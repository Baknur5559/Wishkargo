<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cargo CRM - Admin</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
<style>
    .modal { display: none; position: fixed; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); z-index: 1000; opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0s linear 0.3s; }
    .modal.is-open { display: flex; align-items: center; justify-content: center; opacity: 1; visibility: visible; transition: opacity 0.3s ease; }
    .modal-content { background-color: #fff; padding: 1.5rem; border-radius: 0.5rem; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); max-width: 90%; width: 800px; max-height: 90vh; overflow-y: auto; position: relative; }
    /* --- ИСПРАВЛЕННЫЙ СТИЛЬ ЛОАДЕРА --- */
#loader {
    display: none !important; /* Гарантированно скрыт изначально */
    position: fixed; left: 0; top: 0; width: 100%; height: 100%;
    background-color: rgba(255, 255, 255, 0.7);
    z-index: 2000;
    align-items: center; justify-content: center; /* Применяется только при display: flex */
}
    .loader-spinner { border: 8px solid #f3f3f3; border-top: 8px solid #4f46e5; border-radius: 50%; width: 60px; height: 60px; animation: spin 1s linear infinite; }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    #calculate-modal .modal-content {
        width: 42rem; /* Задаем ширину (max-w-2xl) */
        min-height: 550px; /* Задаем минимальную высоту, чтобы список помещался */
    }
</style>
</head>
<body class="bg-gray-100">
    <div id="loader"><div class="loader-spinner"></div></div>

    <div id="shift-screen" class="hidden min-h-screen flex items-center justify-center">
    <div class="max-w-md w-full bg-white p-8 rounded-lg shadow-lg">
        <h2 class="text-2xl font-bold text-center text-gray-800 mb-6">Открыть новую смену</h2>
        <form id="open-shift-form" class="space-y-4">
            <div id="shift-employee-selector" class="hidden">
                <label for="shift-employee-select" class="block text-sm font-medium text-gray-700">Выберите сотрудника</label>
                <select id="shift-employee-select" required class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm bg-white"></select>
            </div>
            <div id="shift-location-selector" class="hidden">
                <label for="shift-location-select" class="block text-sm font-medium text-gray-700">Выберите филиал</label>
                <select id="shift-location-select" required class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm bg-white"></select>
            </div>
            <div>
                <label for="shift-exchange-rate" class="block text-sm font-medium text-gray-700">Текущий курс $</label>
                <input type="number" step="0.1" id="shift-exchange-rate" required class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md">
            </div>
            <div>
                <label for="shift-price-per-kg" class="block text-sm font-medium text-gray-700">Цена за кг ($)</label>
                <input type="number" step="0.1" id="shift-price-per-kg" required class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md">
            </div>
            <div>
                <label for="starting-cash" class="block text-sm font-medium text-gray-700">Наличные в кассе (сом)</label>
                <input type="number" step="0.01" id="starting-cash" required class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md">
            </div>
            <button type="submit" class="w-full flex justify-center py-2 px-4 border rounded-md shadow-sm font-medium text-white bg-green-600 hover:bg-green-700">Начать смену</button>
             <button type="button" id="cancel-open-shift-btn" class="hidden w-full flex justify-center py-2 px-4 border rounded-md shadow-sm font-medium text-gray-700 bg-gray-200 hover:bg-gray-300 mt-2">Отмена</button>
        </form>
    </div>
</div>

    <div id="login-screen" class="min-h-screen flex items-center justify-center">
        <div class="max-w-md w-full bg-white p-8 rounded-lg shadow-lg">
            <h2 class="text-2xl font-bold text-center text-gray-800 mb-6">Вход в Cargo CRM</h2>
            <form id="login-form">
                <div class="mb-4">
                    <label for="company-code" class="block text-sm font-medium text-gray-700">Код Компании</label>
                    <input type="text" id="company-code" placeholder="Например: SUPER или VISH" required
                           class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm uppercase">
                    <p class="text-xs text-gray-500 mt-1">Для входа как Супер-Админ, введите <b>SUPER</b>.</p>
                </div>
                <div class="mb-4">
                    <label for="password" class="block text-sm font-medium text-gray-700">Пароль</label>
                    <input type="password" id="password" required
                           class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm">
                </div>
                <button type="submit" class="w-full flex justify-center py-2 px-4 border rounded-md shadow-sm text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700">Войти</button>
            </form>
            <p id="login-error" class="text-red-500 text-sm mt-4 text-center"></p>
        </div>
    </div>

    <div id="main-app" class="hidden">
        <div class="max-w-7xl mx-auto p-4 sm:p-6">
            <div class="flex justify-between items-center mb-6">
                <h1 class="text-3xl font-bold text-gray-800">Админ-панель</h1>
                <div class="flex items-center gap-4">
                    <div id="user-info" class="text-right"></div>
                    <div id="company-info" class="text-right border-l pl-4"></div>
                    <button id="logout-btn" title="Выйти из системы" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-3 rounded-lg text-sm">Выйти</button>
                </div>
            </div>
            <div class="border-b border-gray-200">
                <nav class="-mb-px flex space-x-8" id="tabs"></nav>
            </div>
            <div id="tab-content" class="mt-6"></div>
        </div>
    </div>

    <div id="company-modal" class="modal"><div class="modal-content w-full max-w-lg"></div></div>
    <div id="location-modal" class="modal"><div class="modal-content w-full max-w-md"></div></div>
    <div id="employee-modal" class="modal"><div class="modal-content w-full max-w-md"></div></div>
    <div id="role-modal" class="modal"><div class="modal-content w-full max-w-md"></div></div>
    <div id="permissions-modal" class="modal"><div class="modal-content w-full max-w-2xl"></div></div>

    <div id="client-tools-modal" class="modal">
    <div class="modal-content w-full max-w-lg">
        <div class="flex justify-between items-start">
            <h3 class="text-2xl font-bold mb-4">Инструменты для Клиентов</h3>
            <button onclick="closeModal('client-tools-modal')" class="text-2xl font-bold">&times;</button>
        </div>

        <div class="bg-gray-50 p-4 rounded-lg">
            <h4 class="text-lg font-semibold mb-2">Импорт клиентов из Excel</h4>
            <p class="text-sm text-gray-600 mb-1">Обязательные колонки: <strong>full_name</strong>, <strong>phone</strong>.</p>
            <p class="text-sm text-gray-600 mb-4">Необязательно: <strong>client_code</strong> (префикс+номер или только номер).</p>
            <input type="file" id="client-excel-input" accept=".xlsx, .xls" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100"/>
            <button id="import-clients-btn" class="mt-4 w-full bg-blue-600 text-white font-bold py-2 rounded-lg hover:bg-blue-700">Импортировать</button>
            <div id="client-import-results" class="mt-4 text-sm max-h-40 overflow-y-auto border p-2 bg-white rounded"></div>
        </div>

         </div>
</div>

<div id="expense-type-modal" class="modal"><div class="modal-content w-full max-w-md"></div></div>

<div id="client-modal" class="modal">
    <div class="modal-content w-full max-w-md">
        </div>
</div>

<div id="edit-order-modal" class="modal">
    <div class="modal-content w-full max-w-lg">
        </div>
</div>

<div id="buyout-modal" class="modal">
    <div class="modal-content w-full max-w-lg">
        </div>
</div>

<div id="expense-modal" class="modal">
    <div class="modal-content w-full max-w-md">
        </div>
</div>

<div id="issue-modal" class="modal">
    <div class="modal-content w-full max-w-4xl">
        </div>
</div>

<div id="issued-history-modal" class="modal">
    <div class="modal-content w-full max-w-5xl">
        </div>
</div>

<div id="calculate-modal" class="modal">
        <div class="modal-content relative bg-white p-6 rounded-lg shadow-lg max-w-2xl w-full">
            <div class="flex justify-between items-start mb-4">
                <h3 class="text-2xl font-bold">Предварительный расчет</h3>
                <button onclick="closeModal('calculate-modal')" class="text-2xl font-bold">&times;</button>
            </div>

            <div id="calc-step-1-search" class="space-y-4">
                 <label class="block text-sm font-medium">Найдите клиента</label>
                <div class="relative">
                    <input type="text" id="calc-client-search-input" autocomplete="off" placeholder="Введите имя, код или телефон..." class="w-full p-2 border rounded">
                    <div id="calc-client-search-results" class="absolute hidden top-full left-0 right-0 bg-white border mt-1 rounded-md shadow-lg z-30 max-h-48 overflow-y-auto"></div>
                </div>
                <p id="calc-selected-client-info" class="hidden text-center font-semibold p-2 bg-gray-100 rounded"></p>
                <input type="hidden" id="calc-selected-client-id">
            </div>

            <div id="calc-step-2-orders" class="hidden space-y-4 mt-4 border-t pt-4">
                <label class="block text-sm font-medium">Выберите заказы для расчета:</label>
                <div id="calc-orders-list" class="max-h-60 overflow-y-auto space-y-2 border p-2 rounded">
                    <p class="text-gray-500">Сначала выберите клиента.</p>
                </div>
                 <div class="flex items-center">
                    <input type="checkbox" id="calc-select-all-orders" class="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500">
                    <label for="calc-select-all-orders" class="ml-2 text-sm">Выбрать все</label>
                </div>
            </div>

            <div id="calc-step-3-calculation" class="hidden mt-4 border-t pt-4 grid grid-cols-1 md:grid-cols-2 gap-6">
                <div class="space-y-4">
                     <div class="p-3 bg-blue-50 rounded-lg">
                        <label class="block text-sm font-medium">Общий вес (кг)</label>
                        <input type="number" step="any" id="calc-total-weight-input" placeholder="Для авто-распределения" class="mt-1 w-full p-2 border rounded-md">
                    </div>
                    <div id="calc-individual-weights" class="max-h-40 overflow-y-auto pr-2 space-y-2">
                        </div>
                </div>
                 <div class="space-y-4">
                     <div class="p-3 bg-gray-100 rounded-lg space-y-2">
                        <div>
                            <label class="block text-sm">Цена за кг ($) *</label>
                            <input type="number" step="0.1" id="calc-price-per-kg" value="" class="w-full p-2 border rounded" required>
                        </div>
                        <div>
                            <label class="block text-sm">Курс USD (сом) *</label>
                            <input type="number" step="0.1" id="calc-exchange-rate" value="" class="w-full p-2 border rounded" required>
                        </div>
                    </div>
                     <div class="p-4 bg-indigo-50 rounded-lg text-right">
                        <div class="text-lg">Итого к оплате: <span id="calc-total-cost-display" class="font-bold">0.00 сом</span></div>
                     </div>
                </div>
            </div>

            <div id="calc-step-4-actions" class="hidden mt-6 flex justify-between items-center border-t pt-4">
                 <div class="flex items-center gap-2">
                     <label for="calc-new-status-select" class="text-sm">Изменить статус на:</label>
                     <select id="calc-new-status-select" class="p-2 border rounded bg-white text-sm">
                         <option value="">-- Не менять --</option>
                         </select>
                 </div>
                 <div class="flex gap-4">
                    <button type="button" onclick="closeModal('calculate-modal')" class="bg-gray-300 hover:bg-gray-400 text-black font-bold py-2 px-6 rounded-lg">Отмена</button>
                    <button type="button" id="save-calculation-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg">Сохранить</button>
                 </div>
             </div>

        </div>
    </div>

    <div id="assign-client-modal" class="modal">
    <div class="modal-content w-full max-w-lg">
        <div class="flex justify-between items-start mb-4">
            <h3 class="text-2xl font-bold">Назначить клиента</h3>
            <button onclick="closeModal('assign-client-modal')" class="text-2xl font-bold">&times;</button>
        </div>
        <p id="assign-client-info" class="mb-4 font-semibold text-gray-700">Выбрано заказов: 0</p>
        <div class="relative">
            <label for="assign-client-search-input" class="block text-sm font-medium text-gray-700">Поиск клиента (имя, телефон, код)</label>
            <input type="text" id="assign-client-search-input" autocomplete="off" placeholder="Введите имя, код или телефон..." class="w-full p-2 border rounded mt-1">
            <div id="assign-client-search-results" class="absolute hidden top-full left-0 right-0 bg-white border mt-1 rounded-md shadow-lg z-30 max-h-48 overflow-y-auto"></div>
        </div>
        <input type="hidden" id="assign-client-selected-id">
        <p id="assign-client-selected-info" class="hidden text-center font-semibold p-2 bg-gray-100 rounded mt-4"></p>
        <div class="mt-4">
            <label for="assign-client-new-status" class="block text-sm font-medium text-gray-700">Назначить статус:</label>
            <select id="assign-client-new-status" class="mt-1 w-full p-2 border rounded bg-white focus:ring-indigo-500 focus:border-indigo-500">
                </select>
        </div>
        <div class="flex gap-4 mt-6 border-t pt-4">
            <button type="button" onclick="closeModal('assign-client-modal')" class="w-full bg-gray-200 py-2 rounded hover:bg-gray-300">Отмена</button>
            <button type="button" id="assign-client-save-btn" class="w-full bg-green-600 text-white py-2 rounded hover:bg-green-700 disabled:opacity-50" disabled>Подтвердить</button>
        </div>
    </div>
</div>

<script>
// =================================================================
// МОДУЛЬ: ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ И НАСТРОЙКИ (v4.1 - Rebuild)
// =================================================================
const API_URL = 'http://213.148.7.107:8000'; // URL вашего бэкенда
let currentUser = {}; // Данные вошедшего сотрудника { id, full_name, role, permissions, is_super_admin }
let currentCompany = {}; // Данные текущей компании { id, name } (null для SuperAdmin)
let activeShift = null; // Данные активной смены { id, start_time, employee_id, location_id, ... } (null если нет)

// --- Кэши данных (заполняются динамически) ---
// Эти переменные будут хранить списки объектов, загруженные с сервера,
// чтобы не запрашивать их постоянно при открытии модальных окон или рендеринге списков.
let companyLocations = []; // Список объектов Location для текущей компании
let companyRoles = []; // Список объектов Role для текущей компании
let companyPermissions = []; // Список ВСЕХ объектов Permission (глобальные)
let companyClients = []; // Список объектов Client для текущей компании
let companyOrders = []; // Список объектов Order для текущей компании (по последнему фильтру)
let orderStatuses = ["В обработке", "Ожидает выкупа", "Выкуплен", "На складе в Китае", "В пути", "На складе в КР", "Готов к выдаче", "Выдан"]; // Список строк-статусов
let availablePartyDates = []; // Список строк-дат (YYYY-MM-DD)
let companyExpenseTypes = []; // Список объектов ExpenseType для текущей компании

// --- Ссылки на основные DOM-элементы (для быстрого доступа) ---
// Ищем эти элементы ОДИН РАЗ при загрузке скрипта. Если их нет - это критическая ошибка HTML.
const loginScreen = document.getElementById('login-screen');
const mainApp = document.getElementById('main-app');
const loginForm = document.getElementById('login-form');
const loginError = document.getElementById('login-error');
const loader = document.getElementById('loader');
const tabsContainer = document.getElementById('tabs');
const tabContentContainer = document.getElementById('tab-content');

// --- Проверка наличия основных элементов ---
// Если какой-то из этих элементов отсутствует в HTML, дальнейшая работа невозможна.
if (!loginScreen || !mainApp || !loginForm || !loginError || !loader || !tabsContainer || !tabContentContainer) {
    console.error("!!! КРИТИЧЕСКАЯ ОШИБКА: Один или несколько основных элементов DOM (loginScreen, mainApp, loginForm, loginError, loader, tabs, tab-content) не найдены при загрузке скрипта. Проверьте HTML-разметку. !!!");
    // Показываем сообщение пользователю и останавливаем выполнение скрипта
    document.body.innerHTML = '<div style="padding: 20px; text-align: center; color: red; font-size: 1.2em;">Критическая ошибка загрузки интерфейса. Пожалуйста, обратитесь к администратору. Проверьте консоль браузера (F12) для деталей.</div>';
    // Можно выбросить ошибку, чтобы точно остановить скрипт:
    // throw new Error("Критические элементы DOM не найдены.");
} else {
     console.log("[Init] Основные элементы DOM найдены.");
}

// =================================================================
// МОДУЛЬ: УТИЛИТЫ (Вспомогательные функции)
// =================================================================

// Показать/Скрыть индикатор загрузки
const showLoader = () => {
    // Используем setProperty для переопределения !important в CSS, если он есть
    loader?.style.setProperty('display', 'flex', 'important');
};
const hideLoader = () => {
    loader?.style.setProperty('display', 'none', 'important');
};

// Открыть модальное окно по ID
const openModal = (modalId) => {
     const modal = document.getElementById(modalId);
     if (modal) {
          modal.classList.add('is-open');
          console.log(`[Util] Modal opened: #${modalId}`);
     } else {
          console.error(`[Util] openModal: Modal #${modalId} not found.`);
          alert(`Ошибка интерфейса: Не найдено модальное окно ${modalId}`);
     }
};

// Закрыть модальное окно по ID
const closeModal = (modalId) => {
     const modal = document.getElementById(modalId);
     if (modal) {
          modal.classList.remove('is-open');
          console.log(`[Util] Modal closed: #${modalId}`);
     } else {
          console.error(`[Util] closeModal: Modal #${modalId} not found.`);
     }
};

// Обработка ошибок API для извлечения сообщения
async function handleApiError(response) {
    try {
        // Пытаемся прочитать тело ответа как JSON
        const errorJson = await response.json();
        // Возвращаем поле 'detail' (стандарт для FastAPI) или весь JSON, если 'detail' нет
        return errorJson.detail || JSON.stringify(errorJson);
    } catch (e) {
        // Если тело не JSON или произошла другая ошибка, возвращаем статус
        console.warn(`[Util] handleApiError: Could not parse error response as JSON. Status: ${response.status}`);
        return `Статус: ${response.status} - ${response.statusText || 'Unknown Server Error'}`;
    }
}

// --- Общая функция для выполнения запросов к API (ИСПРАВЛЕНА для GET params) ---
async function apiFetch(endpoint, options = {}) {
    // Проверка авторизации перед каждым запросом
    if (!currentUser || !currentUser.id) {
         console.error(`[API] Попытка вызова API (${endpoint}) без авторизации! Перезагрузка...`);
         alert("Ошибка авторизации. Пожалуйста, войдите снова.");
         location.reload();
         throw new Error("Пользователь не авторизован");
    }

    // Установка заголовков по умолчанию
    options.headers = {
        'Content-Type': 'application/json',
        'X-Employee-ID': currentUser.id, // Идентификатор сотрудника
        ...options.headers
    };

    // --- ДОБАВЛЕНО: Обработка параметров для GET запросов ---
    let url = `${API_URL}${endpoint}`;
    const method = options.method?.toUpperCase() || 'GET'; // Определяем метод

    // Если это GET запрос и есть параметры в options.params
    if (method === 'GET' && options.params) {
        // Создаем объект URLSearchParams из options.params
        const searchParams = new URLSearchParams();
        // Проходим по ключам объекта params
        for (const key in options.params) {
            const value = options.params[key];
            // Если значение - массив (например, 'keys' или 'statuses'), добавляем каждый элемент отдельно
            if (Array.isArray(value)) {
                value.forEach(item => searchParams.append(key, item));
            } else if (value !== undefined && value !== null) { // Добавляем только непустые значения
                searchParams.append(key, value);
            }
        }
        // Добавляем параметры к URL, если они есть
        const queryString = searchParams.toString();
        if (queryString) {
            url += `?${queryString}`;
        }
        // Удаляем params из options, чтобы они не мешали fetch
        delete options.params;
    }
    // --- КОНЕЦ ДОБАВЛЕНИЯ ---

    // Логируем исходящий запрос (теперь с правильным URL для GET)
    console.log(`[API] Request: ${method} ${url}`);
    // if (options.body) console.log(`[API] Request Body:`, options.body); // Можно раскомментировать для отладки

    try {
        // Выполняем запрос к API (используем обновленный url)
        const response = await fetch(url, options); // <--- Используем url

        // Логируем статус ответа
        console.log(`[API] Response: ${response.status} ${response.statusText} for ${method} ${url}`);

        // Проверяем статус ответа
        if (!response.ok) {
            const errorDetails = await handleApiError(response);
            console.error(`[API] Error Response Body for ${endpoint}:`, errorDetails);
            throw new Error(errorDetails); // Выбрасываем ошибку
        }

        // Обработка 204 No Content
        if (response.status === 204) {
            console.log(`[API] Received 204 No Content for ${endpoint}`);
            return null;
        }

        // Парсим успешный ответ как JSON
        const data = await response.json();
        // console.log(`[API] Success Response Data for ${endpoint}:`, data); // Раскомментировать для детальной отладки
        return data; // Возвращаем данные

    } catch (error) { // Ловим ошибки сети, парсинга JSON или выброшенные ошибки API
         console.error(`[API] Network or Processing Error for ${endpoint}:`, error);
         // Пробрасываем ошибку дальше
         throw error;
    }
}


// Функция для чтения Excel файла и преобразования в JSON
// Требует подключения библиотеки XLSX в <head> вашего HTML
const readExcelFile = (file) => new Promise((resolve, reject) => {
    // Проверяем, загружена ли библиотека XLSX
    if (typeof XLSX === 'undefined') {
         console.error("!!! [Util] readExcelFile: Библиотека XLSX не найдена. Убедитесь, что она подключена в <head>.");
         return reject(new Error("Ошибка чтения файла: Библиотека XLSX не загружена."));
    }
    // Проверяем, что передан файл
    if (!file) {
         return reject(new Error("Ошибка чтения файла: Файл не выбран."));
    }

    const reader = new FileReader(); // Создаем объект для чтения файла

    // Обработчик успешного чтения файла
    reader.onload = (event) => {
        console.log("[Util] readExcelFile: Файл успешно прочитан.");
        try {
            const data = new Uint8Array(event.target.result); // Получаем данные файла как массив байт
            // Читаем книгу Excel из массива байт
            const workbook = XLSX.read(data, { type: 'array' });
            // Получаем имя первого листа
            const sheetName = workbook.SheetNames[0];
            if (!sheetName) {
                 console.error("!!! [Util] readExcelFile: В Excel файле не найдены листы.");
                 throw new Error("В Excel файле не найдены листы.");
            }
            console.log(`[Util] readExcelFile: Чтение листа "${sheetName}"...`);
            // Получаем данные первого листа
            const worksheet = workbook.Sheets[sheetName];
            // Конвертируем данные листа в массив JSON объектов
            const json = XLSX.utils.sheet_to_json(worksheet);
            console.log(`[Util] readExcelFile: Лист успешно сконвертирован в JSON (${json.length} строк).`);
            resolve(json); // Возвращаем результат (массив объектов)
        } catch (err) {
            console.error("!!! [Util] readExcelFile: Ошибка при обработке Excel данных:", err);
            reject(err); // Возвращаем ошибку обработки
        }
    };

    // Обработчик ошибки чтения файла
    reader.onerror = error => {
         console.error("!!! [Util] readExcelFile: Ошибка чтения файла:", error);
         reject(error);
    };

    // Начинаем чтение файла как ArrayBuffer
    reader.readAsArrayBuffer(file);
    console.log(`[Util] readExcelFile: Начато чтение файла "${file.name}"...`);
});

// Функция для безопасного добавления слушателя событий (с проверкой существования элемента)
// Функция для безопасного добавления слушателя событий (с проверкой существования элемента)
function safeAddEventListener(elementId, eventType, handlerFunction) {
     const element = document.getElementById(elementId);
     if (element) {
         // Удаляем предыдущий слушатель (если функция именованная), чтобы избежать дублей
         try { element.removeEventListener(eventType, handlerFunction); } catch(e){}
         // Добавляем новый слушатель СРАЗУ, так как DOM уже готов
         element.addEventListener(eventType, handlerFunction);
         console.log(`[Listener OK] Added ${eventType} to #${elementId}`);
     } else {
         console.error(`!!! Listener FAILED: Element #${elementId} not found.`);
     }
}

// =================================================================
// МОДУЛЬ: АУТЕНТИФИКАЦИЯ И ИНИЦИАЛИЗАЦИЯ (v4.1 - Rebuild)
// =================================================================

// --- Обработчик входа в систему ---
// Добавляем слушатель к форме входа, если она существует
if (loginForm) {
    loginForm.addEventListener('submit', async (e) => {
        e.preventDefault(); // Предотвращаем стандартную отправку формы
        showLoader(); // Показываем индикатор загрузки
        if(loginError) loginError.textContent = ''; // Очищаем предыдущие ошибки

        // Получаем значения из полей формы
        const companyCodeInput = document.getElementById('company-code');
        const passwordInput = document.getElementById('password');
        const companyCode = companyCodeInput ? companyCodeInput.value.toUpperCase().trim() : null;
        const password = passwordInput ? passwordInput.value : null;

        // Простая валидация на клиенте
        if (!companyCode || !password) {
             if(loginError) loginError.textContent = "Введите код компании и пароль.";
             hideLoader(); // Скрываем лоадер
             return; // Прерываем выполнение
        }

        console.log(`[Auth] Попытка входа с кодом: ${companyCode}`);

        try {
            // Отправляем POST запрос на эндпоинт /login
            const response = await fetch(`${API_URL}/api/login`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ password: password, company_code: companyCode })
            });

            // Проверяем ответ сервера
            if (!response.ok) {
                 // Если сервер вернул ошибку, получаем текст ошибки и выбрасываем исключение
                 throw new Error(await handleApiError(response));
            }

            // Если ответ успешный, парсим JSON
            const data = await response.json();
            currentUser = data.employee; // Сохраняем данные пользователя в глоб. переменную
            currentCompany = data.company; // Сохраняем данные компании (или null для SuperAdmin)
            console.log("[Auth] Успешный вход:", currentUser, currentCompany);

            // --- Проверка необходимости открытия смены ---
            // Выполняется ТОЛЬКО для ОБЫЧНЫХ СОТРУДНИКОВ (не Владелец, не SuperAdmin)
             if (!currentUser.is_super_admin && currentUser.role !== 'Владелец') {
                  console.log("[Auth] Проверка активной смены для обычного сотрудника...");
                  await checkActiveShiftStatus(); // Проверяем статус смены на сервере (обновляет глоб. activeShift)

                  if (!activeShift) { // Если активной смены НЕТ
                       console.log("[Auth] Активной смены нет.");
                       // Проверяем, есть ли у сотрудника права на открытие смены
                       if (currentUser.permissions && currentUser.permissions.includes('open_close_shift')) {
                            // Если ПРАВА ЕСТЬ -> Показываем экран открытия смены
                            console.log("[Auth] Есть права, показываем экран открытия смены.");
                            await showOpenShiftScreen(); // Эта функция отрисует экран и добавит ЕГО слушатели
                            // ВАЖНО: НЕ продолжаем инициализацию основного приложения здесь
                            return; // Выходим из обработчика входа, т.к. показали другой экран
                       } else {
                           // Если ПРАВ НЕТ -> Показываем ошибку и прерываем вход
                           console.error("[Auth] Нет прав на открытие смены.");
                           throw new Error("Нет активной смены в вашем филиале и нет прав на ее открытие. Обратитесь к администратору.");
                       }
                  }
                   console.log("[Auth] Активная смена найдена, продолжаем вход.");
                  // Если смена ЕСТЬ - просто продолжаем выполнение кода ниже
             } else {
                  console.log("[Auth] Вход SuperAdmin или Владельца, проверка активной смены не требуется.");
                  activeShift = null; // Убеждаемся, что для них activeShift = null
             }

             // --- Инициализация основного UI и Глобальных слушателей ---
             // Этот код выполняется, если это SuperAdmin, Владелец, ИЛИ если у обычного сотрудника есть активная смена
             console.log("[Auth] Инициализация основного интерфейса...");
             await initializeMainAppUI(); // Рендерим HTML основного приложения (шапка, вкладки, контент активной вкладки)
             console.log("[Auth] Инициализация глобальных слушателей...");
             initializeGlobalEventListeners(); // Добавляем ГЛОБАЛЬНЫЕ слушатели (кнопка Выход, контейнер вкладок и т.д.)

             // Переключаем видимость экранов
             if(loginScreen) loginScreen.classList.add('hidden');
             if(mainApp) mainApp.classList.remove('hidden');
             console.log("[Auth] Переключение на основное приложение завершено.");
             // hideLoader() будет вызван в finally функции initializeMainAppUI

        } catch (error) { // Обработка ЛЮБЫХ ошибок (сеть, сервер, проверка смены, инициализация UI)
            console.error("[Auth] Ошибка входа:", error);
            if(loginError) loginError.textContent = error.message; // Показываем ошибку пользователю
            // Убеждаемся, что лоадер скрыт, если мы остались на экране входа (или если экран смены не был показан)
            const shiftScreen = document.getElementById('shift-screen');
            if (!shiftScreen || shiftScreen.classList.contains('hidden')) {
                 hideLoader();
            }
        }
    });
} else {
     // Эта ошибка не должна возникать, если основной HTML корректен
     console.error("!!! КРИТИЧЕСКАЯ ОШИБКА: Элемент login-form не найден! Вход невозможен.");
     alert("Ошибка интерфейса: Форма входа не найдена.");
     hideLoader(); // Скрываем лоадер на всякий случай
}


// --- Инициализация основного интерфейса (ТОЛЬКО рендеринг HTML) ---
// Вызывается ПОСЛЕ успешного входа (и проверки смены, если нужно)
// index.html (ПОЛНОСТЬЮ ЗАМЕНЯЕТ initializeMainAppUI)

async function initializeMainAppUI() {
    console.log("[UI] initializeMainAppUI: Начало рендеринга UI");
    try {
        // 1. Отображаем информацию о пользователе и компании
        console.log("[UI] Отображение user/company info...");
        const userInfoDiv = document.getElementById('user-info');
        const companyInfoDiv = document.getElementById('company-info');
        const logoutBtn = document.getElementById('logout-btn');

        if (!userInfoDiv || !companyInfoDiv || !logoutBtn) {
            throw new Error("Критическая ошибка UI: Не найдены элементы шапки.");
        }

        userInfoDiv.innerHTML = `<p class="font-semibold">${currentUser.full_name || 'Имя не указано'}</p><p class="text-sm text-gray-600">${currentUser.role || 'Роль не указана'}</p>`;
        if (currentCompany && currentCompany.name) {
            companyInfoDiv.innerHTML = `<p class="font-semibold">${currentCompany.name}</p><p class="text-sm text-gray-600">Компания</p>`;
        } else if (currentUser.is_super_admin) {
            companyInfoDiv.innerHTML = `<p class="font-semibold text-purple-600">Super-Admin</p><p class="text-sm text-gray-600">Глобальный доступ</p>`;
        } else {
            companyInfoDiv.innerHTML = '';
        }

        // 2. Добавляем/обновляем контейнер для кнопки управления сменой
        console.log("[UI] Создание/обновление shiftControlDiv...");
        let shiftControlDiv = document.getElementById('shift-control-container');
        if (!shiftControlDiv) {
            shiftControlDiv = document.createElement('div');
            shiftControlDiv.id = 'shift-control-container';
            logoutBtn.parentNode?.insertBefore(shiftControlDiv, logoutBtn);
        }
        await updateShiftControlButtonUI();
        console.log("[UI] HTML кнопки смены обновлен.");

        // --- КРИТИЧЕСКОЕ ИСПРАВЛЕНИЕ: Предзагрузка данных (Филиалы) ---
        // Мы должны загрузить филиалы ДО того, как будем рендерить вкладки,
        // так как фильтры филиалов (на вкладках Заказы, Выдача, Отчеты) зависят от companyLocations.
        if (!currentUser.is_super_admin && (!companyLocations || companyLocations.length === 0)) {
            try {
                console.log("[UI] Предзагрузка филиалов (companyLocations)...");
                companyLocations = await apiFetch('/api/locations');
                console.log("[UI] Филиалы успешно загружены:", companyLocations.length);
            } catch (e) {
                console.error("!!! [UI] КРИТИЧЕСКАЯ ОШИБКА: Не удалось загрузить филиалы:", e.message);
                companyLocations = []; // Устанавливаем пустой массив, чтобы избежать ошибок
            }
        }
        // --- КОНЕЦ ИСПРАВЛЕНИЯ ---

        // 3. Генерируем HTML для вкладок на основе прав пользователя
        console.log("[UI] Генерация HTML вкладок...");
        if (!tabsContainer || !tabContentContainer) throw new Error("Не найдены контейнеры вкладок.");

        let tabsHtml = '';
        let contentHtml = '';
        const userPerms = new Set(currentUser.permissions || []);

        // Определяем, какие вкладки показывать
        if (currentUser.is_super_admin) {
            if (userPerms.has('manage_companies')) { tabsHtml += '<button data-tab="companies" class="tab-btn">Управление Компаниями</button>'; contentHtml += '<div id="tab-companies" class="tab-pane"></div>'; }
        } else { // Для Владельца и других ролей
            if (userPerms.has('manage_locations')) { tabsHtml += '<button data-tab="locations" class="tab-btn">Филиалы</button>'; contentHtml += '<div id="tab-locations" class="tab-pane"></div>'; }
            if (userPerms.has('manage_employees')) { tabsHtml += '<button data-tab="employees" class="tab-btn">Персонал</button>'; contentHtml += '<div id="tab-employees" class="tab-pane"></div>'; }
            if (userPerms.has('manage_roles')) { tabsHtml += '<button data-tab="roles" class="tab-btn">Должности и Доступы</button>'; contentHtml += '<div id="tab-roles" class="tab-pane"></div>'; }
            if (userPerms.has('manage_clients')) { tabsHtml += '<button data-tab="clients" class="tab-btn">Клиенты</button>'; contentHtml += '<div id="tab-clients" class="tab-pane"></div>'; }
            if (userPerms.has('manage_orders')) { tabsHtml += '<button data-tab="orders" class="tab-btn">Заказы</button>'; contentHtml += '<div id="tab-orders" class="tab-pane"></div>'; }
            if (userPerms.has('issue_orders')) { tabsHtml += '<button data-tab="issue" class="tab-btn">Выдача</button>'; contentHtml += '<div id="tab-issue" class="tab-pane"></div>'; }
            if (userPerms.has('manage_expense_types')) { tabsHtml += '<button data-tab="expense-types" class="tab-btn">Типы Расходов</button>'; contentHtml += '<div id="tab-expense-types" class="tab-pane"></div>'; }
            if (userPerms.has('add_expense') || userPerms.has('view_full_reports')) { tabsHtml += '<button data-tab="expenses" class="tab-btn">Расходы</button>'; contentHtml += '<div id="tab-expenses" class="tab-pane"></div>'; }
            if (userPerms.has('view_shift_report') || userPerms.has('view_full_reports')) {
                tabsHtml += '<button data-tab="reports" class="tab-btn">Отчеты</button>'; 
                contentHtml += '<div id="tab-reports" class="tab-pane"></div>'; 
            }
            // --- ДОБАВЬ ЭТИ ДВЕ СТРОКИ (Только Владелец видит Настройки) ---
            if (currentUser.role === 'Владелец') {
                 tabsHtml += '<button data-tab="settings" class="tab-btn">Настройки</button>';
                 contentHtml += '<div id="tab-settings" class="tab-pane"></div>';
            }
            // --- КОНЕЦ ДОБАВЛЕНИЯ ---
        }
        
        tabsContainer.innerHTML = tabsHtml.replaceAll('class="tab-btn"', 'class="tab-btn whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300"'); 
        tabContentContainer.innerHTML = contentHtml;
        console.log("[UI] HTML вкладок сгенерирован и установлен.");

        // 4. Вызываем функции рендеринга (теперь companyLocations ГАРАНТИРОВАННО существует)
        console.log("[UI] Вызов функций рендеринга для доступных вкладок...");
        const renderPromises = [];
        if (document.getElementById('tab-companies')) renderPromises.push(renderCompaniesTab());
        if (document.getElementById('tab-locations')) renderPromises.push(renderLocationsTab());
        if (document.getElementById('tab-employees')) renderPromises.push(renderEmployeesTab());
        if (document.getElementById('tab-roles')) renderPromises.push(renderRolesTab());
        if (document.getElementById('tab-clients')) renderPromises.push(renderClientsTab());
        if (document.getElementById('tab-orders')) renderPromises.push(renderOrdersTab());
        if (document.getElementById('tab-issue')) renderPromises.push(renderIssueTab());
        if (document.getElementById('tab-expense-types')) renderPromises.push(renderExpenseTypesTab());
        if (document.getElementById('tab-expenses')) renderPromises.push(renderExpensesTab());
        if (document.getElementById('tab-reports')) renderPromises.push(renderReportsTab());
        if (document.getElementById('tab-settings')) renderPromises.push(renderSettingsTab()); 
        
        await Promise.all(renderPromises); 
        console.log("[UI] Функции рендеринга вкладок завершены.");

        // 5. Активируем первую доступную вкладку
        const firstTab = tabsContainer.querySelector('.tab-btn');
        if (firstTab) {
            console.log("[UI] Активация первой вкладки:", firstTab.dataset.tab);
            activateTab(firstTab.dataset.tab);
        } else {
            console.warn("[UI] Не найдено ни одной доступной вкладки для активации.");
            if(tabContentContainer) tabContentContainer.innerHTML = '<p class="p-4 text-center text-gray-500">Нет доступных разделов.</p>';
        }

        console.log("[UI] --- initializeMainAppUI: Успешное завершение рендеринга ---");
    } catch (e) {
        console.error("[UI] !!! initializeMainAppUI: КРИТИЧЕСКАЯ ОШИБКА:", e);
        alert(`Критическая ошибка инициализации интерфейса: ${e.message}\n\nПожалуйста, обновите страницу или обратитесь к администратору.`);
    } finally {
        console.log("[UI] initializeMainAppUI: Блок finally, скрываем лоадер.");
        hideLoader();
    }
}


// --- Добавление ГЛОБАЛЬНЫХ слушателей (вызывается ПОСЛЕ initializeMainAppUI) ---
function initializeGlobalEventListeners() {
     console.log("--- initializeGlobalEventListeners: Добавление ГЛОБАЛЬНЫХ слушателей ---");

     // --- Основные элементы интерфейса (шапка, вкладки) ---
     safeAddEventListener('logout-btn', 'click', () => { if (confirm('Выйти?')) location.reload(); });
     safeAddEventListener('tabs', 'click', e => {
          const tabButton = e.target.closest('.tab-btn');
          if (tabButton) {
              // ИСПРАВЛЕНИЕ: Передаем имя вкладки как строку (dataset.tab), а не сам элемент
              activateTab(tabButton.dataset.tab); 
            }
      });

     // --- Экран открытия смены (слушатели добавляются в showOpenShiftScreen) ---

     // --- Формы и кнопки внутри СТАТИЧНЫХ Модальных Окон ---
     // (Модалки определены в HTML, их содержимое генерируется динамически)
     // Слушатели для форм добавляются в open...Modal функциях ПОСЛЕ генерации HTML формы
     safeAddEventListener('import-clients-btn', 'click', handleClientExcelImport); // Кнопка импорта в модалке Клиентов

     // --- Динамическая кнопка Открыть/Закрыть Смену ---
     // Слушатель для нее добавляется ОТДЕЛЬНО в updateShiftControlButtonUI

     console.log("--- initializeGlobalEventListeners: Добавление ГЛОБАЛЬНЫХ слушателей завершено ---");
}

// Активация вкладки (делает ее видимой и стилизует кнопку)
function activateTab(tabName) { // Функция теперь принимает tabName (строку)
    // Проверка наличия элементов (tabName теперь используется как строка)
    if (!tabName || !tabsContainer || !tabContentContainer) {
         console.error("[ActivateTab] Ошибка: tabName, tabsContainer или tabContentContainer не найдены.");
         return;
    }
    console.log(`[UI] Активация вкладки: ${tabName}`);

    // Снимаем выделение со ВСЕХ кнопок вкладок
    tabsContainer.querySelectorAll('.tab-btn').forEach(btn => {
         btn.classList.remove('border-indigo-500', 'text-indigo-600'); // Убираем активные классы
         btn.classList.add('border-transparent', 'text-gray-500', 'hover:text-gray-700', 'hover:border-gray-300');
    });

    // Находим НАЖАТУЮ кнопку по data-tab
    const activeTabButton = tabsContainer.querySelector(`[data-tab="${tabName}"]`);
    
    if(activeTabButton) {
        // Выделяем НАЖАТУЮ кнопку
        activeTabButton.classList.add('border-indigo-500', 'text-indigo-600'); // Добавляем активные классы
        activeTabButton.classList.remove('border-transparent', 'text-gray-500', 'hover:text-gray-700', 'hover:border-gray-300');
    }
    
    // Скрываем ВСЕ панели с контентом вкладок
    tabContentContainer.querySelectorAll('.tab-pane').forEach(pane => {
         pane.classList.add('hidden');
    });

    // Находим и ПОКАЗЫВАЕМ панель, соответствующую нажатой кнопке
    const activePane = document.getElementById(`tab-${tabName}`);
    if (activePane) {
         activePane.classList.remove('hidden'); // Убираем класс 'hidden'
         console.log(`[UI] Вкладка ${tabName} показана.`);
    } else {
         console.warn(`[UI] Контейнер для вкладки tab-${tabName} не найден.`);
         if (tabContentContainer) { // Показываем сообщение об ошибке в общем контейнере
              tabContentContainer.innerHTML = `<p class="p-4 text-center text-red-500">Ошибка: Контент для вкладки '${tabName}' не найден.</p>`;
         }
    }
}

// =================================================================
// МОДУЛЬ: КАССА И СМЕНЫ (v4.1 - Rebuild)
// =================================================================

// --- Функция проверки статуса активной смены на сервере ---
// Обновляет глобальную переменную `activeShift`
async function checkActiveShiftStatus() {
     activeShift = null; // Сбрасываем перед проверкой
     // Не проверяем для Владельца или SuperAdmin
     if (!currentUser || currentUser.is_super_admin || currentUser.role === 'Владелец') {
          console.log("[Shift Check] Проверка смены не требуется для Владельца/SuperAdmin.");
          return;
     }

     console.log("[Shift Check] Запрос активной смены для сотрудника ID:", currentUser.id);
     try {
         // Запрашиваем активную смену для текущего сотрудника (бэкенд проверит филиал)
         const shiftData = await apiFetch('/api/shifts/active'); // Ожидаем объект смены или null
         activeShift = shiftData; // Сохраняем результат (может быть null)
         console.log("[Shift Check] Результат проверки:", activeShift);
     } catch (error) {
          // Ошибки сети или если бэкенд вернул 4xx/5xx (кроме 404, которую apiFetch обработает как null?)
          console.warn("[Shift Check] Не удалось получить активную смену:", error.message);
          activeShift = null; // Считаем, что смены нет
     }
}

// --- Функция отображения экрана "Открыть новую смену" ---
// Вызывается, если у обычного сотрудника нет активной смены, но есть права
// index.html (ПОЛНОСТЬЮ ЗАМЕНЯЕТ showOpenShiftScreen)

async function showOpenShiftScreen(locationId = null) {
    console.log(`[Shift UI] Показ экрана открытия смены. Целевой филиал: ${locationId || 'Не указан'}`);
    const shiftScreen = document.getElementById('shift-screen');
    const form = document.getElementById('open-shift-form');
    const employeeSelectorDiv = document.getElementById('shift-employee-selector');
    const locationSelectorDiv = document.getElementById('shift-location-selector');
    const employeeSelect = document.getElementById('shift-employee-select');
    const locationSelect = document.getElementById('shift-location-select');
    const cancelBtn = document.getElementById('cancel-open-shift-btn');

    // Проверка наличия элементов
    if (!shiftScreen || !form || !employeeSelectorDiv || !locationSelectorDiv || !employeeSelect || !locationSelect || !cancelBtn) {
        console.error("!!! КРИТИЧЕСКАЯ ОШИБКА UI: Отсутствуют элементы на экране открытия смены.");
        alert("Ошибка интерфейса: Не удалось загрузить экран открытия смены.");
        hideLoader(); 
        return;
    }

    try {
        // --- Предзаполнение полей формы (Курсы, Цена) ---
        const exchangeRateInput = document.getElementById('shift-exchange-rate');
        const pricePerKgInput = document.getElementById('shift-price-per-kg');
        const startingCashInput = document.getElementById('starting-cash');
        
        // Безопасный доступ к sysConfig
        const defaultRate = activeShift?.exchange_rate_usd 
                            || (typeof sysConfig !== 'undefined' && sysConfig.exchange_rate_usd) 
                            || 87.5;
        const defaultPrice = activeShift?.price_per_kg_usd 
                             || (typeof sysConfig !== 'undefined' && sysConfig.price_per_kg_usd) 
                             || 5.5;

        if(exchangeRateInput) exchangeRateInput.value = defaultRate; 
        if(pricePerKgInput) pricePerKgInput.value = defaultPrice;   
        if(startingCashInput) startingCashInput.value = 0;

        // --- Настройка видимости селекторов в зависимости от РОЛИ ---
        
        if (currentUser.role === 'Владелец') {
            // --- ЛОГИКА ДЛЯ ВЛАДЕЛЬЦА ---
            console.log("[Shift UI] Пользователь - Владелец. Загрузка сотрудников и филиалов...");
            
            // Убеждаемся, что кэши загружены
            if (!companyLocations || companyLocations.length === 0) {
                 companyLocations = await apiFetch('/api/locations');
            }
            const employees = await apiFetch('/api/employees'); 

            // Заполняем селектор сотрудников
            if (employeeSelect) {
                employeeSelect.innerHTML = employees
                    .filter(emp => emp.is_active) 
                    .map(emp => `<option value="${emp.id}">${emp.full_name} (${emp.role?.name || '?'})</option>`)
                    .join('');
                // Выбираем Владельца по умолчанию
                employeeSelect.value = currentUser.id; 
            }
            employeeSelectorDiv.classList.remove('hidden'); 
            employeeSelect.required = true; 

            // Заполняем селектор филиалов
            if (locationSelect) {
                 locationSelect.innerHTML = companyLocations
                    .map(loc => `<option value="${loc.id}">${loc.name}</option>`)
                    .join('');
                 
                 // --- КРИТИЧЕСКОЕ ИСПРАВЛЕНИЕ: ВЫБОР ФИЛИАЛА ---
                 // Если Владелец нажал кнопку в шапке (locationId=null), используем его филиал.
                 // Если Владелец нажал кнопку в списке (locationId=6), используем этот ID.
                 locationSelect.value = locationId || currentUser.location_id; 
                 // --- КОНЕЦ ИСПРАВЛЕНИЯ ---
            }
            
            // Показываем селектор филиалов, только если их больше одного
            if (companyLocations.length > 1) {
                locationSelectorDiv.classList.remove('hidden');
                locationSelect.required = true; 
            } else {
                 locationSelectorDiv.classList.add('hidden');
                 locationSelect.required = false; 
            }
            
            cancelBtn.classList.remove('hidden'); 
            console.log("[Shift UI] Селекторы для Владельца настроены.");

        } else { 
            // --- ЛОГИКА ДЛЯ ОБЫЧНОГО СОТРУДНИКА ---
            console.log("[Shift UI] Пользователь - обычный сотрудник. Скрытие селекторов.");
            
            employeeSelectorDiv.classList.add('hidden');
            locationSelectorDiv.classList.add('hidden');
            employeeSelect.required = false; 
            locationSelect.required = false;

            cancelBtn.classList.add('hidden'); 
        }

        // --- Добавляем слушатели к элементам этого экрана ---
        const currentForm = document.getElementById('open-shift-form');
        if (currentForm) {
             const newForm = currentForm.cloneNode(true);
             currentForm.parentNode.replaceChild(newForm, currentForm);
             newForm.addEventListener('submit', handleOpenShiftSubmit);
             console.log("[Shift UI Listener OK] Added submit to #open-shift-form");
        }
        
        const currentCancelBtn = document.getElementById('cancel-open-shift-btn');
        if (currentCancelBtn) {
             const newCancelBtn = currentCancelBtn.cloneNode(true);
             currentCancelBtn.parentNode.replaceChild(newCancelBtn, currentCancelBtn);
             newCancelBtn.addEventListener('click', () => {
                 console.log("[Shift UI] Cancel button clicked.");
                 if(shiftScreen) shiftScreen.classList.add('hidden');
                 // Если отменяем, возвращаемся в Главное приложение (для Владельца)
                 if(mainApp) mainApp.classList.remove('hidden'); 
                 hideLoader();
             });
             console.log("[Shift UI Listener OK] Added click to #cancel-open-shift-btn");
        }

        // Показываем экран открытия смены
        if(loginScreen) loginScreen.classList.add('hidden');
        if(mainApp) mainApp.classList.add('hidden'); 
        if(shiftScreen) shiftScreen.classList.remove('hidden');
        console.log("[Shift UI] Экран открытия смены показан.");

    } catch (error) {
         console.error("[Shift UI] Ошибка подготовки экрана открытия смены:", error);
         alert(`Ошибка подготовки экрана открытия смены: ${error.message}`);
         if(shiftScreen) shiftScreen.classList.add('hidden');
         if(loginScreen) loginScreen.classList.remove('hidden');
    } finally {
         hideLoader(); 
         console.log("[Shift UI] showOpenShiftScreen: End");
    }
}


// index.html (ПОЛНОСТЬЮ ЗАМЕНЯЕТ handleOpenShiftSubmit)

async function handleOpenShiftSubmit(e) {
    e.preventDefault(); // Предотвращаем стандартную отправку
    console.log("[Shift Action] handleOpenShiftSubmit: Start");
    showLoader(); // Показываем лоадер

    let employeeIdToOpen = currentUser.id; 
    let locationIdToOpen = currentUser.location_id; 

    // --- ИСПРАВЛЕННАЯ ЛОГИКА: Определение ID сотрудника и филиала (для Владельца) ---
    if (currentUser.role === 'Владелец') {
        const employeeSelect = document.getElementById('shift-employee-select');
        const locationSelect = document.getElementById('shift-location-select');
        
        // Владелец ВСЕГДА выбирает сотрудника из списка
        if (employeeSelect) {
            employeeIdToOpen = parseInt(employeeSelect.value);
            console.log("[Shift Action] Владелец выбрал сотрудника:", employeeIdToOpen);
        } else {
            // Если селектора нет, используем Владельца (запасной вариант)
            employeeIdToOpen = currentUser.id;
        }

        // Владелец ВСЕГДА выбирает филиал из списка
        if (locationSelect) {
            locationIdToOpen = parseInt(locationSelect.value);
            console.log("[Shift Action] Владелец выбрал филиал:", locationIdToOpen);
        } else {
             // Если селектора нет (например, только 1 филиал в компании)
             if (companyLocations && companyLocations.length === 1) {
                 locationIdToOpen = companyLocations[0].id;
             } else {
                 locationIdToOpen = currentUser.location_id; // Запасной вариант
             }
        }
    }
    // Для обычного сотрудника ID остаются currentUser.id и currentUser.location_id
    // --- КОНЕЦ ИСПРАВЛЕННОЙ ЛОГИКИ ---

    if (!locationIdToOpen) {
        hideLoader();
        console.error("[Shift Action] Ошибка: Не удалось определить ID филиала для открытия смены.");
        alert("Критическая ошибка: Не удалось определить филиал для открытия смены.");
        return;
    }
    
    // Собираем данные из формы
    const startingCashInput = document.getElementById('starting-cash');
    const exchangeRateInput = document.getElementById('shift-exchange-rate');
    const pricePerKgInput = document.getElementById('shift-price-per-kg');

    const payload = {
        employee_id: employeeIdToOpen,
        location_id: locationIdToOpen, // <-- Теперь здесь будет ID выбранного филиала
        starting_cash: startingCashInput ? parseFloat(startingCashInput.value) : 0,
        exchange_rate_usd: exchangeRateInput ? parseFloat(exchangeRateInput.value) : 0,
        price_per_kg_usd: pricePerKgInput ? parseFloat(pricePerKgInput.value) : 0
    };

    // Валидация данных
     if (isNaN(payload.starting_cash) || payload.starting_cash < 0 ||
         isNaN(payload.exchange_rate_usd) || payload.exchange_rate_usd <= 0 ||
         isNaN(payload.price_per_kg_usd) || payload.price_per_kg_usd <= 0) {
           hideLoader();
           alert("Ошибка: Пожалуйста, введите корректные числовые значения.");
           return;
     }

    console.log("[Shift Action] Отправка запроса на открытие смены:", payload);

    try {
        // Отправляем запрос на бэкенд для открытия смены
        const newShift = await apiFetch('/api/shifts/open', {
            method: 'POST',
            body: JSON.stringify(payload)
        });
        
        // ВАЖНО: Бэкенд (main.py, функция open_shift) УЖЕ ИМЕЕТ проверку, 
        // что в ЦЕЛЕВОМ филиале (payload.location_id) нет открытой смены.
        // Поэтому, если вы выберете "Главный филиал", вы получите ошибку (это ПРАВИЛЬНО).
        // Если вы выберете "WishKargo" (где смены нет), бэкенд ее откроет.

        activeShift = newShift; // Сохраняем данные новой активной смены
        console.log("[Shift Action] Смена успешно открыта:", activeShift);
        
        // 1. Переключаем видимость экранов
        const shiftScreen = document.getElementById('shift-screen');
        if(shiftScreen) shiftScreen.classList.add('hidden');
        if(mainApp) mainApp.classList.remove('hidden');
        console.log("[Shift Action] Переход в основное приложение.");

        // 2. СНАЧАЛА инициализируем HTML главного приложения
        await initializeMainAppUI(); 
        
        // 3. ТЕПЕРЬ обновляем кнопку смены
        // (Мы должны убедиться, что get_active_shift вернет смену Владельца, если он ее открыл)
        await updateShiftControlButtonUI(); 

        // 4. Инициализируем ГЛОБАЛЬНЫЕ слушатели
        initializeGlobalEventListeners(); 
        
    } catch (err) { // Обработка ошибок (включая "смена уже открыта")
         console.error("[Shift Action] Ошибка открытия смены:", err);
         alert(`Ошибка открытия смены: ${err.message}`);
         hideLoader(); // Скрываем лоадер при ошибке
    }
     console.log("[Shift Action] handleOpenShiftSubmit: End");
}

// --- Обновление HTML кнопки управления сменой (без добавления слушателя здесь) ---
// Вызывается из initializeMainAppUI
async function updateShiftControlButtonUI() {
     console.log("[Shift Button UI] updateShiftControlButtonUI: Start");
     const container = document.getElementById('shift-control-container');
     if (!container) {
          console.warn("[Shift Button UI] Контейнер #shift-control-container не найден.");
          return; // Выходим, если контейнера нет
     }
     // Для SuperAdmin кнопка не нужна
     if (!currentUser || currentUser.is_super_admin) {
          container.innerHTML = ''; // Очищаем контейнер
          console.log("[Shift Button UI] SuperAdmin, кнопка не нужна.");
          return;
     }

     container.innerHTML = 'Проверка смены...'; // Временный текст

     // Проверяем статус смены ТОЛЬКО если это НЕ Владелец
     if (currentUser.role !== 'Владелец') {
          await checkActiveShiftStatus(); // Обновляем global activeShift
     } else {
          activeShift = null; // Для Владельца смены нет
          console.log("[Shift Button UI] Пользователь - Владелец, activeShift сброшен в null.");
     }


     let buttonHtml = '';
     const buttonId = 'shift-action-btn'; // ID для кнопки

     // Определяем, какой HTML показать
     if (activeShift && currentUser.id === activeShift.employee_id) {
          // Если смена активна И это смена ТЕКУЩЕГО сотрудника -> Кнопка "Закрыть"
          console.log("[Shift Button UI] Смена активна (текущего сотрудника), генерируем 'Закрыть'.");
          buttonHtml = `<button id="${buttonId}" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg text-sm animate-pulse">Закрыть смену #${activeShift.id}</button>`;
     } else if (!activeShift && currentUser.permissions?.includes('open_close_shift')) {
           // Если смены НЕТ И есть ПРАВА на открытие -> Кнопка "Открыть"
           console.log("[Shift Button UI] Смена закрыта, есть права, генерируем 'Открыть'.");
           buttonHtml = `<button id="${buttonId}" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg text-sm">Открыть смену</button>`;
     } else if (activeShift && currentUser.role === 'Владелец'){
          // Если Владелец видит активную смену ДРУГОГО сотрудника -> Показываем инфо
          console.log("[Shift Button UI] Владелец видит активную смену другого сотрудника (ID:", activeShift.id, ")");
          // TODO: Получить имя сотрудника смены?
           buttonHtml = `<span class="text-sm text-yellow-600 font-semibold" title="Смена ID ${activeShift.id} активна">Смена активна</span>`;
           // TODO: Может Владелец должен иметь возможность принудительно закрыть чужую смену?
     } else { // Смена закрыта и нет прав ИЛИ смена открыта другим (не владельцем)
          console.log("[Shift Button UI] Смена закрыта (нет прав) или открыта другим.");
          buttonHtml = `<span class="text-sm text-red-600 font-semibold">Смена закрыта</span>`;
     }

     // Устанавливаем HTML
     container.innerHTML = buttonHtml;
     console.log("[Shift Button UI] HTML кнопки обновлен.");

     // --- Добавляем слушатель к ТОЛЬКО ЧТО созданной кнопке (если она есть) ---
     const actionButton = document.getElementById(buttonId);
     if (actionButton) {
          let listenerFunc = null;
          if (activeShift && currentUser.id === activeShift.employee_id) {
               listenerFunc = handleCloseShiftClick; // Функция закрытия
          } else if (!activeShift && currentUser.permissions?.includes('open_close_shift')) {
               listenerFunc = () => { // Функция открытия (показ экрана)
                   console.log("[Shift Button UI] Клик по кнопке 'Открыть смену'");
                   if(mainApp) mainApp.classList.add('hidden');
                   showOpenShiftScreen(); // Показываем экран открытия
               };
          }

          if (listenerFunc) {
               // Удаляем старый слушатель перед добавлением нового
               actionButton.replaceWith(actionButton.cloneNode(true));
               document.getElementById(buttonId)?.addEventListener('click', listenerFunc);
               console.log(`[Shift Button Listener OK] Added click to #${buttonId}`);
          }
     } else {
          console.log(`[Shift Button UI] Кнопка #${buttonId} не найдена или для нее не нужен слушатель.`);
     }
     console.log("[Shift Button UI] updateShiftControlButtonUI: End");
}


// --- Обработчик нажатия кнопки "Закрыть смену" ---
async function handleCloseShiftClick() {
     if (!activeShift) {
          console.warn("[Shift Action] Попытка закрыть смену, но activeShift is null.");
          alert("Ошибка: Не найдена активная смена для закрытия.");
          await updateShiftControlButtonUI(); // Обновим кнопку на всякий случай
          return;
     }
     console.log(`[Shift Action] handleCloseShiftClick: Start closing shift ID ${activeShift.id}`);

     // Запрашиваем сумму наличных в кассе
     const closingCashStr = prompt(`Закрытие смены #${activeShift.id}.\nВведите итоговую сумму НАЛИЧНЫХ в кассе (сом):`);
     // Проверяем, нажал ли пользователь Отмена
     if (closingCashStr === null) {
         console.log("[Shift Action] Закрытие смены отменено пользователем.");
         return; // Выходим, если Отмена
     }

     // Проверяем введенное значение
     const closingCash = parseFloat(closingCashStr);
     if (isNaN(closingCash) || closingCash < 0) {
         alert("Некорректная сумма. Введите положительное число.");
         return; // Выходим, если сумма некорректна
     }

     console.log(`[Shift Action] Введена сумма закрытия: ${closingCash}`);
     showLoader(); // Показываем лоадер перед запросом

     try {
         // Отправляем запрос на бэкенд для закрытия смены
         await apiFetch('/api/shifts/close', {
             method: 'POST',
             body: JSON.stringify({ closing_cash: closingCash }) // Отправляем сумму
         });
         console.log(`[Shift Action] Смена #${activeShift.id} успешно закрыта на сервере.`);
         alert(`Смена #${activeShift.id} успешно закрыта!`);
         activeShift = null; // Сбрасываем глобальную переменную

         // Перезагружаем страницу, чтобы пользователь вышел из системы
         console.log("[Shift Action] Перезагрузка страницы...");
         location.reload();

     } catch (err) { // Обработка ошибок от apiFetch
         console.error("[Shift Action] Ошибка закрытия смены:", err);
         alert(`Ошибка закрытия смены: ${err.message}`);
         hideLoader(); // Скрываем лоадер только при ошибке (при успехе страница перезагрузится)
     }
     // При успехе hideLoader не нужен, т.к. страница перезагружается
     console.log("[Shift Action] handleCloseShiftClick: End");
}

// =================================================================
// МОДУЛЬ: ТИПЫ РАСХОДОВ (Владелец) (v4.1 - Rebuild)
// =================================================================
companyExpenseTypes = []; // Кэш для хранения списка типов расходов

// --- Рендеринг вкладки "Типы Расходов" ---
// Вызывается из initializeMainAppUI, если у пользователя есть права
async function renderExpenseTypesTab() {
    console.log("[Render] renderExpenseTypesTab: Start");
    const pane = document.getElementById('tab-expense-types');
    if (!pane) {
        console.warn("[Render] renderExpenseTypesTab: Pane #tab-expense-types not found.");
        return; // Выходим, если контейнер вкладки не найден
    }

    // Генерируем основной HTML для вкладки
    pane.innerHTML = `
        <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
            <div class="md:col-span-1">
                <div class="bg-white p-6 rounded-lg shadow-md h-fit">
                    <h2 class="text-xl font-semibold mb-4">Добавить Тип Расхода</h2>
                    <form id="add-expense-type-form" class="space-y-3">
                        <label for="new-expense-type-name" class="block text-sm font-medium text-gray-700">Название</label>
                        <input type="text" id="new-expense-type-name" placeholder="Например: Аренда, Канцтовары" class="w-full p-2 border rounded" required>
                        <button type="submit" class="w-full bg-indigo-600 text-white font-bold py-2 rounded-lg hover:bg-indigo-700">Создать Тип</button>
                    </form>
                </div>
            </div>
            <div class="md:col-span-2">
                 <div class="bg-white p-6 rounded-lg shadow-md">
                    <h2 class="text-2xl font-bold mb-4">Существующие Типы Расходов</h2>
                    <div id="expense-types-list" class="space-y-3">Загрузка типов...</div>
                </div>
            </div>
        </div>
    `;

    // --- Добавляем слушатели к элементам, созданным ВЫШЕ ---
    const addForm = document.getElementById('add-expense-type-form');
    const typeListDiv = document.getElementById('expense-types-list');

    if (addForm) {
        // Удаляем старый слушатель перед добавлением нового
        addForm.replaceWith(addForm.cloneNode(true));
        document.getElementById('add-expense-type-form').addEventListener('submit', handleAddExpenseType);
        console.log("[Listener OK] Added submit to #add-expense-type-form");
    } else {
        console.error("!!! renderExpenseTypesTab: Element #add-expense-type-form NOT FOUND after innerHTML.");
    }

    if (typeListDiv) {
         // Используем делегирование событий для кнопок внутри списка
         typeListDiv.replaceWith(typeListDiv.cloneNode(true)); // Удаляем старые
         document.getElementById('expense-types-list').addEventListener('click', handleExpenseTypeActions);
         console.log("[Listener OK] Added click listener to #expense-types-list");
    } else {
         console.error("!!! renderExpenseTypesTab: Element #expense-types-list NOT FOUND after innerHTML.");
    }
    // --- Конец добавления слушателей ---

    // Загружаем и отображаем данные
    await fetchAndRenderExpenseTypes();
    console.log("[Render] renderExpenseTypesTab: End");
}

// --- Загрузка и отображение списка Типов Расходов ---
async function fetchAndRenderExpenseTypes() {
     console.log("[Fetch] fetchAndRenderExpenseTypes: Start");
     const listDiv = document.getElementById('expense-types-list');
     if (!listDiv) return; // Проверка на случай, если элемент исчез
     listDiv.innerHTML = '<p class="text-gray-500 animate-pulse">Загрузка типов расходов...</p>'; // Улучшенная заглушка
     // Не показываем глобальный лоадер здесь, т.к. загрузка обычно быстрая
     // showLoader();
     try {
         // Запрашиваем типы расходов для текущей компании
         const types = await apiFetch('/api/expense_types');
         companyExpenseTypes = types; // Обновляем кэш

         if (!types || types.length === 0) {
             listDiv.innerHTML = '<p class="text-gray-500">У вашей компании еще нет типов расходов. Создайте первый!</p>';
         } else {
             // Отображаем список с кнопками Редактировать/Удалить
             listDiv.innerHTML = types.map(t => `
                 <div class="p-3 bg-gray-50 rounded-md flex flex-wrap justify-between items-center gap-2">
                     <p class="font-bold flex-grow">${t.name}</p>
                     <div class="flex-shrink-0 flex gap-2">
                        <button data-type-id="${t.id}" data-type-name="${t.name}" class="edit-expense-type-btn text-sm bg-gray-200 hover:bg-gray-300 px-3 py-1 rounded">Изменить</button>
                        <button data-type-id="${t.id}" data-type-name="${t.name}" class="delete-expense-type-btn text-sm bg-red-200 hover:bg-red-300 text-red-800 px-3 py-1 rounded">Удалить</button>
                     </div>
                 </div>
             `).join('');
         }
         console.log("[Fetch] fetchAndRenderExpenseTypes: Success");
     } catch (e) {
         console.error("[Fetch] fetchAndRenderExpenseTypes: Error", e);
         listDiv.innerHTML = `<p class="text-red-500">Ошибка загрузки типов расходов: ${e.message}</p>`;
     } finally {
         // hideLoader();
     }
}

// --- Обработчик для формы "Добавить Тип Расхода" ---
async function handleAddExpenseType(e) {
    e.preventDefault(); // Предотвращаем перезагрузку
    console.log("[Expense Type Action] handleAddExpenseType: Start");
    const nameInput = document.getElementById('new-expense-type-name');
    const name = nameInput ? nameInput.value.trim() : null;

    if (!name) {
        alert("Введите название типа расхода.");
        return;
    }
    showLoader(); // Показываем лоадер перед запросом
    try {
        // Отправляем POST запрос на создание
        await apiFetch('/api/expense_types', {
             method: 'POST',
             body: JSON.stringify({ name: name })
        });
        alert(`Тип расхода "${name}" успешно создан.`);
        if(nameInput) nameInput.value = ''; // Очищаем поле ввода
        await fetchAndRenderExpenseTypes(); // Обновляем список на странице
    } catch(err) {
        console.error("[Expense Type Action] handleAddExpenseType: Error", err);
        alert(`Ошибка создания типа расхода: ${err.message}`);
    } finally {
        hideLoader(); // Скрываем лоадер
        console.log("[Expense Type Action] handleAddExpenseType: End");
    }
}

// --- Обработчик кликов по кнопкам в списке Типов Расходов (делегирование) ---
function handleExpenseTypeActions(e) {
     // Ищем ближайшую кнопку к месту клика
     const btn = e.target.closest('button');
     if (!btn) return; // Клик не по кнопке

     const typeId = btn.dataset.typeId;
     const typeName = btn.dataset.typeName;

     // Определяем действие по классу кнопки
     if (btn.classList.contains('edit-expense-type-btn')) {
          console.log(`[Expense Type Action] Edit button clicked for ID: ${typeId}`);
          // Находим данные типа в кэше
          const currentType = companyExpenseTypes.find(t => t.id == typeId); // Используем '==' для сравнения строки и числа
          if (currentType) {
               openExpenseTypeModal(currentType); // Открываем модальное окно для редактирования
          } else {
               console.error(`!!! Edit Expense Type: Type with ID ${typeId} not found in cache.`);
               alert("Ошибка: Не удалось найти данные для редактирования.");
          }
     } else if (btn.classList.contains('delete-expense-type-btn')) {
          console.log(`[Expense Type Action] Delete button clicked for ID: ${typeId}`);
          // Запрашиваем подтверждение перед удалением
          if (confirm(`Вы уверены, что хотите удалить тип расхода "${typeName}"?\n\nЭто действие необратимо.`)) {
               handleDeleteExpenseType(typeId, typeName); // Вызываем функцию удаления
          }
     }
}

// --- Открытие модального окна для Типа Расхода ---
function openExpenseTypeModal(expenseType = null) {
     console.log("[Modal] openExpenseTypeModal: Start", expenseType);
     const modal = document.getElementById('expense-type-modal');
     if (!modal) return console.error("!!! openExpenseTypeModal: Modal element #expense-type-modal not found!");
     const modalContent = modal.querySelector('.modal-content');
     if (!modalContent) return console.error("!!! openExpenseTypeModal: Modal content not found!");

     const isEdit = expenseType !== null;

     // Генерируем HTML для модального окна
     modalContent.innerHTML = `
         <div class="flex justify-between items-start">
             <h3 class="text-2xl font-bold mb-4">${isEdit ? 'Редактировать Тип Расхода' : 'Создать Тип Расхода'}</h3>
             <button onclick="closeModal('expense-type-modal')" class="text-2xl font-bold">&times;</button>
         </div>
         <form id="expense-type-form-inner" data-type-id="${isEdit ? expenseType.id : ''}" class="space-y-4">
             <div>
                 <label for="modal-expense-type-name" class="block text-sm font-medium text-gray-700">Название *</label>
                 <input type="text" id="modal-expense-type-name" value="${isEdit ? expenseType.name : ''}" class="mt-1 w-full p-2 border rounded" required>
             </div>
             <div class="flex gap-4 mt-6 border-t pt-4">
                 <button type="button" onclick="closeModal('expense-type-modal')" class="w-full bg-gray-200 py-2 rounded hover:bg-gray-300">Отмена</button>
                 <button type="submit" class="w-full bg-green-600 text-white py-2 rounded hover:bg-green-700">Сохранить</button>
             </div>
         </form>
     `;

     // --- Добавляем слушатель submit к ТОЛЬКО ЧТО созданной форме ---
     const formElement = document.getElementById('expense-type-form-inner');
     if (formElement) {
         formElement.replaceWith(formElement.cloneNode(true)); // Удаляем старые слушатели
         document.getElementById('expense-type-form-inner').addEventListener('submit', handleSaveExpenseType);
         console.log("[Modal Listener OK] Added submit to #expense-type-form-inner");
     } else {
         console.error("!!! openExpenseTypeModal: Form #expense-type-form-inner NOT FOUND after innerHTML!");
     }
     // --- Конец добавления слушателя ---

     openModal('expense-type-modal'); // Открываем модальное окно
     console.log("[Modal] openExpenseTypeModal: End");
 }

// --- Сохранение данных Типа Расхода ---
async function handleSaveExpenseType(e) {
     e.preventDefault();
     console.log("[Save] handleSaveExpenseType: Start");
     showLoader();
     const form = e.target;
     const typeId = form.dataset.typeId;
     const isEdit = !!typeId;
     const nameInput = document.getElementById('modal-expense-type-name');
     const name = nameInput ? nameInput.value.trim() : null;

     if (!name) {
         hideLoader();
         alert("Название типа расхода не может быть пустым.");
         return;
     }

     const url = isEdit ? `/expense_types/${typeId}` : '/expense_types';
     const method = isEdit ? 'PATCH' : 'POST';
     const payload = { name: name };

     try {
         console.log(`[Save] handleSaveExpenseType: Sending ${method} to ${url}`, payload);
         await apiFetch(url, { method: method, body: JSON.stringify(payload) });
         alert(isEdit ? 'Тип расхода успешно обновлен!' : 'Тип расхода успешно создан!');
         closeModal('expense-type-modal');
         await fetchAndRenderExpenseTypes(); // Обновляем список
     } catch (err) {
         console.error("[Save] handleSaveExpenseType: Error", err);
         alert(`Ошибка сохранения типа расхода: ${err.message}`);
     } finally {
         hideLoader();
         console.log("[Save] handleSaveExpenseType: End");
     }
 }

// --- Удаление Типа Расхода ---
async function handleDeleteExpenseType(typeId, typeName) {
    console.log(`[Delete] handleDeleteExpenseType: Start deleting ID ${typeId} (${typeName})`);
    showLoader();
    try {
        // Отправляем DELETE запрос на бэкенд
        await apiFetch(`/api/expense_types/${typeId}`, { method: 'DELETE' });
        alert(`Тип расхода "${typeName}" успешно удален.`);
        await fetchAndRenderExpenseTypes(); // Обновляем список
    } catch(err) {
        console.error("[Delete] handleDeleteExpenseType: Error", err);
        // Бэкенд вернет ошибку (400), если тип используется, apiFetch ее обработает
        alert(`Ошибка удаления типа расхода: ${err.message}`);
    } finally {
        hideLoader();
        console.log("[Delete] handleDeleteExpenseType: End");
    }
}

// =================================================================
// МОДУЛЬ: УПРАВЛЕНИЕ КОМПАНИЯМИ (Super-Admin) (v4.1 - Rebuild)
// =================================================================

// --- Рендеринг вкладки "Управление Компаниями" ---
// Вызывается из initializeMainAppUI, если пользователь SuperAdmin и имеет права
async function renderCompaniesTab() {
    console.log("[Render] renderCompaniesTab: Start");
    const pane = document.getElementById('tab-companies');
    if (!pane) {
         console.warn("[Render] renderCompaniesTab: Pane #tab-companies not found.");
         return; // Выходим, если контейнер вкладки не найден
    }

    // Генерируем HTML для вкладки
    pane.innerHTML = `
        <div class="bg-white p-6 rounded-lg shadow-md">
            <div class="flex flex-wrap justify-between items-center gap-4 mb-4">
                <h2 class="text-2xl font-bold">Управление Компаниями-Арендаторами</h2>
                <button id="add-company-btn" class="bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700">➕ Добавить Компанию</button>
            </div>
            <div id="companies-list" class="space-y-3">Загрузка списка компаний...</div>
        </div>
    `;

    // --- Добавляем слушатели к элементам, созданным ВЫШЕ ---
    const addBtn = document.getElementById('add-company-btn');
    const companyListDiv = document.getElementById('companies-list');

    if (addBtn) {
        // Используем replaceWith(cloneNode) для удаления старых слушателей перед добавлением нового
        const newAddBtn = addBtn.cloneNode(true);
        addBtn.parentNode?.replaceChild(newAddBtn, addBtn);
        newAddBtn.addEventListener('click', () => openCompanyModal()); // Добавляем слушатель к НОВОЙ кнопке
        console.log("[Listener OK] Added click to #add-company-btn");
    } else {
        console.error("!!! renderCompaniesTab: Element #add-company-btn NOT FOUND after innerHTML.");
    }

    if (companyListDiv) {
         // Используем делегирование событий для кнопок Редактировать/Удалить внутри списка
         const newCompanyListDiv = companyListDiv.cloneNode(false); // Клонируем пустой контейнер
         companyListDiv.parentNode?.replaceChild(newCompanyListDiv, companyListDiv); // Заменяем старый
         newCompanyListDiv.innerHTML = 'Загрузка списка компаний...'; // Восстанавливаем заглушку
         newCompanyListDiv.addEventListener('click', handleCompanyActions); // Добавляем слушатель к НОВОМУ контейнеру
         console.log("[Listener OK] Added click delegate listener to #companies-list");
    } else {
         console.error("!!! renderCompaniesTab: Element #companies-list NOT FOUND after innerHTML.");
    }
    // --- Конец добавления слушателей ---

    // Загружаем и отображаем данные в ТОЛЬКО ЧТО созданном #companies-list
    await fetchAndRenderCompanies();
    console.log("[Render] renderCompaniesTab: End");
}

// --- Загрузка и отображение списка компаний ---
async function fetchAndRenderCompanies() {
    console.log("[Fetch] fetchAndRenderCompanies: Start");
    const listDiv = document.getElementById('companies-list'); // Ищем контейнер заново
    if (!listDiv) {
        console.error("!!! fetchAndRenderCompanies: listDiv #companies-list not found!");
        return; // Выходим, если контейнер не найден (не должно произойти)
    }
    listDiv.innerHTML = '<p class="text-gray-500 animate-pulse">Загрузка компаний...</p>';
    // Не показываем глобальный лоадер
    try {
        // Запрашиваем список компаний у бэкенда
        const companies = await apiFetch('/api/superadmin/companies');
        console.log("[Fetch] fetchAndRenderCompanies: Received companies:", companies);

        if (!companies || companies.length === 0) {
            listDiv.innerHTML = '<p class="text-gray-500">Компаний-арендаторов еще нет. Создайте первую!</p>';
        } else {
            // Генерируем HTML для каждой компании в списке
            listDiv.innerHTML = companies.map(c => `
                <div class="p-3 ${c.is_active ? 'bg-gray-50' : 'bg-red-50 opacity-70'} rounded-md flex flex-wrap justify-between items-center gap-2 border">
                    <div class="flex-grow">
                        <p class="font-bold text-lg">${c.name} (Код: <span class="text-indigo-600 font-mono">${c.company_code}</span>)</p>
                        <p class="text-sm text-gray-500">
                            Подписка до: ${c.subscription_paid_until ? new Date(c.subscription_paid_until).toLocaleDateString() : 'Не уст.'} |
                            Статус: ${c.is_active ? '<span class="text-green-600 font-semibold">Активна</span>' : '<span class="text-red-600 font-semibold">ЗАБЛОКИРОВАНА</span>'}
                        </p>
                        ${c.contact_person || c.contact_phone ? `<p class="text-xs text-gray-500">Контакт: ${c.contact_person || ''} ${c.contact_phone || ''}</p>` : ''}
                    </div>
                    <div class="flex-shrink-0 flex gap-2">
                        <button data-company-json='${JSON.stringify(c)}' class="edit-company-btn text-sm bg-gray-200 hover:bg-gray-300 px-3 py-1 rounded">Редактировать</button>
                        <button data-company-id="${c.id}" data-company-name="${c.name}" class="delete-company-btn text-sm bg-red-200 hover:bg-red-300 text-red-800 px-3 py-1 rounded">Удалить</button>
                    </div>
                </div>
            `).join('');
        }
        console.log("[Fetch] fetchAndRenderCompanies: Success");
    } catch (e) {
        console.error("[Fetch] fetchAndRenderCompanies: Error", e);
        listDiv.innerHTML = `<p class="text-red-500">Ошибка загрузки списка компаний: ${e.message}</p>`;
    } finally {
        // hideLoader(); // Глобальный лоадер не используется здесь
    }
}

// --- Открытие модального окна Компании (для создания или редактирования) ---
function openCompanyModal(company = null) {
    console.log("[Modal] openCompanyModal: Start", company);
    // Находим модальное окно и контейнер контента
    const modal = document.getElementById('company-modal');
    if (!modal) return console.error("!!! openCompanyModal: Modal element #company-modal not found!");
    const modalContent = modal.querySelector('.modal-content');
    if (!modalContent) return console.error("!!! openCompanyModal: Modal content not found!");

    // Определяем, режим редактирования (true) или создания (false)
    const isEdit = company !== null;

    // Генерируем HTML для содержимого модального окна
    modalContent.innerHTML = `
        <div class="flex justify-between items-start mb-4">
            <h3 class="text-2xl font-bold">${isEdit ? 'Редактировать Компанию' : 'Создать Новую Компанию'}</h3>
            <button onclick="closeModal('company-modal')" class="text-2xl font-bold leading-none p-1 -m-1">&times;</button>
        </div>
        <form id="modal-company-form" class="space-y-4">
            <input type="hidden" id="modal-company-id" value="${isEdit ? company.id : ''}">

            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                    <label for="modal-company-name" class="block text-sm font-medium text-gray-700">Название компании *</label>
                    <input type="text" id="modal-company-name" class="mt-1 w-full p-2 border rounded" required value="${isEdit ? company.name : ''}">
                </div>
                <div>
                    <label for="modal-company-code" class="block text-sm font-medium text-gray-700">Код Компании (A-Z, 0-9, _) *</label>
                    <input type="text" id="modal-company-code" class="mt-1 w-full p-2 border rounded uppercase font-mono" required
                           value="${isEdit ? company.company_code : ''}"
                           ${isEdit ? 'readonly title="Код нельзя изменить после создания"' : 'placeholder="Напр. VISH, CARGO_KG"'} maxlength="15">
                     <p class="text-xs text-gray-500 mt-1">3-15 знаков. Нельзя изменить.</p>
                </div>
            </div>
            <div>
                <label for="modal-company-subscription" class="block text-sm font-medium text-gray-700">Дата окончания подписки *</label>
                <input type="date" id="modal-company-subscription" class="mt-1 w-full p-2 border rounded" required value="${isEdit && company.subscription_paid_until ? company.subscription_paid_until.split('T')[0] : ''}">
            </div>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                     <label for="modal-company-contact-person" class="block text-sm font-medium text-gray-700">Контактное лицо</label>
                     <input type="text" id="modal-company-contact-person" class="mt-1 w-full p-2 border rounded" value="${isEdit ? (company.contact_person || '') : ''}">
                </div>
                <div>
                     <label for="modal-company-contact-phone" class="block text-sm font-medium text-gray-700">Контактный телефон</label>
                     <input type="text" id="modal-company-contact-phone" class="mt-1 w-full p-2 border rounded" value="${isEdit ? (company.contact_phone || '') : ''}">
                </div>
            </div>

            <div class="border-t pt-4 space-y-4">
                <h4 class="text-lg font-semibold text-gray-700">Настройки Telegram Бота</h4>
                <div>
                     <label for="modal-company-bot-token" class="block text-sm font-medium text-gray-700">Токен Telegram Бота</label>
                     <input type="text" id="modal-company-bot-token" class="mt-1 w-full p-2 border rounded font-mono text-xs" value="${isEdit ? (company.telegram_bot_token || '') : ''}" placeholder="Например: 1234567890:ABC...">
                     <p class="text-xs text-gray-500 mt-1">Получите у @BotFather в Telegram. Оставьте пустым, если бот не используется.</p>
                </div>
                <div>
                     <label for="modal-company-bot-username" class="block text-sm font-medium text-gray-700">Имя пользователя Бота (Username)</label>
                     <input type="text" id="modal-company-bot-username" class="mt-1 w-full p-2 border rounded" value="${isEdit ? (company.telegram_bot_username || '') : ''}" placeholder="Например: @MyCargoCompanyBot">
                     <p class="text-xs text-gray-500 mt-1">Опционально. Начинается с @.</p>
                </div>
            </div>
            <div id="modal-company-owner-fields" class="border-t pt-4 space-y-4 ${isEdit ? 'hidden' : 'block'}">
                 <h4 class="text-lg font-semibold">Данные Владельца Компании</h4>
                 <div>
                      <label for="modal-company-owner-name" class="block text-sm font-medium text-gray-700">ФИО Владельца *</label>
                      <input type="text" id="modal-company-owner-name" class="mt-1 w-full p-2 border rounded" ${!isEdit ? 'required' : ''}>
                 </div>
                 <div>
                      <label for="modal-company-owner-password" class="block text-sm font-medium text-gray-700">Пароль Владельца *</label>
                      <input type="text" id="modal-company-owner-password" class="mt-1 w-full p-2 border rounded" ${!isEdit ? 'required' : ''}>
                 </div>
            </div>

            <div id="modal-company-status-field" class="border-t pt-4 ${isEdit ? 'block' : 'hidden'}">
                  <label class="flex items-center">
                      <input type="checkbox" id="modal-company-is-active" class="h-4 w-4 rounded" ${isEdit && company.is_active ? 'checked' : ''}>
                      <span class="ml-2 text-sm font-medium text-gray-700">Компания Активна (Разрешен вход)</span>
                  </label>
            </div>

            <div class="flex gap-4 mt-6 border-t pt-4">
                <button type="button" onclick="closeModal('company-modal')" class="w-full bg-gray-200 py-2 rounded hover:bg-gray-300 text-gray-800">Отмена</button>
                <button type="submit" class="w-full bg-green-600 text-white py-2 rounded hover:bg-green-700">Сохранить</button>
            </div>
        </form>
    `;

    // Установка даты подписки по умолчанию (+30 дней) для НОВОЙ компании
    if (!isEdit) {
         const subInput = document.getElementById('modal-company-subscription');
         if (subInput && !subInput.value) {
              const today = new Date();
              today.setDate(today.getDate() + 30);
              // Форматируем дату в YYYY-MM-DD для input type="date"
              subInput.value = today.toISOString().split('T')[0];
              console.log("[Modal] Установлена дата подписки по умолчанию:", subInput.value);
         }
    }

    // Привязываем слушатель submit к ТОЛЬКО ЧТО созданной форме
    const formElement = document.getElementById('modal-company-form');
    if (formElement) {
        // Удаляем старые слушатели перед добавлением нового
        const newFormElement = formElement.cloneNode(true);
        formElement.parentNode.replaceChild(newFormElement, formElement);
        newFormElement.addEventListener('submit', handleSaveCompany);
        console.log("[Modal Listener OK] Added submit to #modal-company-form");
    } else {
        // Если форма не найдена после генерации HTML - это ошибка
        console.error("!!! openCompanyModal: Form #modal-company-form NOT FOUND after innerHTML!");
    }

    openModal('company-modal'); // Открываем модальное окно
    console.log("[Modal] openCompanyModal: End");
}

// --- Обработка кликов в списке компаний (делегирование) ---
// Вызывается слушателем, добавленным в renderCompaniesTab
function handleCompanyActions(e) {
    const editButton = e.target.closest('.edit-company-btn');
    const deleteButton = e.target.closest('.delete-company-btn');

    if (editButton) {
        console.log("[Action] Edit company button clicked");
        try {
            // Извлекаем данные компании из data-атрибута кнопки
            const companyData = JSON.parse(editButton.dataset.companyJson);
            openCompanyModal(companyData); // Открываем модалку для редактирования
        } catch (err) {
            console.error("Error parsing company data for edit:", err);
            alert("Ошибка: Не удалось прочитать данные компании для редактирования.");
        }
    } else if (deleteButton) {
        console.log("[Action] Delete company button clicked");
        const companyId = deleteButton.dataset.companyId;
        const companyName = deleteButton.dataset.companyName;
        // Запрашиваем подтверждение перед удалением
        if (confirm(`ВНИМАНИЕ!\n\nВы собираетесь УДАЛИТЬ компанию "${companyName}" и ВСЕ связанные с ней данные (филиалы, сотрудники, роли, клиенты, заказы, смены, расходы)?\n\nДЕЙСТВИЕ НЕОБРАТИМО!`)) {
            // Дополнительное подтверждение для надежности
             if (prompt(`Для подтверждения удаления "${companyName}" введите ее код компании (${companyName === 'WishCargo' ? 'WISH' : 'КОД'}):`)?.toUpperCase() === companyName === 'WishCargo' ? 'WISH' : deleteButton.closest('.p-3').querySelector('.text-indigo-600')?.textContent) {
                  handleDeleteCompany(companyId, companyName); // Вызываем функцию удаления
             } else {
                  alert("Удаление отменено: Код компании введен неверно.");
             }
        }
    }
}

// --- Сохранение данных Компании (вызывается из модального окна) ---
async function handleSaveCompany(e) {
    e.preventDefault(); // Предотвращаем стандартную отправку формы
    console.log("[Save] handleSaveCompany: Start");
    showLoader(); // Показываем индикатор загрузки

    // Считываем ID компании (если он есть - режим редактирования)
    const companyId = document.getElementById('modal-company-id')?.value;
    const isEdit = !!companyId; // true, если ID есть
    // Определяем URL и метод в зависимости от режима
    let url = '/api/superadmin/companies'; // URL для создания
    let method = 'POST'; // Метод для создания
    if(isEdit) {
        url = `/api/superadmin/companies/${companyId}`; // URL для обновления
        method = 'PATCH'; // Метод для обновления
    }
    // Объект для данных, отправляемых на сервер
    let payload = {};

    try {
        // --- Собираем данные из полей модального окна ---
        if (isEdit) {
            // --- РЕДАКТИРОВАНИЕ ---
            payload = {
                name: document.getElementById('modal-company-name')?.value.trim(),
                subscription_paid_until: document.getElementById('modal-company-subscription')?.value,
                contact_person: document.getElementById('modal-company-contact-person')?.value.trim() || null,
                contact_phone: document.getElementById('modal-company-contact-phone')?.value.trim() || null,
                is_active: document.getElementById('modal-company-is-active')?.checked,
                // ДОБАВЛЕНО: Считываем поля бота
                telegram_bot_token: document.getElementById('modal-company-bot-token')?.value.trim() || null, // Отправляем null, если поле пустое
                telegram_bot_username: document.getElementById('modal-company-bot-username')?.value.trim() || null // Отправляем null, если поле пустое
            };
            // Проверка обязательных полей при редактировании
            if (!payload.name || !payload.subscription_paid_until) {
                throw new Error("Название компании и дата окончания подписки обязательны.");
            }
        } else {
            // --- СОЗДАНИЕ ---
            payload = {
                name: document.getElementById('modal-company-name')?.value.trim(),
                company_code: document.getElementById('modal-company-code')?.value.toUpperCase().trim(),
                subscription_paid_until: document.getElementById('modal-company-subscription')?.value,
                contact_person: document.getElementById('modal-company-contact-person')?.value.trim() || null,
                contact_phone: document.getElementById('modal-company-contact-phone')?.value.trim() || null,
                owner_full_name: document.getElementById('modal-company-owner-name')?.value.trim(),
                owner_password: document.getElementById('modal-company-owner-password')?.value, // Пароль не тримим
                // ДОБАВЛЕНО: Считываем поля бота
                telegram_bot_token: document.getElementById('modal-company-bot-token')?.value.trim() || null, // null если пусто
                telegram_bot_username: document.getElementById('modal-company-bot-username')?.value.trim() || null // null если пусто
            };
            // Проверка обязательных полей при создании
             if (!payload.name || !payload.company_code || !payload.subscription_paid_until || !payload.owner_full_name || !payload.owner_password) {
                  throw new Error("Все поля со звездочкой (*) обязательны при создании компании.");
             }
             // Проверка корректности кода компании
             if (!/^[A-Z0-9_]{3,15}$/.test(payload.company_code)) {
                  throw new Error("Код компании некорректен (3-15 знаков, только латинские буквы A-Z, цифры 0-9 и символ подчеркивания '_').");
             }
        }

        // --- Отправляем запрос на сервер ---
        console.log(`[Save] handleSaveCompany: Sending ${method} to ${url}`, payload);
        // Используем универсальную функцию apiFetch для отправки запроса
        const result = await apiFetch(url, { method: method, body: JSON.stringify(payload) });
        console.log("[Save] handleSaveCompany: Server response", result);

        // --- Обработка успеха ---
        alert(isEdit ? 'Данные компании успешно обновлены!' : 'Новая компания успешно создана!');
        closeModal('company-modal'); // Закрываем модальное окно
        await fetchAndRenderCompanies(); // Обновляем список компаний на странице

    } catch(err) { // Обработка ошибок (от валидации или от apiFetch)
        console.error("[Save] handleSaveCompany: Error", err);
        // Показываем сообщение об ошибке пользователю
        alert(`Ошибка сохранения данных компании: ${err.message}`);
        // Оставляем модальное окно открытым для исправления
    } finally {
        // --- Скрываем лоадер в любом случае ---
        hideLoader();
        console.log("[Save] handleSaveCompany: End");
    }
}

// --- Удаление Компании ---
async function handleDeleteCompany(companyId, companyName) {
    console.log(`[Delete] handleDeleteCompany: Start deleting ID ${companyId} (${companyName})`);
    showLoader();
    try {
        // Отправляем DELETE запрос на бэкенд
        await apiFetch(`/api/superadmin/companies/${companyId}`, { method: 'DELETE' });
        console.log(`[Delete] handleDeleteCompany: Company ID ${companyId} deleted successfully.`);
        alert(`Компания "${companyName}" и все ее данные были успешно удалены.`);
        await fetchAndRenderCompanies(); // Обновляем список компаний
    } catch (err) { // Обработка ошибок от apiFetch
        console.error("[Delete] handleDeleteCompany: Error", err);
        alert(`Ошибка удаления компании "${companyName}": ${err.message}`);
    } finally {
        hideLoader(); // Скрываем лоадер
        console.log("[Delete] handleDeleteCompany: End");
    }
}

// =================================================================
// МОДУЛЬ: ФИЛИАЛЫ (Владелец) 
// =================================================================

// --- Рендеринг вкладки "Филиалы" (Создает HTML-контейнеры) ---

async function renderLocationsTab() {
    console.log("[Render] renderLocationsTab: Start");
    const pane = document.getElementById('tab-locations');
    if (!pane) {
         console.warn("[Render] renderLocationsTab: Pane #tab-locations not found.");
         return; 
    }

    // Генерируем основной HTML для вкладки
    pane.innerHTML = `
        <div class="bg-white p-6 rounded-lg shadow-md">
            <div class="flex flex-wrap justify-between items-start gap-4 mb-4">
                <div class="flex flex-col">
                    <h2 class="text-2xl font-bold">Филиалы (Точки) Компании</h2>
                    <p id="locations-status" class="text-sm text-gray-600">Загрузка статуса...</p>
                </div>
                <button id="add-location-btn" class="bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700">➕ Добавить Филиал</button>
            </div>
            <div id="locations-list" class="space-y-3">Загрузка списка филиалов...</div>
        </div>
    `;

    // --- Добавляем слушатели ---
    const addBtn = document.getElementById('add-location-btn');
    if (addBtn) addBtn.addEventListener('click', () => openLocationModal()); 

    const locationListDiv = document.getElementById('locations-list');
    if (locationListDiv) {
         locationListDiv.addEventListener('click', (e) => {
             const editBtn = e.target.closest('.edit-location-btn');
             const deleteBtn = e.target.closest('.delete-location-btn');
             const toggleBtn = e.target.closest('.toggle-shift-btn');
             
             if (editBtn) openLocationModal(JSON.parse(editBtn.dataset.locationJson));
             // ... (логика для удаления и переключения смен)
             if (toggleBtn) handleShiftToggle(e); 
         });
    }

    await fetchAndRenderLocations();
    console.log("[Render] renderLocationsTab: End");
}

// --- Загрузка и отображение списка филиалов (ГДЕ БЫЛА ОШИБКА) ---
// index.html (Полностью заменяет fetchAndRenderLocations)

async function fetchAndRenderLocations() {
    console.log("[Fetch] fetchAndRenderLocations: Start");
    
    // Переменная listDiv должна быть объявлена локально!
    const listDiv = document.getElementById('locations-list'); 
    
    if (!listDiv) {
        console.error("!!! fetchAndRenderLocations: Элемент #locations-list не найден.");
        return; 
    }
    
    listDiv.innerHTML = '<p class="text-gray-500 animate-pulse">Загрузка филиалов...</p>';
    showLoader(); 

    try {
        // --- Загрузка филиалов и активных смен ---
        const [locations, activeShifts] = await Promise.all([
            apiFetch('/api/locations'),
            fetchActiveShiftsForCompany() 
        ]);
        companyLocations = locations; 
        
        const shiftsByLocation = new Map();
        activeShifts.forEach(shift => shiftsByLocation.set(shift.location_id, shift));

        // --- ОБНОВЛЕНИЕ ДИНАМИЧЕСКОГО СТАТУСА ---
        const statusEl = document.getElementById('locations-status');
        const totalLocations = locations.length;
        const activeShiftCount = activeShifts.length;
        if (statusEl) {
            statusEl.textContent = `Всего точек: ${totalLocations} | Открытых смен: ${activeShiftCount}`;
        }
        // ----------------------------------------

        if (!locations || locations.length === 0) {
             listDiv.innerHTML = '<p class="text-gray-500">У вашей компании нет филиалов.</p>';
        } else {
            listDiv.innerHTML = locations.map(loc => {
                const shiftInfo = shiftsByLocation.get(loc.id);
                const isActive = !!shiftInfo;
                const employeeName = shiftInfo?.employee?.full_name || '—';
                const buttonText = isActive ? 'Закрыть смену' : 'Открыть смену';
                const buttonClass = isActive ? 'bg-red-500 hover:bg-red-600' : 'bg-green-500 hover:bg-green-600';

                return `
                    <div class="p-3 bg-gray-50 rounded-md border flex flex-wrap justify-between items-center gap-2">
                        <div class="flex-grow">
                            <p class="font-bold text-lg">${loc.name}</p>
                            <p class="text-sm text-gray-600">${loc.address || 'Адрес не указан'}</p>
                            <p class="text-xs ${isActive ? 'text-green-600 font-semibold' : 'text-red-600'}">
                                ${isActive ? `СМЕНА ОТКРЫТА (Сотрудник: ${employeeName})` : 'СМЕНА ЗАКРЫТА'}
                            </p>
                        </div>
                        <div class="flex-shrink-0 flex gap-2">
                            <button data-location-json='${JSON.stringify(loc)}' class="edit-location-btn text-sm bg-gray-200 hover:bg-gray-300 px-3 py-1 rounded">Редактировать</button>
                            <button data-location-id="${loc.id}" 
                                    data-is-active="${isActive}"
                                    data-shift-id="${shiftInfo?.id || ''}"
                                    data-employee-id="${shiftInfo?.employee_id || ''}"
                                    class="toggle-shift-btn text-sm ${buttonClass} text-white px-3 py-1 rounded">
                                ${buttonText}
                            </button>
                            ${loc.name !== 'Главный филиал' ? `<button data-location-id="${loc.id}" data-location-name="${loc.name}" class="delete-location-btn text-sm bg-red-200 hover:bg-red-300 text-red-800 px-3 py-1 rounded">Удалить</button>` : ''}
                        </div>
                    </div>
                `;
            }).join('');
            
            // Note: addLocationActionListeners() больше не нужна, т.к. мы используем делегирование
        }
    } catch (e) {
        listDiv.innerHTML = `<p class="text-red-500">Ошибка загрузки списка филиалов: ${e.message}</p>`;
    } finally {
        hideLoader();
    }
}

// --- НОВАЯ ФУНКЦИЯ: Запрашивает все активные смены компании ---
async function fetchActiveShiftsForCompany() {
    try {
        const response = await apiFetch('/api/shifts/all_active');
        return response || [];
    } catch (e) {
        // Ловим 404, если роут не существует, и возвращаем пустой массив
        if (e.message && e.message.includes('404')) return [];
        console.error("[Shift Status] Failed to fetch all active shifts:", e);
        return []; 
    }
}

// --- Добавление слушателей к кнопкам Редакт/Удалить в списке филиалов ---
// Вызывается ПОСЛЕ того, как fetchAndRenderLocations сгенерировал HTML списка
function addLocationActionListeners() {
     const listDiv = document.getElementById('locations-list');
     if (!listDiv) return;

     // Находим все кнопки редактирования
     listDiv.querySelectorAll('.edit-location-btn').forEach(btn => {
          // Удаляем старый слушатель (если был) через клонирование
          const newBtn = btn.cloneNode(true);
          btn.parentNode.replaceChild(newBtn, btn);
          // Добавляем новый
          newBtn.addEventListener('click', (e) => {
               console.log("[Action] Edit location button clicked");
               try {
                    const locationData = JSON.parse(e.currentTarget.dataset.locationJson);
                    openLocationModal(locationData); // Открываем модалку с данными
               } catch (err) {
                    console.error("Error parsing location data for edit:", err);
                    alert("Ошибка: Не удалось прочитать данные филиала.");
               }
          });
     });

      // Находим все кнопки удаления
     listDiv.querySelectorAll('.delete-location-btn').forEach(btn => {
           const newBtn = btn.cloneNode(true);
           btn.parentNode.replaceChild(newBtn, btn);
           newBtn.addEventListener('click', (e) => {
                console.log("[Action] Delete location button clicked");
                const locationId = e.currentTarget.dataset.locationId;
                const locationName = e.currentTarget.dataset.locationName;
                if (confirm(`Удалить филиал "${locationName}"?\n\nВНИМАНИЕ: Сотрудники, привязанные к этому филиалу, останутся без филиала!`)) {
                     handleDeleteLocation(locationId, locationName); // Вызываем удаление
                }
           });
     });
     console.log("[Listeners OK] Added action listeners to location list buttons.");
}


// --- Открытие модального окна Филиала (для создания или редактирования) ---
// index.html (ПОЛНОСТЬЮ ЗАМЕНЯЕТ openLocationModal)

function openLocationModal(locationData = null) {
    console.log("[Modal] openLocationModal: Start", locationData);
    const modal = document.getElementById('location-modal');
    if (!modal) return console.error("!!! openLocationModal: Modal element #location-modal not found!");
    const modalContent = modal.querySelector('.modal-content');
    if (!modalContent) return console.error("!!! openLocationModal: Modal content not found!");

    const isEdit = locationData !== null;

    // Генерируем HTML для содержимого модального окна
    modalContent.innerHTML = `
        <div class="flex justify-between items-start mb-4">
            <h3 class="text-2xl font-bold">${isEdit ? 'Редактировать Филиал' : 'Добавить Новый Филиал'}</h3>
            <button onclick="closeModal('location-modal')" class="text-2xl font-bold leading-none p-1 -m-1">&times;</button>
        </div>
        <form id="location-form" data-location-id="${isEdit ? locationData.id : ''}" class="space-y-4">
            
            <div>
                <label for="location-name" class="block text-sm font-medium text-gray-700">Название *</label>
                <input type="text" id="location-name" class="mt-1 w-full p-2 border rounded" required 
                       value="${isEdit && locationData.name ? locationData.name : ''}" placeholder="Например: Склад Дордой, Офис Центр">
            </div>
            <div>
                <label for="location-address" class="block text-sm font-medium text-gray-700">Адрес</label>
                <input type="text" id="location-address" class="mt-1 w-full p-2 border rounded" 
                       value="${isEdit && locationData.address ? locationData.address : ''}" placeholder="Город, улица, дом">
            </div>

            <div class="border-t pt-4">
                <label for="location-phone" class="block text-sm font-medium text-gray-700">Телефон филиала</label>
                <input type="text" id="location-phone" class="mt-1 w-full p-2 border rounded" 
                       value="${isEdit && locationData.phone ? locationData.phone : ''}" placeholder="+996 555 123456">
            </div>
            <div>
                <label for="location-whatsapp" class="block text-sm font-medium text-gray-700">Ссылка WhatsApp</label>
                <input type="text" id="location-whatsapp" class="mt-1 w-full p-2 border rounded" 
                       value="${isEdit && locationData.whatsapp_link ? locationData.whatsapp_link : ''}" placeholder="https://wa.me/996555123456">
            </div>
            <div>
                <label for="location-instagram" class="block text-sm font-medium text-gray-700">Ссылка Instagram</label>
                <input type="text" id="location-instagram" class="mt-1 w-full p-2 border rounded" 
                       value="${isEdit && locationData.instagram_link ? locationData.instagram_link : ''}" placeholder="https://instagram.com/...">
            </div>
            <div>
                <label for="location-map" class="block text-sm font-medium text-gray-700">Ссылка на Карту (2GIS, Google)</label>
                <input type="text" id="location-map" class="mt-1 w-full p-2 border rounded" 
                       value="${isEdit && locationData.map_link ? locationData.map_link : ''}" placeholder="https://go.2gis.com/...">
            </div>
            <div class="flex gap-4 mt-6 border-t pt-4">
                <button type="button" onclick="closeModal('location-modal')" class="w-full bg-gray-200 py-2 rounded hover:bg-gray-300 text-gray-800">Отмена</button>
                <button type="submit" class="w-full bg-green-600 text-white py-2 rounded hover:bg-green-700">Сохранить</button>
            </div>
        </form>
    `;

    // --- Добавляем слушатель submit к ТОЛЬКО ЧТО созданной форме ---
    const formElement = document.getElementById('location-form');
    if (formElement) {
        const newFormElement = formElement.cloneNode(true);
        formElement.parentNode.replaceChild(newFormElement, formElement);
        newFormElement.addEventListener('submit', handleSaveLocation);
        console.log("[Modal Listener OK] Added submit to #location-form");
    } else {
        console.error("!!! openLocationModal: Form #location-form NOT FOUND after innerHTML!");
    }
    // --- Конец добавления слушателя ---

    openModal('location-modal'); // Открываем модальное окно
    console.log("[Modal] openLocationModal: End");
}

// --- Сохранение данных Филиала (вызывается из модального окна) ---
// index.html (ПОЛНОСТЬЮ ЗАМЕНЯЕТ handleSaveLocation)

async function handleSaveLocation(e) {
    e.preventDefault(); 
    console.log("[Save] handleSaveLocation: Start");
    showLoader(); 

    const form = e.target;
    const locationId = form.dataset.locationId;
    const isEdit = !!locationId; 
    
    // ИСПРАВЛЕНИЕ: Используем /api/locations
    const url = isEdit ? `/api/locations/${locationId}` : '/api/locations'; 
    const method = isEdit ? 'PATCH' : 'POST'; 

    // Собираем данные из полей формы
    const payload = {
        name: document.getElementById('location-name')?.value.trim(),
        address: document.getElementById('location-address')?.value.trim() || null,
        // --- НОВЫЕ ПОЛЯ ---
        phone: document.getElementById('location-phone')?.value.trim() || null,
        whatsapp_link: document.getElementById('location-whatsapp')?.value.trim() || null,
        instagram_link: document.getElementById('location-instagram')?.value.trim() || null,
        map_link: document.getElementById('location-map')?.value.trim() || null
        // --- КОНЕЦ НОВЫХ ПОЛЕЙ ---
    };

    if (!payload.name) {
         hideLoader();
         alert("Название филиала не может быть пустым.");
         return; 
     }

    try {
        console.log(`[Save] handleSaveLocation: Sending ${method} to ${url}`, payload);
        
        // ИСПРАВЛЕНИЕ: Используем apiFetch
        const result = await apiFetch(url, { 
            method: method, 
            body: JSON.stringify(payload) 
        });
        
        console.log("[Save] handleSaveLocation: Server response", result);
        alert(isEdit ? 'Данные филиала успешно обновлены!' : 'Новый филиал успешно создан!');
        closeModal('location-modal'); 
        
        // ИСПРАВЛЕНИЕ: Обновляем кэш companyLocations
        companyLocations = await apiFetch('/api/locations'); 
        
        await fetchAndRenderLocations(); 

    } catch(err) { 
        console.error("[Save] handleSaveLocation: Error", err);
        alert(`Ошибка сохранения данных филиала: ${err.message}`);
    } finally {
        hideLoader();
        console.log("[Save] handleSaveLocation: End");
    }
}

// --- Удаление Филиала ---
async function handleDeleteLocation(locationId, locationName) {
    console.log(`[Delete] handleDeleteLocation: Start deleting ID ${locationId} (${locationName})`);
    // Дополнительная проверка перед удалением (можно запросить пароль или код)
    // const confirmation = prompt(`Для подтверждения удаления филиала "${locationName}" введите "УДАЛИТЬ":`);
    // if (confirmation !== "УДАЛИТЬ") {
    //      alert("Удаление отменено.");
    //      return;
    // }
    
    showLoader();
    try {
        // TODO: Добавить эндпоинт DELETE /locations/{id} на бэкенд.
        // Пока имитируем или показываем заглушку.
        // await apiFetch(`/locations/${locationId}`, { method: 'DELETE' });
        
        console.warn(`[Delete] handleDeleteLocation: DELETE endpoint for locations not implemented yet. Deletion skipped for ID ${locationId}.`);
        alert(`Функция удаления филиала "${locationName}" пока не реализована на сервере.`);
        
        // alert(`Филиал "${locationName}" успешно удален.`); // Когда будет готово
        // await fetchAndRenderLocations(); // Обновить список после удаления

    } catch(err) { // Обработка ошибок от apiFetch
        console.error("[Delete] handleDeleteLocation: Error", err);
        alert(`Ошибка удаления филиала "${locationName}": ${err.message}`);
    } finally {
        hideLoader(); // Скрываем лоадер
        console.log("[Delete] handleDeleteLocation: End");
    }
}

// index.html (Внутри МОДУЛЬ: ФИЛИАЛЫ)

// --- НОВАЯ ФУНКЦИЯ: Обработчик клика по кнопке "Открыть/Закрыть смену" ---
async function handleShiftToggle(e) {
    const btn = e.target.closest('.toggle-shift-btn');
    if (!btn) return;
    
    const isActive = btn.dataset.isActive === 'true'; // Текущий статус смены
    const locationId = btn.dataset.locationId; // ID филиала, где происходит действие
    const shiftId = btn.dataset.shiftId; // ID смены (если открыта)
    
    if (isActive) {
        // СМЕНА ОТКРЫТА -> Владелец должен ее закрыть
        await handleForcedCloseShift(shiftId, locationId);
    } else {
        // СМЕНА ЗАКРЫТА -> Владелец открывает новую смену
        await showOpenShiftScreen(locationId);
    }
}

// --- НОВАЯ ФУНКЦИЯ: Принудительное закрытие смены Владельцем ---
async function handleForcedCloseShift(shiftId, locationId) {
    if (!shiftId) return alert("Ошибка: ID смены не найден.");
    
    // Владелец должен знать фактический остаток для закрытия 
    const closingCashStr = prompt(`Введите итоговую сумму наличных в кассе для закрытия смены #${shiftId} (филиал ID ${locationId}):`);
    
    if (closingCashStr === null || closingCashStr === '') {
        alert("Закрытие смены отменено.");
        return;
    }
    const closingCash = parseFloat(closingCashStr);
    if (isNaN(closingCash) || closingCash < 0) {
        alert("Некорректная сумма. Закрытие отменено.");
        return;
    }

    const password = prompt("Введите ваш пароль Владельца для подтверждения закрытия:");
    if (!password) return alert("Закрытие отменено.");
    
    showLoader();
    try {
        // Используем специальный эндпоинт для принудительного закрытия
        await apiFetch(`/api/shifts/${shiftId}/force_close`, {
            method: 'POST',
            body: JSON.stringify({ closing_cash: closingCash, password: password })
        });
        
        alert(`Смена #${shiftId} успешно закрыта!`);
        await fetchAndRenderLocations(); // Обновляем список филиалов
        
    } catch (err) {
        alert(`Ошибка закрытия смены: ${err.message}`);
    } finally {
        hideLoader();
    }
}

// --- ИЗМЕНЕНИЕ СУЩЕСТВУЮЩЕЙ ФУНКЦИИ: Привязка слушателя ---
function addLocationActionListeners() {
    // ... (код для кнопок редактирования/удаления)
    
    // Находим все кнопки открытия/закрытия смены
    listDiv.querySelectorAll('.toggle-shift-btn').forEach(btn => {
         const newBtn = btn.cloneNode(true);
         btn.parentNode.replaceChild(newBtn, btn);
         // !!! КРИТИЧЕСКАЯ ПРИВЯЗКА !!!
         newBtn.addEventListener('click', handleShiftToggle); 
    });
    console.log("[Listeners OK] Added action listeners to location list buttons.");
}

// Теперь вам нужно убедиться, что handleOpenShiftSubmit (в модалке) может принять locationId 
// и вызвать open_shift на бэкенде.
// Эту часть мы уже реализовывали в предыдущих шагах, она должна работать с locationId.

// =================================================================
// МОДУЛЬ: ПЕРСОНАЛ (Владелец) (v4.1 - Rebuild)
// =================================================================

// --- Рендеринг вкладки "Персонал" ---
// Вызывается из initializeMainAppUI, если у Владельца есть права 'manage_employees'
async function renderEmployeesTab() {
    console.log("[Render] renderEmployeesTab: Start");
    const pane = document.getElementById('tab-employees');
    if (!pane) {
        console.warn("[Render] renderEmployeesTab: Pane #tab-employees not found.");
        return;
    }

    // Генерируем основной HTML для вкладки
    pane.innerHTML = `
        <div class="bg-white p-6 rounded-lg shadow-md border">
            <div class="flex flex-wrap justify-between items-center gap-4 mb-4 border-b pb-4">
                <h2 class="text-2xl font-bold text-gray-800">Управление Персоналом</h2>
                <button id="add-employee-btn" class="bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 text-sm">➕ Добавить Сотрудника</button>
            </div>
            <div id="employees-list" class="space-y-3">Загрузка списка сотрудников...</div>
        </div>
    `;

    // --- Добавляем слушатели к элементам, созданным ВЫШЕ ---
    const addBtn = document.getElementById('add-employee-btn');
    const employeeListDiv = document.getElementById('employees-list');

    // Кнопка "Добавить Сотрудника"
    if (addBtn) {
        // Используем replaceWith(cloneNode) для удаления старых слушателей перед добавлением нового
        const newAddBtn = addBtn.cloneNode(true);
        addBtn.parentNode?.replaceChild(newAddBtn, addBtn);
        newAddBtn.addEventListener('click', () => openEmployeeModal()); // Добавляем к новой кнопке
        console.log("[Listener OK] Added click to #add-employee-btn");
    } else {
        console.error("!!! renderEmployeesTab: Element #add-employee-btn NOT FOUND after innerHTML.");
    }

    // Список сотрудников (для делегирования кликов по кнопкам Редакт/Уволить/Удалить)
    if (employeeListDiv) {
         const newEmployeeListDiv = employeeListDiv.cloneNode(false); // Клонируем пустой контейнер
         employeeListDiv.parentNode?.replaceChild(newEmployeeListDiv, employeeListDiv); // Заменяем старый
         newEmployeeListDiv.innerHTML = 'Загрузка списка сотрудников...'; // Восстанавливаем заглушку
         // Добавляем слушатель к НОВОМУ контейнеру
         newEmployeeListDiv.addEventListener('click', handleEmployeeActions);
         console.log("[Listener OK] Added click delegate listener to #employees-list");
    } else {
         console.error("!!! renderEmployeesTab: Element #employees-list NOT FOUND after innerHTML.");
    }
    // --- Конец добавления слушателей ---

    // Загружаем и отображаем данные
    await fetchAndRenderEmployees();
    console.log("[Render] renderEmployeesTab: End");
}

async function fetchAndRenderEmployees() {
    console.log("[Fetch] fetchAndRenderEmployees: Start");
    const listDiv = document.getElementById('employees-list'); // Ищем контейнер
    if (!listDiv) return console.error("!!! fetchAndRenderEmployees: listDiv #employees-list not found!");
    listDiv.innerHTML = '<p class="text-gray-500 animate-pulse">Загрузка сотрудников...</p>';
    showLoader(); // Показываем лоадер

    try {
        // --- Предзагрузка Ролей и Филиалов (если нужны и кэш пуст) ---
        if (!currentUser.is_super_admin) {
             if (!companyLocations || companyLocations.length === 0 || !companyRoles || companyRoles.length === 0) {
                 console.log("[Fetch] fetchAndRenderEmployees: Preloading locations and roles...");
                 const results = await Promise.allSettled([
                     // КРИТИЧЕСКОЕ ИСПРАВЛЕНИЕ 1: ДОБАВЛЕН /api
                     (!companyLocations || companyLocations.length === 0) ? apiFetch('/api/locations') : Promise.resolve(companyLocations),
                     // КРИТИЧЕСКОЕ ИСПРАВЛЕНИЕ 2: ДОБАВЛЕН /api
                     (!companyRoles || companyRoles.length === 0) ? apiFetch('/api/roles') : Promise.resolve(companyRoles)
                 ]);
                 if (results[0].status === 'fulfilled') companyLocations = results[0].value; else console.warn("Failed to preload locations:", results[0].reason);
                 if (results[1].status === 'fulfilled') companyRoles = results[1].value; else console.warn("Failed to preload roles:", results[1].reason);
                 console.log("[Fetch] fetchAndRenderEmployees: Locations and roles loaded/updated.");
             } else {
                 console.log("[Fetch] fetchAndRenderEmployees: Using cached locations and roles.");
             }
        } else { // Для SuperAdmin эти кэши не нужны
             companyLocations = []; companyRoles = [];
        }

        // --- Загрузка списка сотрудников ---
        console.log("[Fetch] fetchAndRenderEmployees: Fetching employees list...");
        // КРИТИЧЕСКОЕ ИСПРАВЛЕНИЕ 3: ДОБАВЛЕН /api
        const employees = await apiFetch('/api/employees'); 
        console.log("[Fetch] fetchAndRenderEmployees: Received employees:", employees);

        // --- Рендеринг списка ---
        if (!employees || employees.length === 0) {
            listDiv.innerHTML = '<p class="text-gray-500">У вашей компании еще нет сотрудников (кроме Владельца).</p>';
        } else {
            listDiv.innerHTML = employees.map(emp => {
                // Ищем имя роли в кэше companyRoles (используем Optional Chaining `?.`)
                const roleName = companyRoles.find(r => r.id === emp.role_id)?.name || emp.role?.name || 'Неизвестная роль';
                // Ищем имя филиала в кэше companyLocations
                const locationName = companyLocations.find(loc => loc.id === emp.location_id)?.name || 'Неизвестный филиал';

                // Определяем доступные действия для текущего пользователя
                const canManage = currentUser.permissions?.includes('manage_employees');
                const isOwnerRole = roleName === 'Владелец'; // Нельзя уволить/удалить Владельца

                return `
                 <div class="p-3 ${emp.is_active ? 'bg-gray-50' : 'bg-red-50 opacity-70'} rounded-md border flex flex-wrap justify-between items-center gap-2 shadow-sm">
                     <div class="flex-grow min-w-[200px]">
                         <p class="font-bold text-lg text-gray-800">${emp.full_name}</p>
                         <p class="text-sm text-gray-600">${roleName} @ ${locationName}</p>
                         <p class="text-xs font-semibold ${emp.is_active ? 'text-green-600' : 'text-red-600'}">${emp.is_active ? 'АКТИВЕН' : 'УВОЛЕН'}</p>
                     </div>
                      <div class="flex-shrink-0 flex gap-2">
                          ${canManage ? `
                              <button data-employee-json='${JSON.stringify(emp)}' class="edit-employee-btn text-sm bg-gray-200 hover:bg-gray-300 px-3 py-1 rounded transition-colors duration-150">Редактировать</button>
                              ${!isOwnerRole ? `
                              <button data-employee-id="${emp.id}" data-employee-name="${emp.full_name}" data-is-active="${emp.is_active}" class="toggle-status-employee-btn text-sm ${emp.is_active ? 'bg-yellow-200 text-yellow-800 hover:bg-yellow-300' : 'bg-green-200 text-green-800 hover:bg-green-300'} px-3 py-1 rounded transition-colors duration-150">
                                  ${emp.is_active ? 'Уволить' : 'Восстановить'}
                              </button>
                              <button data-employee-id="${emp.id}" data-employee-name="${emp.full_name}" class="delete-employee-btn text-sm bg-red-200 hover:bg-red-300 text-red-800 px-3 py-1 rounded transition-colors duration-150" title="Полное удаление сотрудника (необратимо)">Удалить</button>
                              ` : '<span class="text-xs text-gray-400">(Действия недоступны)</span>'}
                          ` : ''} 
                      </div>
                 </div>
                `;}).join('');
            // Слушатели для кнопок уже добавлены на #employees-list через делегирование
        }
        console.log("[Fetch] fetchAndRenderEmployees: Success");
    } catch (e) {
        console.error("!!! [Fetch] fetchAndRenderEmployees: Error", e);
        listDiv.innerHTML = `<p class="text-red-500">Ошибка загрузки списка сотрудников: ${e.message}</p>`;
    } finally {
        hideLoader(); // Скрываем лоадер
        console.log("[Fetch] fetchAndRenderEmployees: End");
    }
}

// --- Открытие модального окна Сотрудника (для создания или редактирования) ---
function openEmployeeModal(employee = null) {
    console.log("[Modal] openEmployeeModal: Start", employee);
    const modal = document.getElementById('employee-modal');
    if (!modal) return console.error("!!! openEmployeeModal: Modal element #employee-modal not found!");
    const modalContent = modal.querySelector('.modal-content');
    if (!modalContent) return console.error("!!! openEmployeeModal: Modal content not found!");

    const isEdit = employee !== null; // true, если переданы данные для редактирования

    // --- Проверка наличия кэшей Ролей и Филиалов ---
    if (!companyLocations || companyLocations.length === 0 || !companyRoles || companyRoles.length === 0) {
        console.error("!!! openEmployeeModal: Кэши companyLocations или companyRoles пусты! Попытка перезагрузить...");
        // Пытаемся перезагрузить данные и снова открыть модалку
        // Добавляем защиту от бесконечного цикла
        if (!window.openEmployeeModalRetry) {
             window.openEmployeeModalRetry = true; // Ставим флаг
             showLoader();
             Promise.allSettled([apiFetch('/api/locations'), apiFetch('/api/roles')])
                 .then(results => {
                      if (results[0].status === 'fulfilled') companyLocations = results[0].value;
                      if (results[1].status === 'fulfilled') companyRoles = results[1].value;
                      // Повторный вызов ПОСЛЕ загрузки
                      openEmployeeModal(employee);
                 })
                 .catch(err => alert(`Критическая ошибка: Не удалось загрузить данные для формы сотрудника: ${err.message}`))
                 .finally(() => {
                      hideLoader();
                      delete window.openEmployeeModalRetry; // Сбрасываем флаг
                 });
        } else {
             alert("Ошибка: Не удалось загрузить данные о филиалах или должностях даже после перезагрузки.");
        }
        return; // Выходим в любом случае, пока данные грузятся
    }
    // --- Конец проверки кэшей ---

    // Генерируем опции для select'ов, используя актуальные кэши
    const locationsOptions = companyLocations
        .map(loc => `<option value="${loc.id}" ${isEdit && employee.location_id === loc.id ? 'selected' : ''}>${loc.name}</option>`)
        .join('');
    // Исключаем роль Владельца из списка при создании/редактировании
    const rolesOptions = companyRoles
        .filter(role => role.name !== 'Владелец') // Нельзя назначить/изменить на Владельца
        .map(role => `<option value="${role.id}" ${isEdit && employee.role_id === role.id ? 'selected' : ''}>${role.name}</option>`)
        .join('');

    // Проверяем, есть ли вообще роли для выбора (кроме Владельца) при СОЗДАНИИ
    if (!rolesOptions && !isEdit) {
         alert("Ошибка: Нет доступных должностей для назначения.\n\nСначала создайте должность во вкладке 'Должности и Доступы'.");
         return; // Не открываем модалку
    }

    // --- Генерируем HTML для модального окна ---
    modalContent.innerHTML = `
        <div class="flex justify-between items-start mb-4">
            <h3 class="text-2xl font-bold text-gray-800">${isEdit ? 'Редактировать Сотрудника' : 'Добавить Нового Сотрудника'}</h3>
            <button onclick="closeModal('employee-modal')" class="text-2xl font-bold leading-none p-1 -m-1 text-gray-500 hover:text-gray-700">&times;</button>
        </div>
        <form id="employee-form" class="space-y-4">
            
            <input type="hidden" id="employee-id" value="${isEdit ? employee.id : ''}">
            
            <div>
                <label for="employee-name" class="block text-sm font-medium text-gray-700">ФИО *</label>
                <input type="text" id="employee-name" class="mt-1 w-full p-2 border rounded focus:ring-indigo-500 focus:border-indigo-500" required value="${isEdit ? employee.full_name : ''}">
            </div>
            
            <div>
                <label for="employee-password" class="block text-sm font-medium text-gray-700">Пароль ${isEdit ? '' : '*'}</label>
                <input type="text" id="employee-password" class="mt-1 w-full p-2 border rounded focus:ring-indigo-500 focus:border-indigo-500" ${isEdit ? 'placeholder="Оставьте пустым, чтобы не менять"' : 'required'}>
            </div>
            
            <div>
                <label for="employee-location" class="block text-sm font-medium text-gray-700">Филиал *</label>
                <select id="employee-location" class="mt-1 w-full p-2 border rounded bg-white focus:ring-indigo-500 focus:border-indigo-500" required ${isEdit && employee.role?.name === 'Владелец' ? 'disabled title="Филиал Владельца нельзя изменить"' : ''}>
                    ${locationsOptions || '<option disabled>Нет доступных филиалов</option>'}
                </select>
            </div>
            
            <div>
                <label for="employee-role" class="block text-sm font-medium text-gray-700">Должность *</label>
                 ${isEdit && employee.role?.name === 'Владелец'
                     ? `<input type="text" class="mt-1 w-full p-2 border rounded bg-gray-100 cursor-not-allowed" value="Владелец" disabled title="Роль Владельца нельзя изменить">
                        <input type="hidden" id="employee-role" value="${employee.role_id}">` // Скрытое поле с ID роли
                     : `<select id="employee-role" class="mt-1 w-full p-2 border rounded bg-white focus:ring-indigo-500 focus:border-indigo-500" required>${rolesOptions}</select>`
                 }
            </div>
             
             ${isEdit ? `
             <div class="border-t pt-4">
                  <label class="flex items-center">
                     <input type="checkbox" id="employee-is-active-modal" class="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500" ${employee.is_active ? 'checked' : ''}>
                     <span class="ml-2 text-sm font-medium text-gray-700">Сотрудник Активен (Разрешен вход)</span>
                  </label>
             </div>` : ''}
             
            <div class="flex gap-4 mt-6 border-t pt-4">
                <button type="button" onclick="closeModal('employee-modal')" class="w-full bg-gray-200 py-2 rounded hover:bg-gray-300 text-gray-800">Отмена</button>
                <button type="submit" class="w-full bg-green-600 text-white py-2 rounded hover:bg-green-700">Сохранить</button>
            </div>
        </form>
    `;

    // --- Добавляем слушатель submit к ТОЛЬКО ЧТО созданной форме ---
    const formElement = document.getElementById('employee-form');
    if (formElement) {
        // Удаляем старые слушатели перед добавлением нового
        const newFormElement = formElement.cloneNode(true);
        formElement.parentNode.replaceChild(newFormElement, formElement);
        newFormElement.addEventListener('submit', handleSaveEmployee);
        console.log("[Modal Listener OK] Added submit to #employee-form");
    } else {
        console.error("!!! openEmployeeModal: Form #employee-form NOT FOUND after innerHTML!");
    }
    // --- Конец добавления слушателя ---

    openModal('employee-modal'); // Открываем модальное окно
    console.log("[Modal] openEmployeeModal: End");
}


// --- Сохранение данных Сотрудника (вызывается из модального окна) ---
async function handleSaveEmployee(e) {
    e.preventDefault(); // Предотвращаем стандартную отправку
    console.log("[Save] handleSaveEmployee: Start");
    showLoader(); // Показываем лоадер

    // Считываем ID (для определения режима - создание/редактирование)
    const employeeId = document.getElementById('employee-id')?.value;
    const isEdit = !!employeeId; // true, если ID есть
    
    // !!! КРИТИЧЕСКОЕ ИСПРАВЛЕНИЕ: ДОБАВЛЕНИЕ ПРЕФИКСА /api !!!
    const url = isEdit ? `/api/employees/${employeeId}` : '/api/employees'; 
    const method = isEdit ? 'PATCH' : 'POST'; 

    // Собираем данные из полей формы
    let payload = {
        full_name: document.getElementById('employee-name')?.value.trim(),
        location_id: parseInt(document.getElementById('employee-location')?.value),
        role_id: parseInt(document.getElementById('employee-role')?.value)
    };
    const password = document.getElementById('employee-password')?.value;
    
    // Добавляем пароль, если он введен ИЛИ если это создание нового сотрудника
    if (password || !isEdit) {
        payload.password = password; 
    }
    
    // Добавляем статус активности при редактировании (если чекбокс есть)
    if (isEdit) {
        const activeCheckbox = document.getElementById('employee-is-active-modal');
        if (activeCheckbox) payload.is_active = activeCheckbox.checked;
    }

    // Валидация: проверяем наличие обязательных полей
    if (!payload.full_name || isNaN(payload.location_id) || isNaN(payload.role_id) || (!payload.password && !isEdit)) {
        hideLoader();
        alert("Ошибка: Пожалуйста, заполните все обязательные поля (*): ФИО, Пароль (при создании), Филиал, Должность.");
        console.error("[Save] handleSaveEmployee: Validation failed. Payload:", payload, "isEdit:", isEdit);
        return; // Прерываем сохранение
    }

    try {
        // Отправляем запрос на сервер
        console.log(`[Save] handleSaveEmployee: Sending ${method} to ${url}`, payload);
        const result = await apiFetch(url, { method: method, body: JSON.stringify(payload) });
        console.log("[Save] handleSaveEmployee: Server response", result);

        // Обработка успеха
        alert(isEdit ? 'Данные сотрудника успешно обновлены!' : 'Новый сотрудник успешно создан!');
        closeModal('employee-modal'); // Закрываем модальное окно
        await fetchAndRenderEmployees(); // Обновляем список сотрудников на странице

    } catch(err) { // Обработка ошибок (от валидации или от apiFetch)
        console.error("!!! [Save] handleSaveEmployee: Error", err);
        alert(`Ошибка сохранения данных сотрудника: ${err.message}`);
        // Оставляем модальное окно открытым для исправления
    } finally {
        // --- Скрываем лоадер в любом случае ---
        hideLoader();
        console.log("[Save] handleSaveEmployee: End");
    }
}

// --- Обработка кликов в списке сотрудников (делегирование) ---
// Вызывается слушателем, добавленным в renderEmployeesTab
function handleEmployeeActions(e) {
    // Ищем ближайшую кнопку к месту клика
    const editButton = e.target.closest('.edit-employee-btn');
    const toggleStatusButton = e.target.closest('.toggle-status-employee-btn');
    const deleteButton = e.target.closest('.delete-employee-btn');

    // Обработка кнопки Редактировать
    if (editButton) {
        console.log("[Action] Edit employee button clicked");
        try {
            // Извлекаем данные сотрудника из data-атрибута
            const employeeData = JSON.parse(editButton.dataset.employeeJson);
            // Пытаемся дополнить данными роли из кэша (для отображения в модалке)
            employeeData.role = companyRoles.find(r => r.id === employeeData.role_id);
            if (!employeeData.role) console.warn("[Action] Role details not found in cache for employee:", employeeData);
            openEmployeeModal(employeeData); // Открываем модалку для редактирования
        } catch (err) {
            console.error("!!! [Action] Error parsing employee data for edit:", err);
            alert("Ошибка: Не удалось прочитать данные сотрудника для редактирования.");
        }
        return; // Прерываем, чтобы не сработали другие кнопки
    }

    // Обработка кнопки Уволить/Восстановить
    if (toggleStatusButton) {
        console.log("[Action] Toggle status employee button clicked");
        const employeeId = toggleStatusButton.dataset.employeeId;
        const employeeName = toggleStatusButton.dataset.employeeName;
        const isActive = toggleStatusButton.dataset.isActive === 'true'; // Преобразуем строку в boolean
        const actionText = isActive ? 'Уволить' : 'Восстановить';
        // Запрашиваем подтверждение
        if (confirm(`${actionText} сотрудника "${employeeName}"?`)) {
            handleToggleEmployeeStatus(employeeId, !isActive); // Вызываем функцию смены статуса
        }
        return; // Прерываем
    }

    // Обработка кнопки Полное Удаление
    if (deleteButton) {
        console.log("[Action] Delete employee button clicked");
        const employeeId = deleteButton.dataset.employeeId;
        const employeeName = deleteButton.dataset.employeeName;
         // Двойное подтверждение для опасной операции
        if (confirm(`ВНИМАНИЕ!\n\nВы собираетесь ПОЛНОСТЬЮ УДАЛИТЬ сотрудника "${employeeName}"?\n\nЭто действие удалит его смены, расходы и отвяжет от выданных им заказов.\n\nДЕЙСТВИЕ НЕОБРАТИМО!`)) {
             if (confirm(`ПОСЛЕДНЕЕ ПРЕДУПРЕЖДЕНИЕ:\n\nТОЧНО УДАЛИТЬ "${employeeName}"?`)){
                  handleDeleteEmployee(employeeId, employeeName); // Вызываем функцию удаления
             }
        }
        return; // Прерываем
    }
}

// --- Смена статуса (Уволить/Восстановить) через API ---
async function handleToggleEmployeeStatus(employeeId, newStatus /* true or false */) {
     const actionText = newStatus ? 'восстановлен' : 'уволен';
     console.log(`[Action] handleToggleEmployeeStatus: Setting status ${newStatus} for employee ID ${employeeId}`);
     showLoader(); // Показываем лоадер
     try {
         // Отправляем PATCH запрос только с полем is_active
         await apiFetch(`/api/employees/${employeeId}`, {
              method: 'PATCH',
              body: JSON.stringify({ is_active: newStatus })
         });
         console.log(`[Action] handleToggleEmployeeStatus: Success for employee ID ${employeeId}`);
         alert(`Сотрудник "${actionText}".`); // Краткое сообщение
         await fetchAndRenderEmployees(); // Обновляем список сотрудников
     } catch (err) { // Обработка ошибок от apiFetch
          console.error("!!! [Action] handleToggleEmployeeStatus: Error", err);
          alert(`Ошибка при попытке ${actionText.slice(0,-1)}ить сотрудника: ${err.message}`);
     } finally {
          hideLoader(); // Скрываем лоадер
          console.log(`[Action] handleToggleEmployeeStatus: End for employee ID ${employeeId}`);
     }
}

// --- Полное удаление сотрудника через API ---
async function handleDeleteEmployee(employeeId, employeeName) {
     console.log(`[Delete] handleDeleteEmployee: Start deleting ID ${employeeId} (${employeeName})`);
     showLoader(); // Показываем лоадер
     try {
         // TODO: Убедиться, что на бэкенде есть эндпоинт DELETE /employees/{id}
         //       и он корректно обрабатывает удаление (например, проверяет зависимости).

         // --- ВРЕМЕННАЯ ЗАГЛУШКА: Используем PATCH для деактивации ---
          console.warn(`[Delete] handleDeleteEmployee: Using PATCH to deactivate instead of DELETE (endpoint DELETE /employees/{id} should be implemented).`);
           await apiFetch(`/api/employees/${employeeId}`, {
                method: 'PATCH',
                body: JSON.stringify({ is_active: false }) // Просто деактивируем
           });
          alert(`Сотрудник "${employeeName}" был деактивирован (уволен).\n\nПримечание: Полное удаление данных пока не реализовано на сервере.`);
         // --- КОНЕЦ ЗАГЛУШКИ ---

         /* --- КОД ДЛЯ РЕАЛЬНОГО УДАЛЕНИЯ (когда будет готов бэкенд) ---
         console.log(`[Delete] Sending DELETE request for employee ID ${employeeId}`);
         await apiFetch(`/employees/${employeeId}`, { method: 'DELETE' });
         console.log(`[Delete] handleDeleteEmployee: Employee ID ${employeeId} deleted successfully.`);
         alert(`Сотрудник "${employeeName}" и все связанные с ним данные были успешно удалены.`);
         */

         await fetchAndRenderEmployees(); // Обновляем список сотрудников

     } catch (err) { // Обработка ошибок от apiFetch
          console.error("!!! [Delete] handleDeleteEmployee: Error", err);
          // Бэкенд может вернуть ошибку (400), если нельзя удалить сотрудника
          alert(`Ошибка удаления сотрудника "${employeeName}": ${err.message}`);
     } finally {
          hideLoader(); // Скрываем лоадер
          console.log("[Delete] handleDeleteEmployee: End");
     }
}

// === КОНЕЦ МОДУЛЯ ПЕРСОНАЛ ===

// =================================================================
// МОДУЛЬ: РОЛИ И ДОСТУПЫ (Владелец) (v4.1 - Rebuild)
// =================================================================

// --- Рендеринг вкладки "Должности и Доступы" ---
// Вызывается из initializeMainAppUI, если у Владельца есть права 'manage_roles'
async function renderRolesTab() {
    console.log("[Render] renderRolesTab: Start");
    const pane = document.getElementById('tab-roles');
    if (!pane) {
        console.warn("[Render] renderRolesTab: Pane #tab-roles not found.");
        return; // Выходим, если контейнер вкладки не найден
    }

    // Генерируем основной HTML для вкладки
    pane.innerHTML = `
        <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
            <div class="md:col-span-1">
                <div class="bg-white p-6 rounded-lg shadow-md h-fit">
                    <h2 class="text-xl font-semibold mb-4">Добавить Новую Должность</h2>
                    <form id="add-role-form" class="space-y-3">
                        <label for="new-role-name" class="block text-sm font-medium text-gray-700">Название Должности *</label>
                        <input type="text" id="new-role-name" placeholder="Например: Менеджер, Кассир" class="w-full p-2 border rounded" required>
                        <button type="submit" class="w-full bg-indigo-600 text-white font-bold py-2 rounded-lg hover:bg-indigo-700">Создать Должность</button>
                    </form>
                </div>
            </div>
            <div class="md:col-span-2">
                 <div class="bg-white p-6 rounded-lg shadow-md">
                    <h2 class="text-2xl font-bold mb-4">Существующие Должности</h2>
                    <div id="roles-list" class="space-y-3">Загрузка списка должностей...</div>
                </div>
            </div>
        </div>
    `;

    // --- Добавляем слушатели к элементам, созданным ВЫШЕ ---
    const addForm = document.getElementById('add-role-form');
    const rolesListDiv = document.getElementById('roles-list');

    if (addForm) {
        // ИСПРАВЛЕНИЕ: Используем безопасный .parentNode?.replaceChild
        const newAddForm = addForm.cloneNode(true);
        addForm.parentNode?.replaceChild(newAddForm, addForm);
        newAddForm.addEventListener('submit', handleAddRole);
        console.log("[Listener OK] Added submit to #add-role-form");
    } else {
        console.error("!!! renderRolesTab: Element #add-role-form NOT FOUND after innerHTML.");
    }

    if (rolesListDiv) {
         // Используем делегирование событий для кнопок "Настроить"/"Удалить"
         const newRolesListDiv = rolesListDiv.cloneNode(false); // Клонируем пустой
         // ИСПРАВЛЕНИЕ: Добавляем ?. (знак вопроса) перед replaceChild
         rolesListDiv.parentNode?.replaceChild(newRolesListDiv, rolesListDiv);
         newRolesListDiv.innerHTML = 'Загрузка списка должностей...'; // Восстанавливаем заглушку
         // Добавляем слушатель к НОВОМУ контейнеру
         newRolesListDiv.addEventListener('click', handleRoleActions);
         console.log("[Listener OK] Added click delegate listener to #roles-list");
    } else {
         console.error("!!! renderRolesTab: Element #roles-list NOT FOUND after innerHTML.");
    }
    // --- Конец добавления слушателей ---

    // Загружаем и отображаем данные
    await fetchAndRenderRoles();
    console.log("[Render] renderRolesTab: End");
}

// --- Загрузка и отображение списка Ролей и Прав ---
async function fetchAndRenderRoles() {
     console.log("[Fetch] fetchAndRenderRoles: Start");
     const listDiv = document.getElementById('roles-list'); // Ищем контейнер
     if (!listDiv) return;
     listDiv.innerHTML = '<p class="text-gray-500 animate-pulse">Загрузка должностей...</p>';
     // showLoader(); // Не используем глобальный лоадер

     try {
         // Загружаем Роли и Права ПАРАЛЛЕЛЬНО
         console.log("[Fetch] fetchAndRenderRoles: Fetching roles and permissions...");
         // Используем Promise.allSettled для надежности
         const results = await Promise.allSettled([
              apiFetch('/api/roles'), // Роли текущей компании
              // Права загружаем только если кэш пуст (они глобальные, но фильтруются на бэке)
              (!companyPermissions || companyPermissions.length === 0) ? apiFetch('/api/permissions') : Promise.resolve(companyPermissions)
         ]);

         // Обрабатываем результаты
         if (results[0].status === 'fulfilled') {
              companyRoles = results[0].value; // Обновляем кэш ролей
              console.log("[Fetch] fetchAndRenderRoles: Received roles:", companyRoles);
         } else {
               throw new Error(`Не удалось загрузить роли: ${results[0].reason?.message || results[0].reason}`);
         }
         if (results[1].status === 'fulfilled') {
              companyPermissions = results[1].value; // Обновляем кэш прав
              console.log("[Fetch] fetchAndRenderRoles: Received permissions:", companyPermissions);
         } else {
               // Не критично, если права не загрузились, но нужно предупредить
               console.warn(`[Fetch] fetchAndRenderRoles: Не удалось загрузить разрешения: ${results[1].reason?.message || results[1].reason}`);
               // Оставляем старый кэш прав, если он был
         }


         // Рендерим список ролей
         if (!companyRoles || companyRoles.length === 0) {
             listDiv.innerHTML = '<p class="text-gray-500">У вашей компании еще нет должностей (кроме "Владелец").</p>';
         } else {
             listDiv.innerHTML = companyRoles.map(role => `
                 <div class="p-3 bg-gray-50 rounded-md border flex flex-wrap justify-between items-center gap-2">
                     <p class="font-bold flex-grow text-lg">${role.name}</p>
                     <div class="flex-shrink-0 flex gap-2">
                         ${role.name !== 'Владелец' ? ` <button data-role-id="${role.id}" data-role-name="${role.name}" class="permissions-btn text-sm bg-blue-200 hover:bg-blue-300 text-blue-800 px-3 py-1 rounded">Настроить доступы</button>
                         <button data-role-id="${role.id}" data-role-name="${role.name}" class="delete-role-btn text-sm bg-red-200 hover:bg-red-300 text-red-800 px-3 py-1 rounded" title="Удалить должность">&times;</button>
                         ` : '<span class="text-sm text-gray-500">(Стандартная роль)</span>'}
                     </div>
                 </div>
             `).join('');
         }
         console.log("[Fetch] fetchAndRenderRoles: Success");
     } catch (e) {
         console.error("[Fetch] fetchAndRenderRoles: Error", e);
         listDiv.innerHTML = `<p class="text-red-500">Ошибка загрузки должностей: ${e.message}</p>`;
     } finally {
         // hideLoader();
     }
}

// --- Обработчик для формы "Добавить должность" ---
async function handleAddRole(e) {
    e.preventDefault(); // Предотвращаем перезагрузку
    console.log("[Role Action] handleAddRole: Start");
    const nameInput = document.getElementById('new-role-name');
    const roleName = nameInput ? nameInput.value.trim() : null;

    if (!roleName) {
        alert("Введите название для новой должности.");
        return;
    }
    showLoader(); // Показываем лоадер
    try {
        // Отправляем POST запрос на создание роли
        console.log(`[Role Action] Creating role: ${roleName}`);
        await apiFetch('/api/roles', {
            method: 'POST',
            body: JSON.stringify({ name: roleName }) // Отправляем только имя
        });
        console.log(`[Role Action] Role "${roleName}" created successfully.`);
        alert(`Должность "${roleName}" успешно создана!`);
        if(nameInput) nameInput.value = ''; // Очищаем поле ввода
        await fetchAndRenderRoles(); // Обновляем список ролей на странице
    } catch(err) { // Обработка ошибок от apiFetch
        console.error("[Role Action] handleAddRole: Error", err);
        alert(`Ошибка создания должности: ${err.message}`);
    } finally {
        hideLoader(); // Скрываем лоадер
        console.log("[Role Action] handleAddRole: End");
    }
}

// --- Обработчик кликов по кнопкам в списке ролей (делегирование) ---
// Вызывается слушателем, добавленным в renderRolesTab
function handleRoleActions(e) {
     // Ищем ближайшую кнопку к месту клика
     const targetButton = e.target.closest('button');
     if (!targetButton) return; // Клик не по кнопке

     const roleId = targetButton.dataset.roleId;
     const roleName = targetButton.dataset.roleName;

     // Определяем действие по классу кнопки
     if (targetButton.classList.contains('permissions-btn')) {
         console.log(`[Role Action] Permissions button clicked for ID: ${roleId} (${roleName})`);
         openPermissionsModal(roleId, roleName); // Открываем окно настройки прав
     }
     else if (targetButton.classList.contains('delete-role-btn')) {
         console.log(`[Role Action] Delete button clicked for ID: ${roleId} (${roleName})`);
         // Запрашиваем подтверждение перед удалением
         if (confirm(`Вы уверены, что хотите удалить должность "${roleName}"?\n\nСотрудники с этой должностью потеряют доступ, соответствующий этой роли.`)) {
             handleDeleteRole(roleId, roleName); // Вызываем функцию удаления
         }
     }
}

// --- Функция удаления роли ---
async function handleDeleteRole(roleId, roleName) {
    console.log(`[Delete] handleDeleteRole: Start deleting ID ${roleId} (${roleName})`);
    showLoader();
    try {
        // Отправляем DELETE запрос на бэкенд
        await apiFetch(`/api/roles/${roleId}`, { method: 'DELETE' });
        console.log(`[Delete] handleDeleteRole: Role ID ${roleId} deleted successfully.`);
        alert(`Должность "${roleName}" успешно удалена.`);
        await fetchAndRenderRoles(); // Обновляем список ролей
    } catch(err) { // Обработка ошибок от apiFetch (включая 400, если роль используется)
        console.error("[Delete] handleDeleteRole: Error", err);
        alert(`Ошибка удаления должности "${roleName}": ${err.message}`);
    } finally {
        hideLoader(); // Скрываем лоадер
        console.log("[Delete] handleDeleteRole: End");
    }
}

// --- Открытие модального окна настройки прав доступа ---
async function openPermissionsModal(roleId, roleName) {
    console.log(`[Modal] openPermissionsModal: Start for Role ID ${roleId} (${roleName})`);
    const permissionsModal = document.getElementById('permissions-modal');
    if (!permissionsModal) return console.error("!!! openPermissionsModal: Modal element #permissions-modal not found!");
    const modalContent = permissionsModal.querySelector('.modal-content');
    if (!modalContent) return console.error("!!! openPermissionsModal: Modal content not found!");

    modalContent.innerHTML = '<p class="text-gray-500 animate-pulse">Загрузка текущих прав...</p>';
    openModal('permissions-modal'); // Открываем модалку сразу с заглушкой
    // showLoader(); // Не используем глобальный лоадер

    try {
        // Проверяем наличие кэша прав, если нет - загружаем
        if (!companyPermissions || companyPermissions.length === 0) {
             console.log("[Modal] openPermissionsModal: Permissions cache empty, fetching...");
             companyPermissions = await apiFetch('/api/permissions');
             console.log("[Modal] openPermissionsModal: Permissions loaded:", companyPermissions);
             if (!companyPermissions || companyPermissions.length === 0) {
                   throw new Error("Не удалось загрузить список доступных разрешений.");
             }
        }

        // Получаем ТЕКУЩИЕ ID прав для ЭТОЙ роли
        console.log(`[Modal] openPermissionsModal: Fetching current permissions for Role ID ${roleId}...`);
        const currentPermissionIds = await apiFetch(`/api/roles/${roleId}/permissions`); // Бэкенд вернет массив ID
        const currentPermissionIdsSet = new Set(currentPermissionIds || []); // Создаем Set для быстрой проверки
        console.log(`[Modal] openPermissionsModal: Current permission IDs for Role ID ${roleId}:`, currentPermissionIdsSet);


        // Генерируем HTML для чекбоксов на основе кэша companyPermissions
        const permissionsHtml = companyPermissions.map(p => `
            <div class="flex items-center py-1">
                <input id="perm-${p.id}" type="checkbox" value="${p.id}"
                       class="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500 permission-checkbox"
                       ${currentPermissionIdsSet.has(p.id) ? 'checked' : ''}>
                <label for="perm-${p.id}" class="ml-3 block text-sm font-medium text-gray-700">${p.description}</label>
            </div>
        `).join('');

        // Устанавливаем HTML в модальное окно
        modalContent.innerHTML = `
            <div class="flex justify-between items-start mb-4">
                <h3 class="text-2xl font-bold">Настройка доступов для: <span class="text-indigo-600">${roleName}</span></h3>
                <button onclick="closeModal('permissions-modal')" class="text-2xl font-bold leading-none p-1 -m-1">&times;</button>
            </div>
            <form id="permissions-form" data-role-id="${roleId}">
                <div class="space-y-2 max-h-[60vh] overflow-y-auto border rounded p-4 mb-4 bg-gray-50">
                     ${permissionsHtml || '<p class="text-gray-500">Нет доступных разрешений.</p>'}
                </div>
                <div class="flex gap-4 mt-6 border-t pt-4">
                    <button type="button" onclick="closeModal('permissions-modal')" class="w-full bg-gray-200 py-2 rounded hover:bg-gray-300 text-gray-800">Отмена</button>
                    <button type="submit" class="w-full bg-green-600 text-white py-2 rounded hover:bg-green-700">Сохранить Права</button>
                </div>
            </form>
        `;

        // --- Добавляем слушатель submit к ТОЛЬКО ЧТО созданной форме ---
        const formElement = document.getElementById('permissions-form');
        if (formElement) {
            const newFormElement = formElement.cloneNode(true);
            formElement.parentNode.replaceChild(newFormElement, formElement);
            newFormElement.addEventListener('submit', handleSavePermissions);
            console.log("[Modal Listener OK] Added submit to #permissions-form");
        } else {
            console.error("!!! openPermissionsModal: Form #permissions-form NOT FOUND after innerHTML!");
        }
        // --- Конец добавления слушателя ---

    } catch (err) { // Обработка ошибок загрузки прав
        console.error("[Modal] openPermissionsModal: Error loading permissions", err);
        modalContent.innerHTML = `
             <div class="flex justify-between items-start mb-4">
                 <h3 class="text-2xl font-bold">Ошибка</h3>
                 <button onclick="closeModal('permissions-modal')" class="text-2xl font-bold leading-none p-1 -m-1">&times;</button>
             </div>
             <p class="text-red-500">Не удалось загрузить права доступа: ${err.message}</p>
             <div class="mt-4 text-right">
                  <button onclick="closeModal('permissions-modal')" class="bg-gray-200 py-2 px-4 rounded">Закрыть</button>
             </div>`;
    } finally {
        // hideLoader(); // Глобальный лоадер не используется
        console.log(`[Modal] openPermissionsModal: End for Role ID ${roleId}`);
    }
}

// --- Сохранение измененных прав доступа ---
async function handleSavePermissions(e) {
    e.preventDefault(); // Предотвращаем стандартную отправку
    console.log("[Save Permissions] handleSavePermissions: Start");
    const form = e.target;
    const roleId = form.dataset.roleId;
    if (!roleId) {
         alert("Ошибка: Не удалось определить ID роли.");
         return;
    }

    // Собираем ID ВСЕХ отмеченных чекбоксов внутри формы
    const selectedPermissionIds = Array.from(form.querySelectorAll('.permission-checkbox:checked'))
                                     .map(checkbox => parseInt(checkbox.value));

    console.log(`[Save Permissions] Saving permissions for Role ID ${roleId}. Selected IDs:`, selectedPermissionIds);
    showLoader(); // Показываем лоадер

    try {
        // Отправляем PUT запрос на бэкенд со списком ID
        await apiFetch(`/api/roles/${roleId}/permissions`, {
            method: 'PUT',
            body: JSON.stringify({ permission_ids: selectedPermissionIds })
        });
        console.log(`[Save Permissions] Permissions saved successfully for Role ID ${roleId}.`);
        alert('Права доступа успешно обновлены!');
        closeModal('permissions-modal'); // Закрываем модальное окно
        // Перезагружать список ролей не нужно, так как мы меняли только права

    } catch(err) { // Обработка ошибок от apiFetch
        console.error("[Save Permissions] handleSavePermissions: Error", err);
        alert(`Ошибка сохранения прав доступа: ${err.message}`);
        // Оставляем модальное окно открытым для повторной попытки
    } finally {
        hideLoader(); // Скрываем лоадер
        console.log("[Save Permissions] handleSavePermissions: End");
    }
}

// =================================================================
// МОДУЛЬ: КЛИЕНТЫ (Владелец) (v4.1 - Rebuild)
// =================================================================

companyClients = []; // Кэш для хранения списка клиентов текущей компании

// --- Рендеринг вкладки "Клиенты" ---
// Вызывается из initializeMainAppUI, если у Владельца есть права 'manage_clients'
async function renderClientsTab() {
    console.log("[Render] renderClientsTab: Start");
    const pane = document.getElementById('tab-clients');
    if (!pane) {
        console.warn("[Render] renderClientsTab: Pane #tab-clients not found.");
        return; // Выходим, если контейнер вкладки не найден
    }

    // Генерируем основной HTML для вкладки
    pane.innerHTML = `
        <div class="bg-white p-6 rounded-lg shadow-md">
            <div class="flex flex-wrap justify-between items-center gap-4 mb-4 border-b pb-4">
                <h2 class="text-2xl font-bold text-gray-800">Клиенты Компании</h2>
                <div class="flex items-center gap-4">
                     <button id="client-tools-btn" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded-lg text-sm">🛠️ Инструменты</button>
                    <button id="add-client-btn" class="bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 text-sm">➕ Добавить клиента</button>
                </div>
            </div>
            <div class="mb-4">
                <input type="search" id="clients-search-input" placeholder="🔍 Поиск по имени, телефону, коду..." class="w-full p-2 border rounded-lg focus:ring-indigo-500 focus:border-indigo-500">
            </div>
            <div id="clients-list" class="space-y-3">Загрузка списка клиентов...</div>
        </div>
        `;

    // --- Добавляем слушатели к элементам, созданным ВЫШЕ ---
    const addBtn = document.getElementById('add-client-btn');
    const searchInput = document.getElementById('clients-search-input');
    const clientListDiv = document.getElementById('clients-list');
    const toolsBtn = document.getElementById('client-tools-btn');

    // Кнопка "Добавить клиента"
    if (addBtn) {
        addBtn.replaceWith(addBtn.cloneNode(true)); // Удаляем старые слушатели
        document.getElementById('add-client-btn').addEventListener('click', () => openClientModal()); // Открывает пустую модалку
        console.log("[Listener OK] Added click to #add-client-btn");
    } else {
        console.error("!!! renderClientsTab: Element #add-client-btn NOT FOUND.");
    }

    // Поле поиска
    if (searchInput) {
         searchInput.replaceWith(searchInput.cloneNode(true));
         document.getElementById('clients-search-input').addEventListener('input', handleClientsSearch); // Фильтрует список при вводе
         console.log("[Listener OK] Added input listener to #clients-search-input");
    } else {
         console.error("!!! renderClientsTab: Element #clients-search-input NOT FOUND.");
    }

    // Список клиентов (для кнопок Редакт/Удалить/ЛК через делегирование)
    if (clientListDiv) {
         const newClientListDiv = clientListDiv.cloneNode(false);
         clientListDiv.parentNode?.replaceChild(newClientListDiv, clientListDiv);
         newClientListDiv.innerHTML = 'Загрузка списка клиентов...';
         newClientListDiv.addEventListener('click', handleClientListActions); // Обрабатывает клики внутри списка
         console.log("[Listener OK] Added click delegate listener to #clients-list");
    } else {
         console.error("!!! renderClientsTab: Element #clients-list NOT FOUND.");
    }

    // Кнопка "Инструменты"
    if (toolsBtn) {
         toolsBtn.replaceWith(toolsBtn.cloneNode(true));
         document.getElementById('client-tools-btn').addEventListener('click', () => {
             // Очищаем результаты импорта и сбрасываем файл перед открытием
             const resultsDiv = document.getElementById('client-import-results');
             const fileInput = document.getElementById('client-excel-input');
             if (resultsDiv) resultsDiv.innerHTML = '';
             if (fileInput) fileInput.value = '';
             openModal('client-tools-modal'); // Открываем модальное окно инструментов
         });
         console.log("[Listener OK] Added click to #client-tools-btn");
    } else {
         console.error("!!! renderClientsTab: Element #client-tools-btn NOT FOUND.");
    }

    // Слушатель для кнопки "Импортировать" внутри модалки client-tools-modal
    // добавляется в initializeGlobalEventListeners, т.к. модалка статична.

    // --- Конец добавления слушателей ---

    // Загружаем и отображаем данные клиентов
    await fetchAndRenderClients();
    console.log("[Render] renderClientsTab: End");
}

// --- Загрузка и отображение списка Клиентов ---
async function fetchAndRenderClients() {
    console.log("[Fetch] fetchAndRenderClients: Start");
    const listDiv = document.getElementById('clients-list'); // Ищем контейнер
    if (!listDiv) return;
    listDiv.innerHTML = '<p class="text-gray-500 animate-pulse">Загрузка клиентов...</p>';
    // showLoader(); // Не показываем глобальный лоадер

    try {
        // Запрашиваем клиентов текущей компании
        const clients = await apiFetch('/api/clients');
        companyClients = clients; // Обновляем кэш
        console.log("[Fetch] fetchAndRenderClients: Received clients:", clients);

        if (!clients || clients.length === 0) {
            listDiv.innerHTML = '<p class="text-gray-500">У вашей компании еще нет клиентов.</p>';
        } else {
            // Генерируем HTML для каждого клиента
            listDiv.innerHTML = clients.map(c => `
                <div class="client-list-item p-3 bg-gray-50 rounded-md border flex flex-wrap justify-between items-center gap-2"
                     data-client-name="${c.full_name}"
                     data-client-phone="${c.phone}"
                     data-client-code="${(c.client_code_prefix || '') + (c.client_code_num || '')}">
                    <div class="flex-grow min-w-[200px]"> <p class="font-bold text-lg">${c.full_name} (${c.client_code_prefix || ''}${c.client_code_num || 'Нет кода'})</p>
                        <p class="text-sm text-gray-600">${c.phone} ${c.telegram_chat_id ? '<span class="text-blue-500 font-bold text-xs" title="Telegram привязан"> (TG)</span>' : ''}</p>
                        <p class="text-xs text-gray-500">Статус: ${c.status || 'Розница'}</p>
                    </div>
                    <div class="flex-shrink-0 flex gap-2">
                        <button data-client-id="${c.id}" class="lk-link-client-btn text-sm bg-blue-100 hover:bg-blue-200 text-blue-800 px-3 py-1 rounded" title="Получить ссылку на Личный Кабинет">🔗ЛК</button>
                        <button data-client-id="${c.id}" data-client-json='${JSON.stringify(c)}' class="edit-client-btn text-sm bg-gray-200 hover:bg-gray-300 px-3 py-1 rounded">Редакт.</button>
                        <button data-client-id="${c.id}" data-client-name="${c.full_name}" class="delete-client-btn text-sm bg-red-200 hover:bg-red-300 text-red-800 px-3 py-1 rounded">Удалить</button>
                    </div>
                </div>
            `).join('');
            // Слушатели для кнопок добавляются через делегирование на #clients-list
        }
        console.log("[Fetch] fetchAndRenderClients: Success");
    } catch (e) {
        console.error("[Fetch] fetchAndRenderClients: Error", e);
        listDiv.innerHTML = `<p class="text-red-500">Ошибка загрузки клиентов: ${e.message}</p>`;
    } finally {
        // hideLoader();
    }
}

// --- Открытие модального окна Клиента (для создания или редактирования) ---
function openClientModal(client = null) {
    console.log("[Modal] openClientModal: Start", client);
    const modal = document.getElementById('client-modal');
    if (!modal) return console.error("!!! openClientModal: Modal element #client-modal not found!");
    const modalContent = modal.querySelector('.modal-content');
    if (!modalContent) return console.error("!!! openClientModal: Modal content not found!");

    const isEdit = client !== null; // true, если переданы данные для редактирования

    // Генерируем HTML для модального окна
    modalContent.innerHTML = `
        <div class="flex justify-between items-start mb-4">
            <h3 class="text-2xl font-bold">${isEdit ? 'Редактировать клиента' : 'Добавить нового клиента'}</h3>
            <button onclick="closeModal('client-modal')" class="text-2xl font-bold leading-none p-1 -m-1">&times;</button>
        </div>
        <form id="client-form-inner" class="space-y-4">
             <input type="hidden" id="modal-client-id" value="${isEdit ? client.id : ''}">
            <div>
                <label for="modal-client-full_name" class="block text-sm font-medium text-gray-700">ФИО *</label>
                <input type="text" id="modal-client-full_name" value="${isEdit ? client.full_name : ''}" class="mt-1 w-full p-2 border rounded" required>
            </div>
            <div>
                <label for="modal-client-phone" class="block text-sm font-medium text-gray-700">Телефон *</label>
                <input type="text" id="modal-client-phone" value="${isEdit ? client.phone : ''}" placeholder="Например: 996555123456 или 0555123456" class="mt-1 w-full p-2 border rounded" required>
            </div>
            <div class="grid grid-cols-3 gap-2">
                <div>
                    <label for="modal-client-prefix" class="block text-sm font-medium text-gray-700">Префикс Кода</label>
                    <input type="text" id="modal-client-prefix" value="${isEdit ? (client.client_code_prefix || '') : (currentCompany?.company_code || 'KB')}" class="mt-1 w-full p-2 border rounded uppercase" maxlength="5">
                </div>
                <div class="col-span-2">
                    <label for="modal-client-code" class="block text-sm font-medium text-gray-700">Номер Кода</label>
                    <input type="number" id="modal-client-code" value="${isEdit ? (client.client_code_num || '') : ''}" class="mt-1 w-full p-2 border rounded" placeholder="${isEdit ? 'Можно менять' : 'Авто (если пусто)'}">
                    <p class="text-xs text-gray-500 mt-1">Оставьте пустым при создании для авто-генерации.</p>
                </div>
            </div>
             <div>
                <label for="modal-client-status" class="block text-sm font-medium text-gray-700">Статус клиента</label>
                <input type="text" id="modal-client-status" value="${isEdit ? (client.status || 'Розница') : 'Розница'}" class="mt-1 w-full p-2 border rounded" placeholder="Например: Розница, Опт">
            </div>
             ${isEdit ? `
             <div class="text-sm ${client.telegram_chat_id ? 'text-green-600 font-semibold' : 'text-gray-500'}">
                <span class="font-medium">Telegram:</span> ${client.telegram_chat_id ? `Привязан (${client.telegram_chat_id})` : 'Не привязан (клиент должен привязать сам в боте)'}
                ${client.telegram_chat_id ? '<button type="button" id="modal-client-unlink-tg" class="ml-2 text-xs text-red-500 underline hover:text-red-700">Отвязать</button>' : ''}
             </div>` : ''}
            <div class="flex gap-4 mt-6 border-t pt-4">
                <button type="button" onclick="closeModal('client-modal')" class="w-full bg-gray-200 py-2 rounded hover:bg-gray-300 text-gray-800">Отмена</button>
                <button type="submit" class="w-full bg-green-600 text-white py-2 rounded hover:bg-green-700">Сохранить</button>
            </div>
        </form>
    `;

    // --- Добавляем слушатель submit к ТОЛЬКО ЧТО созданной форме ---
    const formElement = document.getElementById('client-form-inner');
    if (formElement) {
        const newFormElement = formElement.cloneNode(true);
        formElement.parentNode.replaceChild(newFormElement, formElement);
        newFormElement.addEventListener('submit', handleSaveClient);
        console.log("[Modal Listener OK] Added submit to #client-form-inner");
        // Добавляем слушатель для кнопки отвязки TG, если она есть
        const unlinkBtn = document.getElementById('modal-client-unlink-tg');
        if (unlinkBtn) {
            unlinkBtn.addEventListener('click', () => handleUnlinkTelegram(client?.id));
        }
    } else {
        console.error("!!! openClientModal: Form #client-form-inner NOT FOUND after innerHTML!");
    }
    // --- Конец добавления слушателя ---

    openModal('client-modal'); // Открываем модальное окно
    console.log("[Modal] openClientModal: End");
}

// --- Сохранение данных Клиента (вызывается из модального окна) ---

async function handleSaveClient(e) {
    e.preventDefault(); // Предотвращаем стандартную отправку
    console.log("[Save] handleSaveClient: Start");
    showLoader(); // Показываем лоадер

    // Считываем ID (для определения режима - создание/редактирование)
    const clientId = document.getElementById('modal-client-id')?.value;
    const isEdit = !!clientId; // true, если ID есть
    
    // !!! КРИТИЧЕСКОЕ ИСПРАВЛЕНИЕ: ДОБАВЛЕНИЕ ПРЕФИКСА /api !!!
    // Создание: /api/clients (POST)
    // Редактирование: /api/clients/{id} (PATCH)
    const url = isEdit ? `/api/clients/${clientId}` : '/api/clients'; 
    const method = isEdit ? 'PATCH' : 'POST'; 
    // ... (Остальной код остается)
    
    // Собираем данные из полей модального окна
    const payload = {
        full_name: document.getElementById('modal-client-full_name')?.value.trim(),
        phone: document.getElementById('modal-client-phone')?.value.trim(),
        // Префикс: берем введенный ИЛИ код компании ИЛИ 'KB'
        client_code_prefix: document.getElementById('modal-client-prefix')?.value.trim().toUpperCase() || (currentCompany?.company_code) || 'KB',
        // Номер кода: null если пусто или 0
        client_code_num: parseInt(document.getElementById('modal-client-code')?.value) || null,
        // Вы указали "Оптовик" — статус передается как есть
        status: document.getElementById('modal-client-status')?.value.trim() || 'Розница' 
    };

    // Удаляем номер кода из payload при СОЗДАНИИ, если он null (чтобы сработала авто-генерация на бэке)
     if (!isEdit && payload.client_code_num === null) {
         delete payload.client_code_num;
     }

    // Валидация: проверяем наличие ФИО и Телефона
    if (!payload.full_name || !payload.phone) {
         hideLoader();
         alert("ФИО и Телефон обязательны для заполнения.");
         return; 
    }

    try {
        // Отправляем запрос на сервер
        console.log(`[Save] handleSaveClient: Sending ${method} to ${url}`, payload);
        const result = await apiFetch(url, { method: method, body: JSON.stringify(payload) });
        console.log("[Save] handleSaveClient: Server response", result);

        // Обработка успеха
        alert(isEdit ? 'Данные клиента успешно обновлены!' : 'Новый клиент успешно создан!');
        closeModal('client-modal'); // Закрываем модальное окно
        await fetchAndRenderClients(); // Обновляем список клиентов на странице

    } catch(err) { // Обработка ошибок (от валидации или от apiFetch)
        console.error("!!! [Save] handleSaveClient: Error", err);
        alert(`Ошибка сохранения данных клиента: ${err.message}`);
        // Оставляем модальное окно открытым для исправления
    } finally {
        // --- Скрываем лоадер в любом случае ---
        hideLoader();
        console.log("[Save] handleSaveClient: End");
    }
}

// --- Обработка кликов в списке клиентов (делегирование) ---
// Вызывается слушателем, добавленным в renderClientsTab
function handleClientListActions(e) {
    const targetButton = e.target.closest('button'); // Ищем ближайшую кнопку
    if (!targetButton) return; // Клик не по кнопке

    const clientId = targetButton.dataset.clientId; // ID клиента из data-атрибута

    // Определяем действие по классу кнопки
    if (targetButton.classList.contains('edit-client-btn')) {
        console.log(`[Action] Edit client button clicked for ID: ${clientId}`);
        try {
             // Извлекаем данные клиента из data-атрибута кнопки Редактировать
             const clientData = JSON.parse(targetButton.dataset.clientJson);
             openClientModal(clientData); // Открываем модалку для редактирования
        } catch (err) {
             console.error("Error parsing client data for edit:", err);
             // Пытаемся найти в кэше как запасной вариант
              const clientToEdit = companyClients.find(c => c.id == clientId);
              if (clientToEdit) {
                  openClientModal(clientToEdit);
              } else {
                  alert("Ошибка: Не удалось прочитать данные клиента для редактирования.");
              }
        }
    }
    else if (targetButton.classList.contains('delete-client-btn')) {
        console.log(`[Action] Delete client button clicked for ID: ${clientId}`);
        const clientName = targetButton.dataset.clientName;
        // Запрашиваем подтверждение
        if (confirm(`Удалить клиента "${clientName}"?\n\nВНИМАНИЕ: Это действие необратимо! Заказы клиента останутся в системе, но будут отвязаны.`)) {
            handleDeleteClient(clientId, clientName); // Вызываем функцию удаления
        }
    }
     else if (targetButton.classList.contains('lk-link-client-btn')) {
        console.log(`[Action] LK link button clicked for ID: ${clientId}`);
        handleGenerateLkLink(clientId); // Вызываем функцию генерации ссылки ЛК
    }
}

// --- Функция удаления клиента ---
async function handleDeleteClient(clientId, clientName) {
    console.log(`[Delete] handleDeleteClient: Start deleting ID ${clientId} (${clientName})`);
    showLoader();
    try {
        // Отправляем DELETE запрос на бэкенд
        await apiFetch(`/api/clients/${clientId}`, { method: 'DELETE' });
        console.log(`[Delete] handleDeleteClient: Client ID ${clientId} deleted successfully.`);
        alert(`Клиент "${clientName}" успешно удален.`);
        await fetchAndRenderClients(); // Обновляем список клиентов
    } catch (err) { // Обработка ошибок от apiFetch (включая 400, если есть активные заказы)
        console.error("[Delete] handleDeleteClient: Error", err);
        alert(`Ошибка удаления клиента "${clientName}": ${err.message}`);
    } finally {
        hideLoader(); // Скрываем лоадер
        console.log("[Delete] handleDeleteClient: End");
    }
}

// --- Функция генерации и показа ссылки на ЛК ---
async function handleGenerateLkLink(clientId) {
     console.log(`[Action] handleGenerateLkLink: Start for Client ID ${clientId}`);
     showLoader();
     try {
         // Отправляем POST запрос (как указано в main.py)
         const response = await apiFetch(`/api/clients/${clientId}/generate_lk_link`, { method: 'POST' });
         console.log(`[Action] handleGenerateLkLink: Received link: ${response.link}`);
         // Показываем ссылку в prompt для удобного копирования
         // prompt() может блокировать интерфейс, можно заменить на показ в модальном окне или просто копирование в буфер
         prompt(`Ссылка на Личный Кабинет клиента (Нажмите Ctrl+C / Cmd+C для копирования):`, response.link);
         // navigator.clipboard.writeText(response.link).then(() => alert("Ссылка скопирована в буфер обмена!"), () => alert("Не удалось скопировать ссылку.")); // Вариант с копированием
     } catch (err) { // Обработка ошибок от apiFetch
         console.error("[Action] handleGenerateLkLink: Error", err);
         alert(`Ошибка генерации ссылки на Личный Кабинет: ${err.message}`);
     } finally {
         hideLoader(); // Скрываем лоадер
         console.log(`[Action] handleGenerateLkLink: End for Client ID ${clientId}`);
     }
 }

// --- Функция отвязки Telegram ID ---
async function handleUnlinkTelegram(clientId) {
     if (!clientId) return;
     console.log(`[Action] handleUnlinkTelegram: Start for Client ID ${clientId}`);
     if (confirm("Вы уверены, что хотите отвязать Telegram аккаунт этого клиента?\nОн сможет привязать его снова через бота.")) {
          showLoader();
          try {
               // Отправляем PATCH запрос, устанавливая telegram_chat_id в null
               await apiFetch(`/api/clients/${clientId}`, {
                    method: 'PATCH',
                    body: JSON.stringify({ telegram_chat_id: null })
               });
               console.log(`[Action] handleUnlinkTelegram: Success for Client ID ${clientId}`);
               alert("Telegram аккаунт успешно отвязан.");
               closeModal('client-modal'); // Закрываем модалку
               await fetchAndRenderClients(); // Обновляем список
          } catch (err) {
               console.error("[Action] handleUnlinkTelegram: Error", err);
               alert(`Ошибка отвязки Telegram: ${err.message}`);
          } finally {
               hideLoader();
          }
     }
}


// --- Функция поиска клиентов (фильтрует отображение списка) ---
function handleClientsSearch(e) {
    const searchTerm = e.target.value.toLowerCase().trim(); // Получаем поисковый запрос
    console.log(`[Search] handleClientsSearch: Term = "${searchTerm}"`);
    const clientItems = document.querySelectorAll('#clients-list .client-list-item'); // Находим все элементы списка

    clientItems.forEach(item => {
        // Извлекаем данные для поиска из data-атрибутов элемента
        const name = item.dataset.clientName?.toLowerCase() || '';
        const phone = item.dataset.clientPhone?.toLowerCase() || '';
        const code = item.dataset.clientCode?.toLowerCase() || '';

        // Проверяем, содержит ли хотя бы одно поле поисковый запрос
        const isMatch = name.includes(searchTerm) ||
                        phone.includes(searchTerm) ||
                        code.includes(searchTerm);

        // Показываем или скрываем элемент в зависимости от результата поиска
        item.style.display = isMatch ? 'flex' : 'none'; // Используем 'flex', так как в CSS используется flexbox
    });
    console.log(`[Search] handleClientsSearch: Filtering complete.`);
}


// --- Обработка импорта клиентов из Excel ---
// Вызывается слушателем, добавленным в initializeGlobalEventListeners
async function handleClientExcelImport() {
    console.log("[Import] handleClientExcelImport: Start");
    const fileInput = document.getElementById('client-excel-input');
    const resultsDiv = document.getElementById('client-import-results');
    if (!resultsDiv) return console.error("!!! Import Error: resultsDiv #client-import-results not found!");

    resultsDiv.innerHTML = '<p class="text-blue-600 animate-pulse">Обработка файла...</p>';

    // Проверяем, выбран ли файл
    if (!fileInput || fileInput.files.length === 0) {
        resultsDiv.innerHTML = '<p class="text-red-500">Ошибка: Выберите Excel-файл.</p>';
        return;
    }
    const file = fileInput.files[0];
    console.log(`[Import] Selected file: ${file.name}, size: ${file.size} bytes`);
    showLoader(); // Показываем глобальный лоадер

    try {
        // --- Шаг 1: Чтение данных из Excel файла ---
        console.log("[Import] Reading Excel file...");
        const jsonData = await readExcelFile(file); // Используем утилиту
        console.log(`[Import] Excel read successfully. Found ${jsonData.length} rows.`);

        if (jsonData.length === 0) {
            resultsDiv.innerHTML = '<p class="text-yellow-600">Файл пуст или не содержит данных на первом листе.</p>';
            return; // Выходим, если данных нет
        }

        // --- Шаг 2: Проверка колонок (ИЗМЕНЕНО) ---
        const firstRow = jsonData[0];
        // Теперь проверяем ТОЛЬКО наличие 'track_code'
        if (!firstRow || !firstRow.hasOwnProperty('track_code')) {
            resultsDiv.innerHTML = '<p class="text-red-500">Ошибка: Файл должен содержать как минимум колонку <strong>track_code</strong>.</p>';
            hideLoader(); return;
        }
        console.log("[Import] Required columns found.");

        // --- Шаг 3: Подготовка данных для отправки ---
        resultsDiv.innerHTML = `<p class="text-blue-600">Подготовка ${jsonData.length} записей для отправки...</p>`;
        const dataToSend = jsonData.map(row => ({
            // Преобразуем к строке, удаляем пробелы, берем null если поле отсутствует
            full_name: String(row.full_name || '').trim() || null,
            phone: String(row.phone || '').trim() || null,
            // client_code передаем как есть (строкой), бэкенд разберет
            client_code: row.client_code ? String(row.client_code).trim() : null
        })).filter(item => item.full_name && item.phone); // Отфильтровываем строки без имени или телефона

        if (dataToSend.length === 0) {
             console.warn("[Import] No valid rows found after filtering.");
             resultsDiv.innerHTML = '<p class="text-yellow-600">Не найдено корректных строк с ФИО и телефоном для импорта.</p>';
             return;
        }
        console.log(`[Import] Prepared ${dataToSend.length} valid records for sending.`);

        // --- Шаг 4: Отправка данных на БЭКЕНД ---
        resultsDiv.innerHTML = `<p class="text-blue-600 animate-pulse">Отправка ${dataToSend.length} записей на сервер... Это может занять некоторое время.</p>`;
        const response = await apiFetch('/api/clients/bulk_import', {
            method: 'POST',
            body: JSON.stringify(dataToSend) // Отправляем массив объектов
        });
        console.log("[Import] Server response:", response);

        // --- Шаг 5: Отображение результата ---
        let resultHtml = `<p class="text-green-600 font-semibold"><strong>Импорт завершен! Успешно создано: ${response.created_clients || 0}</strong></p>`;
        // Добавляем предупреждения (например, о дубликатах)
        if (response.warnings && response.warnings.length > 0) {
             resultHtml += `<p class="text-yellow-600 mt-2 font-semibold"><strong>Предупреждения (${response.warnings.length}):</strong></p><ul class="list-disc list-inside text-xs">${response.warnings.map(w => `<li>${w}</li>`).join('')}</ul>`;
        }
        // Добавляем ошибки (например, невалидные данные)
        if (response.errors && response.errors.length > 0) {
            resultHtml += `<p class="text-red-600 mt-2 font-semibold"><strong>Ошибки (${response.errors.length}):</strong></p><ul class="list-disc list-inside text-xs">${response.errors.map(er => `<li>${er}</li>`).join('')}</ul>`;
        }
        resultsDiv.innerHTML = resultHtml; // Показываем результат в модальном окне

        // --- Шаг 6: Обновление списка клиентов на основной вкладке ---
        if (response.created_clients > 0) {
             console.log("[Import] Refreshing client list...");
             await fetchAndRenderClients(); // Перезагружаем список
        }

    } catch (error) { // Обработка ошибок чтения файла или запроса к API
        console.error("!!! [Import] handleClientExcelImport: CRITICAL ERROR", error);
        resultsDiv.innerHTML = `<p class="text-red-500"><b>Критическая ошибка импорта:</b> ${error.message}</p>`;
    } finally {
        hideLoader(); // Прячем общий лоадер
        if (fileInput) fileInput.value = ''; // Сбрасываем выбор файла в любом случае
        console.log("[Import] handleClientExcelImport: End");
    }
}

// === КОНЕЦ МОДУЛЯ КЛИЕНТЫ ===

// =================================================================
// МОДУЛЬ: ЗАКАЗЫ (Владелец) (v4.1 - Rebuild - Полная версия)
// =================================================================

companyOrders = []; // Кэш для заказов компании (обновляется при загрузке/фильтрации)
// let orderStatuses = ["В обработке", ...]; // Уже определен глобально
// let availablePartyDates = []; // Уже определен глобально

// --- Рендеринг основной вкладки Заказов ---
// index.html (ПОЛНОСТЬЮ ЗАМЕНЯЕТ renderOrdersTab)

async function renderOrdersTab() {
    console.log("[Render] renderOrdersTab: Start");
    const pane = document.getElementById('tab-orders');
    if (!pane) {
        console.warn("[Render] renderOrdersTab: Pane #tab-orders not found.");
        return;
    }

    // Загружаем статусы, даты партий И ФИЛИАЛЫ ПЕРЕД рендерингом HTML
    try {
        console.log("[Render] renderOrdersTab: Preloading party dates and locations...");
        // Используем Promise.allSettled для надежности
        const results = await Promise.allSettled([
            Promise.resolve(orderStatuses), // Статусы из глоб. переменной
            // Загружаем даты партий, если кэш пуст
            (!availablePartyDates || availablePartyDates.length === 0) ? apiFetch('/api/orders/parties') : Promise.resolve(availablePartyDates),
            // Загружаем филиалы, если кэш пуст (нужны для фильтра)
            (!companyLocations || companyLocations.length === 0) ? apiFetch('/api/locations') : Promise.resolve(companyLocations)
        ]);

        if (results[0].status === 'fulfilled') orderStatuses = results[0].value;
        if (results[1].status === 'fulfilled') availablePartyDates = results[1].value; else console.warn("[Render] renderOrdersTab: Failed to preload party dates:", results[1].reason);
        if (results[2].status === 'fulfilled') companyLocations = results[2].value; else console.warn("[Render] renderOrdersTab: Failed to preload locations:", results[2].reason);

        console.log("[Render] renderOrdersTab: Data loaded/updated.");
    } catch (e) {
        console.error("[Render] renderOrdersTab: Error preloading data:", e);
        // Не прерываем рендеринг, но фильтр филиалов может быть недоступен
    }

    // --- Генерируем HTML для фильтра филиалов (только для Владельца) ---
    let locationFilterHtml = '';
    // Показываем, если Владелец И филиалов БОЛЬШЕ одного
    if (currentUser.role === 'Владелец' && companyLocations && companyLocations.length > 1) {
        const locationOptions = companyLocations.map(loc =>
            `<option value="${loc.id}">${loc.name}</option>`
        ).join('');
        
        locationFilterHtml = `
            <div class="p-2 bg-gray-100 rounded-md shadow-sm relative">
                <label for="orders-location-filter" class="text-xs font-medium text-gray-700 mr-2">Филиал:</label>
                <select id="orders-location-filter" class="rounded-md border-gray-300 p-1.5 text-xs bg-white shadow-sm w-36"> {/* Задаем ширину */}
                    <option value="">-- Все филиалы --</option> 
                    ${locationOptions}
                </select>
            </div>
        `;
        console.log("[Render] renderOrdersTab: Location filter HTML generated.");
    } else {
         console.log("[Render] renderOrdersTab: Location filter not needed or not enough locations.");
    }
    // --- КОНЕЦ ГЕНЕРАЦИИ ФИЛЬТРА ФИЛИАЛОВ ---

// Генерируем основной HTML для вкладки
pane.innerHTML = `
    <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">

        <div class="lg:col-span-1 space-y-6">

            <div class="bg-white p-6 rounded-lg shadow-md h-fit border">
                <h2 class="text-xl font-semibold mb-4 text-gray-800">Добавить заказ</h2>
                <form id="add-order-form" class="space-y-4">
                    <div class="relative">
                        <label for="order-client-search-input" class="block text-sm font-medium text-gray-700">Клиент (поиск)</label>
                        <input type="text" id="order-client-search-input" autocomplete="off" placeholder="Имя, телефон или код..." class="mt-1 w-full p-2 border rounded focus:ring-indigo-500 focus:border-indigo-500">
                        <input type="hidden" id="order-selected-client-id">
                        <div id="order-client-search-results" class="absolute hidden top-full left-0 right-0 bg-white border mt-1 rounded-md shadow-lg z-20 max-h-48 overflow-y-auto"></div>
                    </div>
                    <div> <label for="order-track-code" class="block text-sm font-medium text-gray-700">Трек-код</label> <input type="text" id="order-track-code" class="mt-1 w-full p-2 border rounded focus:ring-indigo-500 focus:border-indigo-500" placeholder="Обязательно для Доставки"> </div>
                    <div> <label for="order-party-date" class="block text-sm font-medium text-gray-700">Дата Партии</label> <input type="date" id="order-party-date" class="mt-1 w-full p-2 border rounded focus:ring-indigo-500 focus:border-indigo-500"> </div>
                    <div> <label for="order-purchase-type" class="block text-sm font-medium text-gray-700">Тип заказа</label> <select id="order-purchase-type" required class="mt-1 w-full p-2 border rounded bg-white focus:ring-indigo-500 focus:border-indigo-500"> <option value="Доставка" selected>Доставка</option> <option value="Выкуп">Выкуп</option> </select> </div>
                    ${currentUser.role === 'Владелец' && companyLocations.length > 0 ? `
                    <div>
                        <label for="order-location-select" class="block text-sm font-medium text-gray-700">Филиал *</label>
                        <select id="order-location-select" class="mt-1 w-full p-2 border rounded bg-white focus:ring-indigo-500 focus:border-indigo-500">
                            ${companyLocations.map(loc => `<option value="${loc.id}" ${loc.id === currentUser.location_id ? 'selected' : ''}>${loc.name}</option>`).join('')}
                        </select>
                        <p class="text-xs text-gray-500 mt-1">Выберите филиал, к которому относится заказ.</p>
                    </div>
                    ` : ''}
                    <div id="order-buyout-fields" class="hidden space-y-3 border-t pt-4 mt-4"> <h4 class="text-sm font-semibold text-gray-600">Данные для выкупа:</h4> <div> <label for="order-buyout-cost" class="block text-xs font-medium text-gray-600">Стоимость товара (CNY)</label> <input type="number" step="any" id="order-buyout-cost" class="mt-1 w-full p-2 border rounded text-sm"> </div> <div> <label for="order-buyout-rate" class="block text-xs font-medium text-gray-600">Курс для клиента (сом/юань)</label> <input type="number" step="any" id="order-buyout-rate" class="mt-1 w-full p-2 border rounded text-sm"> </div> <div> <label for="order-buyout-commission" class="block text-xs font-medium text-gray-600">Комиссия (%)</label> <input type="number" step="1" id="order-buyout-commission" value="10" class="mt-1 w-full p-2 border rounded text-sm"> </div> </div>
                    <div> <label for="order-comment" class="block text-sm font-medium text-gray-700">Комментарий</label> <textarea id="order-comment" class="mt-1 w-full p-2 border rounded h-16 focus:ring-indigo-500 focus:border-indigo-500" placeholder="Цвет, размер, особенности..."></textarea> </div>
                    <button type="submit" class="w-full bg-green-600 text-white font-bold py-2 rounded hover:bg-green-700 transition-colors duration-150">Создать Заказ</button>
                </form>
            </div>
            <div class="bg-white p-6 rounded-lg shadow-md h-fit border">
                <h2 class="text-xl font-semibold mb-4 text-gray-800">Импорт заказов из Excel</h2>
                <p class="text-xs text-gray-600 mb-1">Колонки: <strong>track_code</strong>* (и <strong>client_code</strong> или <strong>phone</strong>, если нужно привязать).</p>
                <p class="text-xs text-gray-600 mb-4">Необязательно: <strong>comment</strong>, <strong>purchase_type</strong>, <strong>buyout_item_cost_cny</strong>, <strong>buyout_rate_for_client</strong>, <strong>buyout_commission_percent</strong>.</p>
                <div class="space-y-3 mb-4"> <label for="import-order-party-date" class="block text-sm font-medium text-gray-700">Общая Дата партии (если нет в файле)</label> <input type="date" id="import-order-party-date" class="mt-1 w-full p-2 border rounded"> </div>
                ${currentUser.role === 'Владелец' && companyLocations.length > 0 ? `
                <div class="space-y-3 mb-4">
                    <label for="import-location-select" class="block text-sm font-medium text-gray-700">Импортировать в филиал *</label>
                    <select id="import-location-select" class="mt-1 w-full p-2 border rounded bg-white focus:ring-indigo-500 focus:border-indigo-500">
                        ${companyLocations.map(loc => `<option value="${loc.id}" ${loc.id === currentUser.location_id ? 'selected' : ''}>${loc.name}</option>`).join('')}
                    </select>
                </div>
                ` : ''}
                <label for="order-excel-input" class="block text-sm font-medium text-gray-700 mb-2">Выберите файл (.xlsx, .xls)</label> 
                <input type="file" id="order-excel-input" accept=".xlsx, .xls" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100 cursor-pointer"/> 
                <button id="import-orders-btn" class="mt-4 w-full bg-blue-600 text-white font-bold py-2 rounded-lg hover:bg-blue-700 transition-colors duration-150">Импортировать Заказы</button> 
                <div id="order-import-results" class="mt-4 text-xs max-h-40 overflow-y-auto border p-2 bg-gray-50 rounded"></div>
            </div>
            </div>
        <div class="lg:col-span-2 bg-white p-6 rounded-lg shadow-md border">

            <div id="orders-action-header" class="sticky top-0 bg-white py-3 mb-4 border-b -mx-6 px-6 flex flex-wrap justify-between items-center gap-2 z-10">

                     <div class="flex items-center gap-2 flex-wrap">
                        
                        <button id="orders-toggle-select-mode-btn" class="px-3 py-2 bg-gray-100 rounded-md shadow-sm font-bold text-indigo-600 hover:bg-indigo-100 text-sm transition-colors duration-150" title="Включить/выключить режим выбора заказов">✅ Выбрать</button>
                        
                        <div class="relative"> <button id="orders-toggle-party-filter-btn" class="px-3 py-2 bg-gray-100 rounded-md shadow-sm font-bold text-indigo-600 hover:bg-indigo-100 text-sm transition-colors duration-150">🗳️ Партии</button> <div id="orders-party-filter-container" class="hidden absolute top-full mt-2 bg-white border rounded-lg shadow-lg p-3 w-60 z-30"> <p class="font-semibold mb-2 text-sm text-gray-700">Фильтр по партиям:</p> <div id="orders-party-list" class="space-y-1 max-h-60 overflow-y-auto mb-2 text-sm">Загрузка...</div> <div class="flex gap-2"> <button id="orders-apply-party-filter" class="flex-1 bg-indigo-600 text-white text-xs py-1.5 rounded hover:bg-indigo-700">Применить</button> <button id="orders-reset-party-filter" class="flex-1 bg-gray-300 text-black text-xs py-1.5 rounded hover:bg-gray-400">Сброс</button> </div> </div> </div>
                        
                        <div class="relative"> <button id="orders-toggle-status-filter-btn" class="px-3 py-2 bg-gray-100 rounded-md shadow-sm font-bold text-indigo-600 hover:bg-indigo-100 text-sm transition-colors duration-150">🟢 Статусы</button> <div id="orders-status-filter-container" class="hidden absolute top-full mt-2 bg-white border rounded-lg shadow-lg p-3 w-60 z-30"> <p class="font-semibold mb-2 text-sm text-gray-700">Фильтр по статусам:</p> <div id="orders-status-list" class="space-y-1 max-h-60 overflow-y-auto mb-2 text-sm">Загрузка...</div> <div class="flex gap-2"> <button id="orders-apply-status-filter" class="flex-1 bg-indigo-600 text-white text-xs py-1.5 rounded hover:bg-indigo-700">Применить</button> <button id="orders-reset-status-filter" class="flex-1 bg-gray-300 text-black text-xs py-1.5 rounded hover:bg-gray-400">Сброс</button> </div> </div> </div>
                        
                        ${locationFilterHtml} 
                        
                        
                        <button id="orders-export-btn" class="px-3 py-2 bg-gray-100 rounded-md shadow-sm font-bold text-green-600 hover:bg-green-100 text-sm transition-colors duration-150" title="Экспортировать отфильтрованные заказы в Excel">📥 Экспорт</button>

                    <button id="orders-calculate-btn" class="px-3 py-2 bg-gray-100 rounded-md shadow-sm font-bold text-blue-600 hover:bg-blue-100 text-sm transition-colors duration-150" title="Открыть окно расчета стоимости для выбранного клиента">🧮 Рассчитать</button>
                    <button id="orders-filter-unclaimed-btn" class="px-3 py-2 bg-gray-100 rounded-md shadow-sm font-bold text-red-600 hover:bg-red-100 text-sm transition-colors duration-150" title="Показать только невостребованные заказы (без клиента)">🚩 Невостребованные</button>
                </div>

                <button id="refresh-orders-btn" title="Обновить список заказов" class="text-2xl text-gray-500 hover:text-indigo-600 transition-colors duration-150">&circlearrowright;</button>
            </div>

            <div class="mb-4"> <input type="search" id="orders-search-input" placeholder="🔍 Поиск по клиенту, телефону, трек-коду, комментарию..." class="w-full p-2 border rounded-lg focus:ring-indigo-500 focus:border-indigo-500"> </div>

            <div id="orders-bulk-action-bar" class="hidden p-3 bg-indigo-50 rounded-lg mb-4 border border-indigo-200 space-y-3">
                <div class="flex items-center gap-4 flex-wrap"> 
                    <span id="orders-selected-count" class="font-bold text-indigo-700 text-sm">Выбрано: 0</span> 
                    <div class="flex items-center gap-2 border-l border-indigo-200 pl-3"> <label for="orders-bulk-status-select" class="text-xs font-medium text-gray-700">Статус:</label> <select id="orders-bulk-status-select" class="rounded-md border-gray-300 p-1.5 text-xs bg-white shadow-sm"></select> <button id="orders-bulk-update-status-btn" class="bg-indigo-600 text-white font-bold py-1.5 px-3 rounded-lg text-xs hover:bg-indigo-700">Применить</button> </div> 
                    <div class="flex items-center gap-2 border-l border-indigo-200 pl-3"> <label for="orders-bulk-party-date-input" class="text-xs font-medium text-gray-700">Дата:</label> <input type="date" id="orders-bulk-party-date-input" class="p-1.5 border rounded text-xs bg-white shadow-sm"> <button id="orders-bulk-update-date-btn" class="bg-orange-500 text-white font-bold py-1.5 px-3 rounded-lg text-xs hover:bg-orange-600">Применить</button> </div> 
                    <button id="orders-bulk-buyout-btn" class="hidden bg-purple-600 text-white font-bold py-1.5 px-3 rounded-lg text-xs hover:bg-purple-700">Выкупить отмеченное</button> 
                    <button id="orders-bulk-assign-client-btn" class="bg-teal-600 text-white font-bold py-1.5 px-3 rounded-lg text-xs hover:bg-teal-700">👤 Назначить клиента</button> 
                </div>
                <div class="border-t border-indigo-200 pt-2"> <button id="orders-bulk-delete-btn" class="bg-red-600 text-white font-bold py-1.5 px-3 rounded-lg text-xs hover:bg-red-700">Удалить выбранное</button> </div>
            </div>

            <div id="orders-select-all-container" class="hidden flex items-center p-2 border-b"> <input type="checkbox" id="orders-select-all-checkbox" class="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500"> <label for="orders-select-all-checkbox" class="ml-3 block text-sm font-bold text-gray-700">Выбрать все видимые заказы</label> </div>

            <div id="orders-list-container" class="space-y-4 mt-4"> <p class="text-gray-500 animate-pulse">Загрузка заказов...</p> </div>
        </div>
        </div>
`;

    // --- Добавляем слушатели к элементам ---
    console.log("[Render] renderOrdersTab: Adding listeners...");
    // (Используем replaceAndListen для всех, чтобы избежать дублирования при перерисовке)
    const replaceAndListen = (id, event, handler) => {
        const element = document.getElementById(id);
        if (element) {
            const newElement = element.cloneNode(true);
            element.parentNode?.replaceChild(newElement, element);
            newElement.addEventListener(event, handler);
            console.log(`[Listener OK] Added ${event} to #${id}`);
        } else {
             console.warn(`!!! renderOrdersTab: Element #${id} NOT FOUND during listener attachment.`);
        }
    };

    // Форма добавления
    replaceAndListen('add-order-form', 'submit', handleAddOrderSubmit);
    replaceAndListen('order-client-search-input', 'input', handleOrderClientSearch);
    replaceAndListen('order-purchase-type', 'change', toggleOrderBuyoutFields);
    const today = new Date().toISOString().split('T')[0]; 
    const partyDateInputAdd = document.getElementById('order-party-date');
    if (partyDateInputAdd) partyDateInputAdd.value = today;

    // Форма импорта
    replaceAndListen('import-orders-btn', 'click', handleOrderExcelImport);

    // Панель действий и фильтров
    replaceAndListen('refresh-orders-btn', 'click', fetchAndRenderOrders);
    replaceAndListen('orders-toggle-select-mode-btn', 'click', toggleOrdersSelectMode);
    replaceAndListen('orders-toggle-party-filter-btn', 'click', toggleOrdersPartyFilter);
    replaceAndListen('orders-toggle-status-filter-btn', 'click', toggleOrdersStatusFilter);
    replaceAndListen('orders-apply-party-filter', 'click', applyOrdersFiltersAndFetch);
    replaceAndListen('orders-reset-party-filter', 'click', resetOrdersPartyFilter);
    replaceAndListen('orders-apply-status-filter', 'click', applyOrdersFiltersAndFetch);
    replaceAndListen('orders-reset-status-filter', 'click', resetOrdersStatusFilter);
    replaceAndListen('orders-export-btn', 'click', handleExportOrders);
    replaceAndListen('orders-calculate-btn', 'click', openCalculateModal);
    replaceAndListen('orders-location-filter', 'change', fetchAndRenderOrders);
    // replaceAndListen('orders-filter-unclaimed-btn', 'click', handleFilterUnclaimed); удалено
    setupUnclaimedFilterButton();
    setupAssignClientButton();

    // Поиск
    replaceAndListen('orders-search-input', 'input', handleOrdersSearch);

    // Массовые действия
    replaceAndListen('orders-select-all-checkbox', 'change', handleOrdersSelectAll);
    replaceAndListen('orders-bulk-update-status-btn', 'click', handleBulkUpdateStatus);
    replaceAndListen('orders-bulk-update-date-btn', 'click', handleBulkUpdatePartyDate);
    replaceAndListen('orders-bulk-delete-btn', 'click', handleBulkDeleteOrders);
    replaceAndListen('orders-bulk-buyout-btn', 'click', openBuyoutModal); 

    // Список заказов (делегирование)
    const listContainer = document.getElementById('orders-list-container');
    if (listContainer) {
         const newListContainer = listContainer.cloneNode(false);
         listContainer.parentNode?.replaceChild(newListContainer, listContainer);
         newListContainer.innerHTML = '<p class="text-gray-500 animate-pulse">Загрузка заказов...</p>';
         newListContainer.addEventListener('change', handleOrderCheckboxChange); // Чекбоксы
         newListContainer.addEventListener('click', handleOrderListClick);      // Кнопки Редакт.
         console.log("[Listener OK] Added change & click delegate listeners to #orders-list-container");
    } else {
         console.error("!!! renderOrdersTab: Element #orders-list-container NOT FOUND.");
    }

    // --- Инициализация фильтров и загрузка данных ---
    populateStatusFilter(); 
    populatePartyFilter(); 
    await fetchAndRenderOrders(); // Загружаем заказы с учетом нового фильтра
    console.log("[Render] renderOrdersTab: End");
}





// Рендерит HTML для ОДНОГО заказа в списке (без обертки клиента)
function renderOrderListItem(order) {
    // Проверка на случай отсутствия данных клиента (маловероятно после группировки)
    const client = order.client || { full_name: '?', phone: '?', client_code_prefix: '', client_code_num: '?' };
    const clientCode = `${client.client_code_prefix || ''}${client.client_code_num || '?'}`;
    const statusColor = getStatusColor(order.status); // Получаем цвет для статуса

    // Data-атрибуты для поиска по этому конкретному заказу
    const itemSearchData = `
         data-track="${order.track_code?.toLowerCase() || ''}"
         data-client-name="${client.full_name?.toLowerCase() || ''}"
         data-client-phone="${client.phone || ''}"
         data-client-code="${clientCode.toLowerCase()}"
         data-comment="${(order.comment || '').toLowerCase()}"
     `;

    // Генерируем HTML самого заказа
    return `
        <div class="order-list-item border rounded-lg p-3 hover:bg-gray-50 transition-colors duration-100 shadow-sm" ${itemSearchData}>
            <div class="flex flex-wrap justify-between items-start gap-2 mb-2">
                 <div class="flex items-center gap-3">
                      <input type="checkbox" data-order-id="${order.id}" class="order-checkbox hidden h-5 w-5 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500">
                      <div>
                           <span class="font-bold text-md text-gray-800 break-all">${order.track_code || 'N/A'}</span>
                           <span class="ml-2 px-2 py-0.5 rounded-full text-xs font-semibold ${statusColor}">${order.status || '?'}</span>
                      </div>
                 </div>
                 ${order.party_date ? `<span class="text-xs text-gray-500 font-medium">${order.party_date}</span>` : ''}
            </div>

            <div class="text-xs text-gray-700 space-y-1 pl-8">
                ${order.comment ? `<p><strong class="font-medium">Коммент:</strong> ${order.comment}</p>` : ''}
                ${order.purchase_type === 'Выкуп' ? `
                    <p class="text-purple-700"><strong class="font-medium">Выкуп:</strong> ${order.buyout_item_cost_cny || '?'} CNY | Курс(К): ${order.buyout_rate_for_client || '?'} | Ком: ${order.buyout_commission_percent}% ${order.buyout_actual_rate ? `| Курс(Р): ${order.buyout_actual_rate}` : ''}</p>
                ` : ''}
                ${order.calculated_final_cost_som ? `<p class="text-blue-700 font-semibold"><strong class="font-medium">Расчет:</strong> ${order.calculated_final_cost_som.toFixed(0)} сом (${order.calculated_weight_kg || '?'} кг @ ${order.calculated_price_per_kg_usd || '?'} USD, ${order.calculated_exchange_rate_usd || '?'} сом/USD)</p>` : ''}
                 ${order.status === 'Выдан' && order.issued_at ? `<p class="text-green-700 font-bold"><strong class="font-medium">Выдан (${new Date(order.issued_at).toLocaleDateString()}):</strong> ${order.final_cost_som?.toFixed(0) || '?'} сом (${order.weight_kg || '?'} кг)</p>` : ''}
            </div>

             <div class="mt-2 flex justify-end">
                <button data-order-id="${order.id}" class="edit-order-btn text-xs bg-gray-200 hover:bg-gray-300 text-gray-800 px-2 py-1 rounded transition-colors duration-150">Редактировать</button>
             </div>
        </div>
    `;
}

// --- Вспомогательная функция для получения CSS классов цвета статуса ---
// Возвращает строку с Tailwind CSS классами для фона и текста
function getStatusColor(status) {
    switch (status) {
        case 'В обработке':
            return 'bg-gray-100 text-gray-800'; // Серый
        case 'Ожидает выкупа':
            return 'bg-yellow-100 text-yellow-800'; // Желтый
        case 'Выкуплен':
            return 'bg-purple-100 text-purple-800'; // Фиолетовый
        case 'На складе в Китае':
            return 'bg-orange-100 text-orange-800'; // Оранжевый
        case 'В пути':
            return 'bg-blue-100 text-blue-800'; // Синий
        case 'На складе в КР':
            return 'bg-teal-100 text-teal-800'; // Бирюзовый
        case 'Готов к выдаче':
            return 'bg-lime-100 text-lime-800'; // Лаймовый
        case 'Выдан':
            return 'bg-green-100 text-green-800'; // Зеленый
        default: // Для неизвестных статусов
            return 'bg-gray-100 text-gray-800';
    }
}


// --- Функции для формы Добавления Заказа ---

// Поиск клиента при добавлении заказа (с debounce)
function handleOrderClientSearch(e) {
    const input = e.target; // Поле ввода, куда печатает пользователь
    const resultsDiv = document.getElementById('order-client-search-results'); // Div для показа результатов
    const selectedClientIdInput = document.getElementById('order-selected-client-id'); // Скрытое поле для ID
    const searchTerm = input.value; // Текст, введенный пользователем

    // Если поле поиска пустое или слишком короткое, скрываем результаты и сбрасываем ID
    if (!searchTerm || searchTerm.length < 1) { // Ищем хотя бы от 1 символа
        if(resultsDiv) resultsDiv.innerHTML = '';
        if(resultsDiv) resultsDiv.classList.add('hidden');
        if(selectedClientIdInput) selectedClientIdInput.value = ''; // Сбрасываем ID выбранного клиента
        return; // Выходим из функции
    }

    // --- Механизм "Debounce" ---
    // Очищаем предыдущий таймер, если пользователь продолжает печатать
    clearTimeout(input.debounceTimer);
    // Устанавливаем новый таймер: выполнить поиск через 300 мс после последней нажатой клавиши
    input.debounceTimer = setTimeout(async () => {
        console.log(`[Client Search] Searching for: "${searchTerm}"`);
        if(!resultsDiv || !selectedClientIdInput) return; // Доп. проверка

        resultsDiv.innerHTML = '<div class="p-2 text-sm text-gray-500 animate-pulse">Поиск...</div>'; // Показываем индикатор поиска
        resultsDiv.classList.remove('hidden'); // Показываем контейнер результатов

        try {
            // Выполняем запрос к API для поиска клиентов
            const clients = await apiFetch(`/api/clients/search?q=${encodeURIComponent(searchTerm)}`);
            console.log(`[Client Search] Found ${clients.length} clients.`);

            if (clients.length > 0) {
                // Если клиенты найдены, генерируем HTML для списка результатов
                 resultsDiv.innerHTML = clients.map(c => `
                    <div class="p-2 hover:bg-gray-100 cursor-pointer text-sm search-result-item"
                         data-client-id="${c.id}"
                         data-client-name="${c.full_name} (${c.client_code_prefix || ''}${c.client_code_num || 'Нет кода'})">
                        ${c.full_name} (${c.client_code_prefix || ''}${c.client_code_num || 'Нет кода'}) - ${c.phone}
                    </div>
                 `).join('');

                 // Добавляем обработчики клика на каждый элемент результата
                 resultsDiv.querySelectorAll('.search-result-item').forEach(item => {
                     item.addEventListener('click', () => {
                         const clientId = item.dataset.clientId;
                         const clientName = item.dataset.clientName;
                         console.log(`[Client Search] Client selected: ID=${clientId}, Name=${clientName}`);
                         input.value = clientName; // Показываем выбранное имя в поле ввода
                         selectedClientIdInput.value = clientId; // Сохраняем ID клиента в скрытое поле
                         resultsDiv.innerHTML = ''; // Очищаем список результатов
                         resultsDiv.classList.add('hidden'); // Скрываем список результатов
                     });
                 });
            } else {
                 // Если клиенты не найдены
                 resultsDiv.innerHTML = '<div class="p-2 text-sm text-gray-500">Клиенты не найдены.</div>';
            }
        } catch (error) { // Обработка ошибок при поиске
             console.error("[Client Search] Error:", error);
             resultsDiv.innerHTML = `<div class="p-2 text-sm text-red-500">Ошибка поиска: ${error.message}</div>`;
        }
    }, 300); // Задержка debounce в 300 миллисекунд
}

// Показать/Скрыть поля Выкупа при смене типа заказа в форме добавления
function toggleOrderBuyoutFields(e) {
    const purchaseType = e.target.value; // Получаем выбранный тип ("Доставка" или "Выкуп")
    const buyoutFieldsDiv = document.getElementById('order-buyout-fields'); // Находим div с полями выкупа

    if (!buyoutFieldsDiv) return; // Выходим, если div не найден

    if (purchaseType === 'Выкуп') {
        console.log("[Add Order Form] Purchase type changed to 'Выкуп'. Showing buyout fields.");
        buyoutFieldsDiv.classList.remove('hidden'); // Показываем поля
    } else {
        console.log("[Add Order Form] Purchase type changed to 'Доставка'. Hiding buyout fields.");
        buyoutFieldsDiv.classList.add('hidden'); // Скрываем поля
    }
}

// --- НОВАЯ ФУНКЦИЯ: Рендерит список заказов ИЗ КЭША companyOrders ---
function renderOrderListFromCache() {
    console.log("[Render Cache] renderOrderListFromCache: Start");
    const listContainer = document.getElementById('orders-list-container');
    if (!listContainer) return console.error("!!! renderOrderListFromCache: listContainer #orders-list-container not found!");

    const orders = companyOrders; // Используем данные из ГЛОБАЛЬНОГО кэша

    if (!orders || orders.length === 0) {
        listContainer.innerHTML = '<p class="text-gray-500">Заказы по заданным фильтрам не найдены.</p>';
    } else {
        // --- Группировка заказов по клиенту ---
        const groupedOrders = orders.reduce((acc, order) => {
            const clientId = order.client?.id || 'unknown';
            if (!acc[clientId]) {
                acc[clientId] = { client: order.client, orders: [] };
            }
            acc[clientId].orders.push(order);
            return acc;
        }, {});
        console.log("[Render Cache] Orders grouped by client:", groupedOrders);

        // --- Рендеринг сгруппированных заказов ---
        listContainer.innerHTML = Object.values(groupedOrders).map(group => {
            group.orders.sort((a, b) => b.id - a.id); // Новые вверху
            const client = group.client || { full_name: 'Неизвестный клиент', phone: '', client_code_prefix: '', client_code_num: '' };
            const clientCode = `${client.client_code_prefix || ''}${client.client_code_num || 'Нет кода'}`;
            const ordersHtml = group.orders.map(o => renderOrderListItem(o)).join(''); // Используем старую функцию рендеринга одного элемента
            const groupSearchData = `
                data-client-name="${client.full_name?.toLowerCase() || ''}"
                data-client-phone="${client.phone || ''}"
                data-client-code="${clientCode.toLowerCase()}"
                data-tracks="${group.orders.map(o => o.track_code?.toLowerCase() || '').join(' ')}"
            `;
            return `
                <div class="client-order-group border rounded-lg overflow-hidden mb-4 shadow-sm bg-white" ${groupSearchData}>
                    <div class="bg-gray-100 p-3 flex flex-wrap justify-between items-center border-b gap-2">
                         <div>
                            <p class="font-bold text-lg text-gray-800">${client.full_name} (${clientCode})</p>
                            <p class="text-sm text-gray-600">${client.phone}</p>
                         </div>
                         <span class="text-sm font-medium text-gray-500">${group.orders.length} зак.</span>
                    </div>
                    <div class="p-4 space-y-3">
                         ${ordersHtml}
                    </div>
                </div>
            `;
        }).join('');
        console.log("[Render Cache] Grouped HTML rendered.");
    }
    hideBulkActionBar(); // Сбрасываем панель массовых действий после перерисовки
    // Обновляем поиск и чекбокс "Выбрать все", если они активны
    handleOrdersSearch({ target: document.getElementById('orders-search-input') }); // Перефильтровываем отображение
    updateSelectAllCheckboxState(); // Обновляем галочку "Выбрать все"
    console.log("[Render Cache] renderOrderListFromCache: End");
}


// --- ИЗМЕНЕННАЯ ФУНКЦИЯ: Загружает заказы с API и вызывает renderOrderListFromCache ---
async function fetchAndRenderOrders(filters = {}) {
    console.log("[Fetch] fetchAndRenderOrders: Start");
    const listContainer = document.getElementById('orders-list-container');
    if (!listContainer) return console.error("!!! fetchAndRenderOrders: listContainer #orders-list-container not found!");
    listContainer.innerHTML = '<p class="text-gray-500 animate-pulse">Загрузка заказов...</p>';
    showLoader();

    // Собираем параметры для запроса из фильтров
    const params = new URLSearchParams();

    // --- ДОБАВИТЬ ЭТОТ БЛОК ---
    // Добавляем ID компании В ЛЮБОМ СЛУЧАЕ (он обязателен на бэкенде)
    if (currentCompany && currentCompany.id) {
        params.append('company_id', currentCompany.id);
        console.log("[Fetch Orders] Добавлен company_id:", currentCompany.id);
    } else if (currentUser && !currentUser.is_super_admin) {
        // Если currentCompany не определен (маловероятно для Владельца/Сотрудника, но на всякий случай)
        console.error("!!! [Fetch Orders] ОШИБКА: Не удалось определить ID компании для запроса заказов!");
        listContainer.innerHTML = '<p class="text-red-500">Ошибка: Не удалось определить ID компании.</p>';
        hideLoader();
        return; // Прерываем выполнение
    }
    // --- КОНЕЦ ДОБАВЛЕНИЯ ---

    // Добавляем фильтры по датам
    const selectedParties = Array.from(document.querySelectorAll('#orders-party-list input:checked')).map(cb => cb.value);
    selectedParties.forEach(date => params.append('party_dates', date));

    // Добавляем фильтры по статусам
    const selectedStatuses = Array.from(document.querySelectorAll('#orders-status-list input:checked')).map(cb => cb.value);
    selectedStatuses.forEach(status => params.append('statuses', status));

    // Если фильтр по статусам пуст И это не СуперАдмин (т.е. обычный пользователь CRM)
    // то по умолчанию НЕ показываем "Выдан"
    if (selectedStatuses.length === 0 && currentUser && !currentUser.is_super_admin && orderStatuses.length > 0) {
        orderStatuses.filter(s => s !== 'Выдан').forEach(status => params.append('statuses', status));
    }

    if (filterUnclaimedOnly) {
        params.append('unclaimed_only', 'true');
    }

    // Передача выбранного location_id для Владельца
    if (currentUser.role === 'Владелец') {
        const locationFilterSelect = document.getElementById('orders-location-filter');
        if (locationFilterSelect && locationFilterSelect.value) {
            params.append('location_id', locationFilterSelect.value);
            console.log("[Fetch Orders] Filtering by location_id:", locationFilterSelect.value);
        } else {
             console.log("[Fetch Orders] Owner viewing all locations.");
        }
    }

    const url = `/api/orders?${params.toString()}`;
    console.log("[Fetch] fetchAndRenderOrders: Requesting with params:", params.toString());

    try {
        // Запрашиваем заказы
        const orders = await apiFetch(url);
        companyOrders = orders; // Обновляем кэш новыми данными с сервера
        console.log("[Fetch] fetchAndRenderOrders: Received and cached orders:", orders.length);

        // ВЫЗЫВАЕМ НОВУЮ ФУНКЦИЮ ДЛЯ РЕНДЕРИНГА ИЗ КЭША
        renderOrderListFromCache();

    } catch (e) {
        console.error("!!! [Fetch] fetchAndRenderOrders: Error", e);
        listContainer.innerHTML = `<p class="text-red-500">Ошибка загрузки списка заказов: ${e.message}</p>`;
        companyOrders = []; // Очищаем кэш при ошибке
    } finally {
        hideLoader();
        console.log("[Fetch] fetchAndRenderOrders: End");
    }
}


// --- ИЗМЕНЕННАЯ ФУНКЦИЯ: Обработчик добавления заказа ---
async function handleAddOrderSubmit(e) {
    e.preventDefault(); // Предотвращаем стандартную отправку формы
    console.log("[Add Order] handleAddOrderSubmit: Start");
    showLoader(); // Показываем индикатор загрузки

    // Получаем ID выбранного клиента из скрытого поля
    const clientId = document.getElementById('order-selected-client-id')?.value;
    // Проверяем, выбран ли клиент
    if (!clientId) {
        hideLoader(); // Прячем лоадер перед alert
        alert('Ошибка: Клиент не выбран из поиска.');
        console.warn("[Add Order] Submit failed: Client not selected.");
        return; // Прерываем выполнение функции
    }

    // Считываем значения из полей формы
    let track_code = document.getElementById('order-track-code')?.value.trim(); // Считываем трек-код и убираем пробелы
    const purchase_type = document.getElementById('order-purchase-type')?.value; // Получаем тип заказа
    const party_date = document.getElementById('order-party-date')?.value || null; // Дата партии (или null, если не выбрана)
    const comment = document.getElementById('order-comment')?.value.trim() || null; // Комментарий (или null, если пустой)

    // Генерируем временный трек-код, если поле пустое И тип заказа "Выкуп"
    if (!track_code && purchase_type === 'Выкуп') {
        const timestamp = Date.now(); // Текущее время в миллисекундах
        track_code = `PENDING-${timestamp}`; // Генерируем код вида PENDING-1678886400000
        console.log("[Add Order] Сгенерирован временный трек-код для выкупа:", track_code);
    }

    // Проверяем, есть ли трек-код ПОСЛЕ возможной генерации
    if (!track_code) {
        hideLoader();
        alert("Трек-код обязателен для заполнения (для типа 'Доставка').");
        console.warn("[Add Order] Submit failed: Track code is missing for 'Доставка'.");
        return; // Прерываем
    }

    // Собираем основной payload
    const payload = {
       client_id: parseInt(clientId),
       track_code: track_code,
       party_date: party_date,
       purchase_type: purchase_type,
       comment: comment,
       company_id: currentCompany.id, // <-- ДОБАВЬ ЭТУ СТРОКУ
       // location_id будет добавлен ниже
    };

    // Добавляем location_id для Владельца
    if (currentUser.role === 'Владелец') {
        const locationSelect = document.getElementById('order-location-select');
        if (locationSelect && locationSelect.value) {
            payload.location_id = parseInt(locationSelect.value);
        } else if (currentUser.location_id) {
             payload.location_id = currentUser.location_id;
        } else {
             console.warn("[Add Order] Owner location_id could not be determined.");
        }
    }

    // Добавляем поля выкупа, если нужно
    if (payload.purchase_type === 'Выкуп') {
        payload.buyout_item_cost_cny = parseFloat(document.getElementById('order-buyout-cost')?.value) || null;
        payload.buyout_rate_for_client = parseFloat(document.getElementById('order-buyout-rate')?.value) || null;
        payload.buyout_commission_percent = parseFloat(document.getElementById('order-buyout-commission')?.value) || 10.0;
    }

    // Отправка данных на сервер
    console.log("[Add Order] Sending payload to server:", payload);
    try {
        const newOrder = await apiFetch('/api/orders', {
            method: 'POST',
            body: JSON.stringify(payload)
        });
        console.log("[Add Order] Server response (new order):", newOrder);
        alert(`Заказ #${newOrder.id} (${newOrder.track_code}) успешно создан!`);

        const addOrderForm = document.getElementById('add-order-form');
        if(addOrderForm) addOrderForm.reset();

        // Дополнительно сбрасываем/очищаем поля, которые не сбрасываются методом reset()
        const clientSearchInput = document.getElementById('order-client-search-input');
        if (clientSearchInput) clientSearchInput.value = '';
        const selectedClientIdInput = document.getElementById('order-selected-client-id');
        if (selectedClientIdInput) selectedClientIdInput.value = '';
        const buyoutFieldsDiv = document.getElementById('order-buyout-fields');
        if (buyoutFieldsDiv) buyoutFieldsDiv.classList.add('hidden');
        console.log("[Add Order] Form reset complete.");

        // Устанавливаем сегодняшнюю дату по умолчанию для партии после сброса
        const today = new Date().toISOString().split('T')[0];
        const partyDateInput = document.getElementById('order-party-date');
        if (partyDateInput) partyDateInput.value = today;
        // Сбрасываем выбор филиала на основной филиал Владельца (если он есть)
        const locationSelect = document.getElementById('order-location-select');
        if (locationSelect && currentUser.location_id) {
             locationSelect.value = currentUser.location_id;
        }

        // --- ИЗМЕНЕНИЕ ЗДЕСЬ ---
        // Добавляем новый заказ В НАЧАЛО кэша
        companyOrders.unshift(newOrder); // newOrder - это ответ от бэкенда
        console.log("[Add Order] Новый заказ добавлен в кэш companyOrders.");

        // Перерисовываем список ИЗ ОБНОВЛЕННОГО КЭША
        renderOrderListFromCache();
        console.log("[Add Order] Список заказов перерисован из кэша.");

        // Обновляем доступные даты партий (на всякий случай, если это была новая дата)
        try {
            availablePartyDates = await apiFetch('/api/orders/parties');
            populatePartyFilter(); // Обновляем HTML фильтра дат
            console.log("[Add Order] Фильтр дат партий обновлен.");
        } catch(partyError) {
            console.warn("[Add Order] Не удалось обновить даты партий после добавления заказа:", partyError);
        }
        // --- КОНЕЦ ИЗМЕНЕНИЯ ---

    } catch (err) {
        console.error("!!! [Add Order] Ошибка при создании заказа:", err);
        alert(`Ошибка создания заказа: ${err.message}`);
    } finally {
        hideLoader();
        console.log("[Add Order] handleAddOrderSubmit: End");
    }
}

// === КОНЕЦ ФУНКЦИЙ ДЛЯ ФОРМЫ ДОБАВЛЕНИЯ ЗАКАЗА ===

// --- НОВЫЙ БЛОК: Логика для "Невостребованных" заказов ---

// Глобальный флаг для фильтра
let filterUnclaimedOnly = false;

// Фильтр "Невостребованные"
// Фильтр "Невостребованные"
function setupUnclaimedFilterButton() {
     const btn = document.getElementById('orders-filter-unclaimed-btn');
     if (btn) {
         btn.replaceWith(btn.cloneNode(true)); // Очистка слушателя
         // ИСПРАВЛЕНО: Теперь мы вызываем handleFilterUnclaimed
         document.getElementById('orders-filter-unclaimed-btn').addEventListener('click', handleFilterUnclaimed);
         console.log("[Listener OK] Added click to #orders-filter-unclaimed-btn via setup function.");
     }
}


// Кнопка "Назначить клиента"
function setupAssignClientButton() {
     const btn = document.getElementById('orders-bulk-assign-client-btn');
     if(btn) {
         btn.replaceWith(btn.cloneNode(true));
         document.getElementById('orders-bulk-assign-client-btn').addEventListener('click', openAssignClientModal);
     }
}

// Открытие модального окна "Назначить клиента"
function openAssignClientModal() {
    const selectedIds = Array.from(document.querySelectorAll('.order-checkbox:checked')).map(cb => cb.dataset.orderId);
    if (selectedIds.length === 0) {
        alert("Сначала выберите заказы для назначения.");
        return;
    }

    // Сброс модального окна
    document.getElementById('assign-client-info').textContent = `Выбрано заказов: ${selectedIds.length}`;
    document.getElementById('assign-client-search-input').value = '';
    document.getElementById('assign-client-search-results').innerHTML = '';
    document.getElementById('assign-client-selected-id').value = '';
    document.getElementById('assign-client-selected-info').classList.add('hidden');
    document.getElementById('assign-client-save-btn').disabled = true;

    // --- НОВЫЙ КОД: Заполняем select статусов ---
        const statusSelect = document.getElementById('assign-client-new-status');
        if (statusSelect) {
            // Заполняем всеми статусами, кроме "Выдан" (т.к. мы назначаем, а не выдаем)
            statusSelect.innerHTML = orderStatuses
                .filter(s => s !== 'Выдан')
                .map(s => `<option value="${s}" ${s === 'В пути' ? 'selected' : ''}>${s}</option>`)
                .join('');
            // По умолчанию выбираем "В пути", как ты и предлагал
        }
        // --- КОНЕЦ НОВОГО КОДА ---

    // Привязка слушателей
    const searchInput = document.getElementById('assign-client-search-input');
    const searchResults = document.getElementById('assign-client-search-results');
    const selectedIdInput = document.getElementById('assign-client-selected-id');
    const selectedInfo = document.getElementById('assign-client-selected-info');
    const saveBtn = document.getElementById('assign-client-save-btn');

// Поиск клиента
const newSearchInput = searchInput.cloneNode(true);
searchInput.parentNode.replaceChild(newSearchInput, searchInput);
newSearchInput.addEventListener('input', (e) => {
    handleGenericClientSearch(e.target, searchResults, (client) => {
        e.target.value = ''; 
        searchResults.classList.add('hidden');
        selectedIdInput.value = client.id; 
        selectedInfo.textContent = `Выбран клиент: ${client.full_name} (${client.client_code_prefix || ''}${client.client_code_num || '?'})`;
        selectedInfo.classList.remove('hidden');
        // Важно: newSaveBtn может быть не определен, если saveBtn еще не был обработан.
        // Вместо этого просто найдем кнопку и включим ее.
        document.getElementById('assign-client-save-btn').disabled = false;
    });
});

// Кнопка Сохранить
const newSaveBtn = saveBtn.cloneNode(true);
saveBtn.parentNode.replaceChild(newSaveBtn, saveBtn);
newSaveBtn.addEventListener('click', () => handleSaveClientAssignment(selectedIds));

    openModal('assign-client-modal');
}

// Сохранение назначения клиента
async function handleSaveClientAssignment(orderIds) {
    const clientId = document.getElementById('assign-client-selected-id').value;
    const newStatus = document.getElementById('assign-client-new-status').value; // <-- ДОБАВИТЬ
    if (!clientId) {
        alert("Ошибка: Клиент не выбран.");
        return;
    }

    console.log(`[Assign Client] Назначение ${orderIds.length} заказов клиенту ID: ${clientId}`);
    showLoader();

    try {
        // Мы используем тот же эндпоинт, что и 'update_status'
        const response = await apiFetch('/api/orders/bulk_action', {
            method: 'POST',
            body: JSON.stringify({
                action: 'assign_client', // <-- НОВОЕ ДЕЙСТВИЕ
                order_ids: orderIds.map(id => parseInt(id)),
                client_id: parseInt(clientId), // <-- НОВЫЙ ПАРАМЕТР
                new_status: newStatus
            })
        });

        alert(response.message || 'Заказы успешно назначены!');
        closeModal('assign-client-modal');
        toggleOrdersSelectMode(); // Выходим из режима выбора
        await fetchAndRenderOrders(); // Обновляем список

    } catch (err) {
        alert(`Ошибка назначения: ${err.message}`);
    } finally {
        hideLoader();
    }
}

// --- КОНЕЦ НОВОГО БЛОКА ---

// --- Функции для Импорта Заказов ---

async function handleOrderExcelImport() {
    console.log("[Import Orders] handleOrderExcelImport: Start");
    const fileInput = document.getElementById('order-excel-input');
    const resultsDiv = document.getElementById('order-import-results');
    const partyDateInput = document.getElementById('import-order-party-date');
    const partyDate = partyDateInput ? partyDateInput.value : null;

    // --- ДОБАВЛЕНИЕ: Считываем выбранный location_id из select'а импорта ---
    let importLocationId = null;
    if (currentUser.role === 'Владелец') {
        const locationSelect = document.getElementById('import-location-select');
        if (locationSelect && locationSelect.value) {
            importLocationId = parseInt(locationSelect.value); // Владелец выбрал
             console.log("[Import Orders] Owner selected location_id for import:", importLocationId);
        } else if (currentUser.location_id) {
             // Используем location_id Владельца по умолчанию, если select недоступен или не выбран
             importLocationId = currentUser.location_id; 
             console.log("[Import Orders] Owner using default location_id for import:", importLocationId);
        } else {
             // Если у Владельца нет location_id и нет select'а, бэкенд назначит первый
             console.warn("[Import Orders] Owner location_id for import could not be determined. Backend will assign default.");
        }
    }
    // Для обычного сотрудника location_id будет определен на бэкенде
    // --- КОНЕЦ ДОБАВЛЕНИЯ ---

    if (!resultsDiv) return console.error("!!! Import Orders Error: resultsDiv #order-import-results not found!");
    resultsDiv.innerHTML = '<p class="text-blue-600 animate-pulse">Обработка файла...</p>';

    if (!fileInput || fileInput.files.length === 0) {
        resultsDiv.innerHTML = '<p class="text-red-500">Ошибка: Выберите Excel-файл для импорта.</p>';
        return;
    }
    const file = fileInput.files[0];
    console.log(`[Import Orders] Selected file: ${file.name}, size: ${file.size} bytes`);
    showLoader(); // Показываем глобальный лоадер

    try {
        // --- Шаг 1: Чтение Excel ---
        console.log("[Import Orders] Reading Excel file...");
        const jsonData = await readExcelFile(file); 
        console.log(`[Import Orders] Excel read successfully. Found ${jsonData.length} rows.`);

        if (!jsonData || jsonData.length === 0) {
            resultsDiv.innerHTML = '<p class="text-yellow-600">Файл пуст.</p>';
            hideLoader(); return; 
        }

        // --- Шаг 2: Проверка колонок ---
        const firstRow = jsonData[0];
        if (!firstRow || !firstRow.hasOwnProperty('track_code')) {
          resultsDiv.innerHTML = '<p class="text-red-500">Ошибка: Файл должен содержать как минимум колонку <strong>track_code</strong>.</p>';
          hideLoader(); return;
        }
        console.log("[Import Orders] Required columns found.");

        // --- Шаг 3: Подготовка данных ---
        resultsDiv.innerHTML = `<p class="text-blue-600">Подготовка ${jsonData.length} записей...</p>`;
        const dataToSend = jsonData.map(row => ({
            track_code: String(row.track_code || '').trim() || null,
            client_code: row.client_code ? String(row.client_code).trim() : null,
            phone: row.phone ? String(row.phone).trim() : null,
            comment: row.comment ? String(row.comment).trim() : null,
            purchase_type: String(row.purchase_type || 'Доставка').trim(),
            buyout_item_cost_cny: parseFloat(row.buyout_item_cost_cny) || null,
            buyout_rate_for_client: parseFloat(row.buyout_rate_for_client) || null,
            buyout_commission_percent: parseFloat(row.buyout_commission_percent) || 10.0
        })).filter(item => item.track_code); // Отфильтровываем строки без трек-кода

        if (dataToSend.length === 0) {
            resultsDiv.innerHTML = '<p class="text-yellow-600">Нет строк с трек-кодом для импорта.</p>';
            hideLoader(); return;
        }
        console.log(`[Import Orders] Prepared ${dataToSend.length} valid records for sending.`);

        // --- Шаг 4: Отправка данных на БЭКЕНД ---
        // Формируем payload с датой партии, списком заказов И location_id
        const payload = {
            party_date: partyDate, 
            orders_data: dataToSend, 
            location_id: importLocationId // <-- ПЕРЕДАЕМ location_id
        };
        resultsDiv.innerHTML = `<p class="text-blue-600 animate-pulse">Отправка ${dataToSend.length} заказов на сервер...</p>`;
        console.log("[Import Orders] Sending payload to /api/orders/bulk_import:", payload);

        const response = await apiFetch('/api/orders/bulk_import', {
            method: 'POST',
            body: JSON.stringify(payload) 
        });
        console.log("[Import Orders] Server response:", response);

        // --- Шаг 5: Отображение результата ---
        let resultHtml = `<p class="text-green-600 font-semibold"><strong>Импорт завершен! Успешно создано: ${response.created_clients || 0}</strong></p>`; // Используем поле created_clients
        if (response.warnings && response.warnings.length > 0) {
            resultHtml += `<p class="text-yellow-600 mt-2 font-semibold"><strong>Предупреждения (${response.warnings.length}):</strong></p><ul class="list-disc list-inside text-xs">${response.warnings.map(w => `<li>${w}</li>`).join('')}</ul>`;
        }
        if (response.errors && response.errors.length > 0) {
            resultHtml += `<p class="text-red-600 mt-2 font-semibold"><strong>Ошибки (${response.errors.length}):</strong></p><ul class="list-disc list-inside text-xs">${response.errors.map(er => `<li>${er}</li>`).join('')}</ul>`;
        }
        resultsDiv.innerHTML = resultHtml; // Показываем результат

        // --- Шаг 6: Обновление списка заказов и дат партий (ИСПРАВЛЕН ПОРЯДОК) ---
        if (response.created_clients > 0 || partyDate || importLocationId) { 
            console.log("[Import Orders] Refreshing party dates filter FIRST...");

            // 1. СНАЧАЛА получаем новые даты
            availablePartyDates = await apiFetch('/api/orders/parties');

            // 2. ПОТОМ обновляем (и "чекаем") фильтр в интерфейсе
            populatePartyFilter(); 
            console.log("[Import Orders] Party filter updated. Refreshing orders list NOW...");

            // 3. ТЕПЕРЬ загружаем заказы. Они не исчезнут, т.к. фильтр обновлен.
            await fetchAndRenderOrders(); 
        }

    } catch (error) { // Обработка ошибок чтения файла или API
        console.error("!!! [Import Orders] CRITICAL ERROR", error);
        resultsDiv.innerHTML = `<p class="text-red-500"><b>Критическая ошибка импорта заказов:</b> ${error.message}</p>`;
    } finally {
        hideLoader(); // Прячем лоадер
        if (fileInput) fileInput.value = ''; // Сбрасываем выбор файла
        console.log("[Import Orders] handleOrderExcelImport: End");
    }
}


// --- Функции для Фильтров ---

// Заполняет HTML списка статусов в выпадающем фильтре
function populateStatusFilter() {
    console.log("[Filters] populateStatusFilter: Start");
    const listDiv = document.getElementById('orders-status-list');
    if (!listDiv) return console.warn("[Filters] populateStatusFilter: Element #orders-status-list not found.");

    // Проверяем, есть ли статусы в глоб. переменной
    if (!orderStatuses || orderStatuses.length === 0) {
        listDiv.innerHTML = '<p class="text-xs text-red-500">Ошибка: Список статусов не загружен.</p>';
        console.error("!!! [Filters] populateStatusFilter: orderStatuses array is empty!");
        return;
    }

    // Генерируем HTML для чекбоксов статусов
    // Отмечаем все, кроме "Выдан", по умолчанию
    listDiv.innerHTML = orderStatuses.map(s => `
        <div class="flex items-center">
            <input type="checkbox" id="status-filter-${s.replace(/\s+/g, '-')}" value="${s}"
                   class="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500 status-filter-checkbox"
                   ${s !== 'Выдан' ? 'checked' : ''}>
            <label for="status-filter-${s.replace(/\s+/g, '-')}" class="ml-2 text-sm text-gray-700">${s}</label>
        </div>
    `).join('');
    console.log("[Filters] populateStatusFilter: Status filter populated.");
}

// Заполняет HTML списка дат партий в выпадающем фильтре
function populatePartyFilter() {
     console.log("[Filters] populatePartyFilter: Start");
     const listDiv = document.getElementById('orders-party-list');
     if (!listDiv) return console.warn("[Filters] populatePartyFilter: Element #orders-party-list not found.");

     // Проверяем наличие дат в кэше
     if (!availablePartyDates || availablePartyDates.length === 0) {
          listDiv.innerHTML = '<p class="text-sm text-gray-500">Дат партий не найдено.</p>';
          console.log("[Filters] populatePartyFilter: No party dates available.");
          return;
     }

     // Генерируем HTML для чекбоксов дат партий
     // Отмечаем все по умолчанию
     listDiv.innerHTML = availablePartyDates.map(p => `
         <div class="flex items-center">
             <input type="checkbox" id="party-filter-${p}" value="${p}"
                    class="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500 party-filter-checkbox" checked>
             <label for="party-filter-${p}" class="ml-2 text-sm text-gray-700">${p}</label>
         </div>
     `).join('');
     console.log("[Filters] populatePartyFilter: Party date filter populated.");
 }


// Показать/Скрыть выпадающее окно фильтра статусов
function toggleOrdersStatusFilter() {
    console.log("[Filters] toggleOrdersStatusFilter called.");
    const statusContainer = document.getElementById('orders-status-filter-container');
    const partyContainer = document.getElementById('orders-party-filter-container');
    if (!statusContainer) return;

    // Перезаполняем список статусов перед показом (на случай изменений)
    if (statusContainer.classList.contains('hidden')) {
        populateStatusFilter();
    }
    statusContainer.classList.toggle('hidden'); // Показываем/скрываем
    // Скрываем другой фильтр, если он был открыт
    if(partyContainer) partyContainer.classList.add('hidden');
}

// Показать/Скрыть выпадающее окно фильтра партий (с обновлением дат)
async function toggleOrdersPartyFilter() {
     console.log("[Filters] toggleOrdersPartyFilter called.");
     const partyContainer = document.getElementById('orders-party-filter-container');
     const statusContainer = document.getElementById('orders-status-filter-container');
     if (!partyContainer) return;

     const listDiv = document.getElementById('orders-party-list');
     if (!listDiv) return;

     // Если контейнер скрыт, значит мы его открываем
     if (partyContainer.classList.contains('hidden')) {
          console.log("[Filters] Opening party filter. Refreshing dates...");
          listDiv.innerHTML = '<p class="text-sm text-gray-500 animate-pulse">Обновление дат...</p>';
          showLoader(); // Показываем глобальный лоадер на время запроса
          try {
                // Запрашиваем АКТУАЛЬНЫЕ даты партий с сервера
                const freshPartyDates = await apiFetch('/api/orders/parties');
                availablePartyDates = freshPartyDates; // Обновляем кэш
                console.log("[Filters] Fresh party dates received:", availablePartyDates);
                populatePartyFilter(); // Заполняем список свежими датами
                partyContainer.classList.remove('hidden'); // Показываем контейнер
          } catch(e) { // Обработка ошибки загрузки дат
                console.error("!!! [Filters] Error refreshing party dates:", e);
                listDiv.innerHTML = `<p class="text-sm text-red-500">Ошибка: ${e.message}</p>`;
                // Оставляем контейнер видимым, чтобы показать ошибку
                partyContainer.classList.remove('hidden');
          } finally {
               hideLoader(); // Скрываем лоадер
          }
     } else {
          // Если контейнер уже был открыт, просто скрываем его
          console.log("[Filters] Closing party filter.");
          partyContainer.classList.add('hidden');
     }
     // Скрываем другой фильтр (статусов), если он был открыт
     if(statusContainer) statusContainer.classList.add('hidden');
}

// Применить выбранные фильтры (закрывает окна и перезагружает список заказов)
function applyOrdersFiltersAndFetch() {
    console.log("[Filters] applyOrdersFiltersAndFetch called.");
    // Скрываем оба окна фильтров
    document.getElementById('orders-status-filter-container')?.classList.add('hidden');
    document.getElementById('orders-party-filter-container')?.classList.add('hidden');
    // Вызываем функцию перезагрузки списка заказов (она сама считает выбранные фильтры)
    fetchAndRenderOrders();
}

// Сбросить фильтр статусов (выбирает все, кроме "Выдан") и применить
function resetOrdersStatusFilter() {
     console.log("[Filters] resetOrdersStatusFilter called.");
     // Находим все чекбоксы статусов
     document.querySelectorAll('.status-filter-checkbox').forEach(cb => {
         // Отмечаем, если статус НЕ "Выдан"
         cb.checked = (cb.value !== 'Выдан');
     });
     applyOrdersFiltersAndFetch(); // Применяем сброшенные фильтры
}

// Сбросить фильтр партий (выбирает все доступные даты) и применить
function resetOrdersPartyFilter() {
     console.log("[Filters] resetOrdersPartyFilter called.");
     // Находим все чекбоксы дат
     document.querySelectorAll('.party-filter-checkbox').forEach(cb => {
         cb.checked = true; // Отмечаем все
     });
     applyOrdersFiltersAndFetch(); // Применяем сброшенные фильтры
}

// --- Функция Поиска по заказам (фильтрует отображение списка) ---
// Вызывается при вводе текста в поле #orders-search-input
function handleOrdersSearch(e) {
    const searchTerm = e.target.value.toLowerCase().trim(); // Получаем поисковый запрос (без пробелов по краям)
    console.log(`[Order Search] Term = "${searchTerm}"`);
    // Находим все ГРУППЫ клиентов в списке заказов
    const groupItems = document.querySelectorAll('#orders-list-container .client-order-group');

    groupItems.forEach(group => {
        // Извлекаем данные для поиска по всей группе из data-атрибутов
        const clientName = group.dataset.clientName || '';
        const clientPhone = group.dataset.clientPhone || '';
        const clientCode = group.dataset.clientCode || '';
        const groupTracks = group.dataset.tracks || ''; // Строка со всеми треками группы

        // Проверяем, совпадает ли поисковый запрос с данными КЛИЕНТА группы
        const clientMatch = clientName.includes(searchTerm) ||
                            clientPhone.includes(searchTerm) ||
                            clientCode.includes(searchTerm);

        let hasVisibleOrderInGroup = false; // Флаг, есть ли видимые заказы ВНУТРИ группы

        // Проходим по КАЖДОМУ заказу ВНУТРИ этой группы
        const orderItems = group.querySelectorAll('.order-list-item');
        orderItems.forEach(item => {
             // Извлекаем данные для поиска по конкретному заказу
             const itemTrack = item.dataset.track || '';
             const itemComment = item.dataset.comment || '';
             // Проверяем, совпадает ли запрос с треком или комментарием ЗАКАЗА
             const itemMatch = itemTrack.includes(searchTerm) || itemComment.includes(searchTerm);

             // Показываем заказ, если:
             // 1) Запрос совпал с данными клиента всей группы (clientMatch)
             // ИЛИ
             // 2) Запрос совпал с треком/комментарием этого конкретного заказа (itemMatch)
             if (clientMatch || itemMatch) {
                 item.style.display = 'block'; // Показываем элемент заказа
                 hasVisibleOrderInGroup = true; // Отмечаем, что в группе есть видимый заказ
             } else {
                 item.style.display = 'none'; // Скрываем элемент заказа
             }
        });

        // Показываем или скрываем ВСЮ ГРУППУ
        // Группа видна, если поисковый запрос пуст ИЛИ если внутри нее есть хотя бы один видимый заказ
        if (searchTerm === '' || hasVisibleOrderInGroup) {
            group.style.display = 'block'; // Показываем группу
        } else {
            group.style.display = 'none'; // Скрываем группу
        }
    });
    console.log(`[Order Search] Filtering complete.`);
    // После фильтрации нужно обновить состояние чекбокса "Выбрать все"
    updateSelectAllCheckboxState();
}

// --- ИСПРАВЛЕННАЯ ФУНКЦИЯ: Показать только "Невостребованные" (Неизвестный клиент) ---
// (Вставить после handleOrdersSearch)
function handleFilterUnclaimed() {
    // Эта функция ищет заказы, которые сгруппированы под 'unknown'
    // (т.е. `client_id` у них `null`), и которым `renderOrderListFromCache`
    // присваивает `full_name: 'Неизвестный клиент'`.
    
    const searchString = "Неизвестный клиент";
    console.log(`[Filter] handleFilterUnclaimed: Filtering by '${searchString}'`);
    
    // 1. Находим поле поиска
    const searchInput = document.getElementById('orders-search-input');
    if (!searchInput) return;

    // 2. Вписываем в него "Неизвестный клиент"
    searchInput.value = searchString; 

    // 3. Вызываем событие 'input', чтобы запустить функцию handleOrdersSearch
    // handleOrdersSearch найдет группу с `data-client-name="неизвестный клиент"`
    searchInput.dispatchEvent(new Event('input', { bubbles: true }));
    
    // 4. (Опционально) Скрываем панели фильтров, чтобы не мешали
    document.getElementById('orders-status-filter-container')?.classList.add('hidden');
    document.getElementById('orders-party-filter-container')?.classList.add('hidden');
}

// --- НОВАЯ ФУНКЦИЯ: Обновить список и сбросить поиск ---
// (Вставить после handleFilterUnclaimed)
async function handleRefreshOrders() {
    console.log("[Refresh] handleRefreshOrders: Clearing search and fetching orders.");
    // 1. Очищаем поле поиска
    const searchInput = document.getElementById('orders-search-input');
    if (searchInput) {
        searchInput.value = "";
        // Вызываем событие 'input', чтобы сбросить фильтрацию
        searchInput.dispatchEvent(new Event('input', { bubbles: true }));
    }
    
    // 2. (Опционально) Сбрасываем фильтры статусов и партий
    // resetOrdersStatusFilter(); // Это вызовет двойную загрузку, не надо
    // resetOrdersPartyFilter(); // Это вызовет двойную загрузку, не надо
    
    // 3. Загружаем свежие данные с сервера
    await fetchAndRenderOrders();
}

// --- Функции для Массовых Действий ---

// Переключает режим выбора заказов (показывает/скрывает чекбоксы и панель "Выбрать все")
function toggleOrdersSelectMode() {
    console.log("[Bulk Actions] Toggling select mode...");
    // Находим все чекбоксы заказов
    const checkboxes = document.querySelectorAll('.order-checkbox');
    // Находим контейнер "Выбрать все"
    const selectAllContainer = document.getElementById('orders-select-all-container');
    // Определяем, был ли режим выбора УЖЕ включен (по видимости первого чекбокса)
    const wasSelecting = checkboxes.length > 0 && !checkboxes[0].classList.contains('hidden');

    // Переключаем видимость для КАЖДОГО чекбокса заказа
    checkboxes.forEach(cb => cb.classList.toggle('hidden'));
    // Переключаем видимость контейнера "Выбрать все"
    if (selectAllContainer) selectAllContainer.classList.toggle('hidden');

    if (wasSelecting) {
        // Если режим выбора ВЫКЛЮЧАЕТСЯ, скрываем панель массовых действий
        console.log("[Bulk Actions] Select mode OFF. Hiding bulk action bar.");
        hideBulkActionBar();
    } else {
         // Если режим выбора ВКЛЮЧАЕТСЯ, просто показываем чекбоксы
         console.log("[Bulk Actions] Select mode ON.");
         // Заполняем select статусов для массовой смены (если еще не заполнен)
         const bulkStatusSelect = document.getElementById('orders-bulk-status-select');
         if (bulkStatusSelect && bulkStatusSelect.options.length <= 1) { // Проверяем, что опций мало
             bulkStatusSelect.innerHTML = '<option value="">-- Выберите статус --</option>' + // Добавляем пустую опцию
                                          orderStatuses.map(s => `<option value="${s}">${s}</option>`).join('');
             console.log("[Bulk Actions] Bulk status select populated.");
         }
         updateBulkActionBar(); // Обновляем панель (она может остаться скрытой, если ничего не выбрано)
         updateSelectAllCheckboxState(); // Обновляем состояние чекбокса "Выбрать все"
    }
}

// Скрывает панель массовых действий и сбрасывает все чекбоксы
function hideBulkActionBar() {
    console.log("[Bulk Actions] Hiding bulk action bar and resetting selection.");
    const actionBar = document.getElementById('orders-bulk-action-bar');
    const selectAllCheckbox = document.getElementById('orders-select-all-checkbox');

    if (actionBar) actionBar.classList.add('hidden'); // Скрываем панель
    if (selectAllCheckbox) selectAllCheckbox.checked = false; // Снимаем галочку "Выбрать все"
    // Снимаем галочки со всех чекбоксов заказов
    document.querySelectorAll('.order-checkbox').forEach(cb => cb.checked = false);
}

// Обработчик изменения чекбокса "Выбрать все видимые"
function handleOrdersSelectAll(e) {
    const isChecked = e.target.checked; // Получаем состояние главного чекбокса
    console.log(`[Bulk Actions] Select all checkbox changed to: ${isChecked}`);
    // Находим все чекбоксы заказов, которые ВИДИМЫ в данный момент
    document.querySelectorAll('#orders-list-container .order-list-item:not([style*="display: none"]) .order-checkbox').forEach(cb => {
        cb.checked = isChecked; // Устанавливаем им то же состояние
    });
    updateBulkActionBar(); // Обновляем счетчик и видимость панели массовых действий
}

// index.html (Внутри МОДУЛЬ: ЗАКАЗЫ)

function handleOrderCheckboxChange(e) {
    if (e.target.classList.contains('order-checkbox')) {
        const bar = document.getElementById('orders-bulk-action-bar');
        const selected = document.querySelectorAll('.order-checkbox:checked');
        const bulkStatusBlock = document.getElementById('orders-bulk-status-select').closest('div.flex');
        const bulkDateBlock = document.getElementById('orders-bulk-party-date-input').closest('div.flex');
        const buyoutBtn = document.getElementById('orders-bulk-buyout-btn'); // Кнопка выкупа

        if (selected.length > 0) {
            bar.classList.remove('hidden');
            document.getElementById('orders-selected-count').textContent = `Выбрано: ${selected.length}`;
            
            // --- КРИТИЧЕСКОЕ ИСПРАВЛЕНИЕ ЛОГИКИ ВЫКУПА ---
            const selectedOrders = Array.from(selected).map(cb => companyOrders.find(o => o.id == cb.dataset.orderId));
            // Проверяем, что ВСЕ выбранные заказы имеют статус "Ожидает выкупа"
            const allAwaitingBuyout = selectedOrders.every(o => o.status === 'Ожидает выкупа');

            if (allAwaitingBuyout) {
                // Если все готовы к выкупу, показываем ТОЛЬКО кнопку выкупа
                buyoutBtn.classList.remove('hidden'); 
                if (bulkStatusBlock) bulkStatusBlock.classList.add('hidden'); // Скрываем статус
                if (bulkDateBlock) bulkDateBlock.classList.add('hidden'); // Скрываем дату
            } else {
                // Иначе показываем стандартные массовые действия
                buyoutBtn.classList.add('hidden'); 
                if (bulkStatusBlock) bulkStatusBlock.classList.remove('hidden'); 
                if (bulkDateBlock) bulkDateBlock.classList.remove('hidden'); 
            }
            // --- КОНЕЦ КРИТИЧЕСКОГО ИСПРАВЛЕНИЯ ---
            
        } else {
            bar.classList.add('hidden');
        }
    }
    updateSelectAllCheckboxState();
}

// Обновляет состояние чекбокса "Выбрать все" (отмечен/не отмечен/промежуточный)
function updateSelectAllCheckboxState() {
     const selectAllCheckbox = document.getElementById('orders-select-all-checkbox');
     if (!selectAllCheckbox) return;

     // Находим все ВИДИМЫЕ чекбоксы заказов
     const allVisibleCheckboxes = Array.from(
          document.querySelectorAll('#orders-list-container .order-list-item:not([style*="display: none"]) .order-checkbox')
     );

     if (allVisibleCheckboxes.length === 0) {
          // Если видимых чекбоксов нет, снимаем галочку и делаем неактивным? (пока просто снимаем)
          selectAllCheckbox.checked = false;
          selectAllCheckbox.indeterminate = false;
          return;
     }

     const checkedVisibleCount = allVisibleCheckboxes.filter(cb => cb.checked).length; // Считаем отмеченные среди видимых

     if (checkedVisibleCount === 0) {
          // Если ни один не отмечен
          selectAllCheckbox.checked = false;
          selectAllCheckbox.indeterminate = false; // Нет промежуточного состояния
     } else if (checkedVisibleCount === allVisibleCheckboxes.length) {
          // Если ВСЕ видимые отмечены
          selectAllCheckbox.checked = true;
          selectAllCheckbox.indeterminate = false; // Нет промежуточного состояния
     } else {
          // Если отмечена только ЧАСТЬ видимых
          selectAllCheckbox.checked = false; // Галочку снимаем
          selectAllCheckbox.indeterminate = true; // Устанавливаем промежуточное состояние (тире)
     }
     console.log(`[Bulk Actions] Select all state updated: checked=${selectAllCheckbox.checked}, indeterminate=${selectAllCheckbox.indeterminate}`);
}


// Обновляет счетчик выбранных и показывает/скрывает панель массовых действий
function updateBulkActionBar() {
    // Считаем ВСЕ отмеченные чекбоксы (даже если они скрыты поиском)
    const selectedCheckboxes = document.querySelectorAll('.order-checkbox:checked');
    const count = selectedCheckboxes.length;
    const actionBar = document.getElementById('orders-bulk-action-bar');
    const countSpan = document.getElementById('orders-selected-count');

    console.log(`[Bulk Actions] updateBulkActionBar: Selected count = ${count}`);

    if (count > 0 && actionBar) {
        // Если выбран хотя бы один заказ, показываем панель
        actionBar.classList.remove('hidden');
        if(countSpan) countSpan.textContent = `Выбрано: ${count}`; // Обновляем счетчик
    } else if (actionBar) {
        // Если ни один не выбран, скрываем панель
        actionBar.classList.add('hidden');
    }
}

// Выполнить массовое обновление статуса
async function handleBulkUpdateStatus() {
    // Получаем ID всех отмеченных заказов
    const selectedIds = Array.from(document.querySelectorAll('.order-checkbox:checked'))
                           .map(cb => parseInt(cb.dataset.orderId));
    // Получаем выбранный новый статус из select'а
    const bulkStatusSelect = document.getElementById('orders-bulk-status-select');
    const newStatus = bulkStatusSelect ? bulkStatusSelect.value : null;

    // Проверки
    if (selectedIds.length === 0) {
        alert("Не выбраны заказы для смены статуса.");
        return;
    }
    if (!newStatus) { // Проверяем, выбран ли статус (не пустая ли опция "-- Выберите статус --")
         alert("Пожалуйста, выберите новый статус из списка.");
         return;
    }

    console.log(`[Bulk Action] handleBulkUpdateStatus: Attempting to set status '${newStatus}' for ${selectedIds.length} orders:`, selectedIds);
    showLoader(); // Показываем лоадер

    try {
        // Отправляем запрос на бэкенд
        const response = await apiFetch('/api/orders/bulk_action', {
            method: 'POST',
            body: JSON.stringify({
                action: 'update_status', // Указываем действие
                order_ids: selectedIds,   // Передаем массив ID
                new_status: newStatus     // Передаем новый статус
            })
        });
        console.log("[Bulk Action] handleBulkUpdateStatus: Server response:", response);
        alert(response.message || `Статус успешно обновлен для ${selectedIds.length} заказов.`);
        // Перезагружаем список заказов, чтобы увидеть изменения
        // При перезагрузке выбор и панель автоматически сбросятся
        await fetchAndRenderOrders();

    } catch (err) { // Обработка ошибок от apiFetch
        console.error("!!! [Bulk Action] handleBulkUpdateStatus: Error", err);
        alert(`Ошибка массового обновления статуса: ${err.message}`);
    } finally {
        hideLoader(); // Скрываем лоадер
        console.log("[Bulk Action] handleBulkUpdateStatus: End");
    }
}

// Выполнить массовое обновление даты партии
async function handleBulkUpdatePartyDate() {
    // Получаем ID всех отмеченных заказов
    const selectedIds = Array.from(document.querySelectorAll('.order-checkbox:checked'))
                           .map(cb => parseInt(cb.dataset.orderId));
    // Получаем выбранную дату из поля ввода
    const partyDateInput = document.getElementById('orders-bulk-party-date-input');
    const newDate = partyDateInput ? partyDateInput.value : null;

    // Проверки
    if (selectedIds.length === 0) {
        alert("Не выбраны заказы для смены даты партии."); return;
    }
    if (!newDate) {
        alert("Пожалуйста, выберите новую дату партии."); return;
    }

    // Запрашиваем пароль Владельца для подтверждения (т.к. это изменение данных)
    const ownerPassword = prompt(`Введите ваш пароль для подтверждения смены даты партии на ${newDate} для ${selectedIds.length} заказов:`);
    if (ownerPassword === null) { // Пользователь нажал Отмена
         console.log("[Bulk Action] Смена даты партии отменена пользователем.");
         return;
    }
    if (ownerPassword === "") { // Пароль не введен
         alert("Пароль не введен. Смена даты отменена.");
         return;
    }


    console.log(`[Bulk Action] handleBulkUpdatePartyDate: Attempting to set date '${newDate}' for ${selectedIds.length} orders.`);
    showLoader(); // Показываем лоадер

    try {
        // Отправляем запрос на бэкенд
        const response = await apiFetch('/api/orders/bulk_action', {
            method: 'POST',
            body: JSON.stringify({
                action: 'update_party_date', // Указываем действие
                order_ids: selectedIds,      // Передаем массив ID
                new_party_date: newDate,     // Передаем новую дату
                password: ownerPassword      // Передаем введенный пароль
            })
        });
        console.log("[Bulk Action] handleBulkUpdatePartyDate: Server response:", response);
        alert(response.message || `Дата партии успешно обновлена для ${selectedIds.length} заказов.`);

        // Обновляем список заказов
        await fetchAndRenderOrders();
        // Обновляем кэш и фильтр дат партий
        console.log("[Bulk Action] Refreshing party dates after update...");
        availablePartyDates = await apiFetch('/api/orders/parties');
        populatePartyFilter();

    } catch (err) { // Обработка ошибок (включая неверный пароль - 403)
        console.error("!!! [Bulk Action] handleBulkUpdatePartyDate: Error", err);
        alert(`Ошибка массовой смены даты партии: ${err.message}`);
    } finally {
        hideLoader(); // Скрываем лоадер
        console.log("[Bulk Action] handleBulkUpdatePartyDate: End");
    }
}

// Выполнить массовое удаление заказов
async function handleBulkDeleteOrders() {
    // Получаем ID всех отмеченных заказов
    const selectedIds = Array.from(document.querySelectorAll('.order-checkbox:checked'))
                           .map(cb => parseInt(cb.dataset.orderId));

    // Проверка
    if (selectedIds.length === 0) {
        alert("Не выбраны заказы для удаления."); return;
    }

    // Запрашиваем пароль Владельца для подтверждения (опасная операция)
    const ownerPassword = prompt(`ВНИМАНИЕ! Вы собираетесь удалить ${selectedIds.length} заказ(ов). Это действие НЕОБРАТИМО.\n\nВведите ваш пароль для подтверждения:`);
    if (ownerPassword === null) {
         console.log("[Bulk Action] Массовое удаление отменено пользователем.");
         return;
    }
     if (ownerPassword === "") {
         alert("Пароль не введен. Удаление отменено.");
         return;
    }

    console.log(`[Bulk Action] handleBulkDeleteOrders: Attempting to delete ${selectedIds.length} orders.`);
    showLoader(); // Показываем лоадер

    try {
        // Отправляем запрос на бэкенд
        const response = await apiFetch('/api/orders/bulk_action', {
            method: 'POST',
            body: JSON.stringify({
                action: 'delete',        // Указываем действие
                order_ids: selectedIds,  // Передаем массив ID
                password: ownerPassword  // Передаем введенный пароль
            })
        });
        console.log("[Bulk Action] handleBulkDeleteOrders: Server response:", response);
        alert(response.message || `Успешно удалено ${selectedIds.length} заказов.`);

        // Обновляем список заказов
        await fetchAndRenderOrders();
        // Обновляем кэш и фильтр дат партий (могли удалиться все заказы с какой-то датой)
        console.log("[Bulk Action] Refreshing party dates after delete...");
        availablePartyDates = await apiFetch('/api/orders/parties');
        populatePartyFilter();

    } catch (err) { // Обработка ошибок (включая неверный пароль - 403)
        console.error("!!! [Bulk Action] handleBulkDeleteOrders: Error", err);
        alert(`Ошибка массового удаления заказов: ${err.message}`);
    } finally {
        hideLoader(); // Скрываем лоадер
        console.log("[Bulk Action] handleBulkDeleteOrders: End");
    }
}

// --- ФУНКЦИЯ: Открывает модальное окно для ввода курса выкупа ---
function openBuyoutModal() {
    const modal = document.getElementById('buyout-modal');
    const selectedCheckboxes = document.querySelectorAll('.order-checkbox:checked');
    const selectedOrders = Array.from(selectedCheckboxes).map(cb => companyOrders.find(o => o.id == cb.dataset.orderId));

    if (selectedOrders.length === 0) return; // На всякий случай

    const ordersHtml = selectedOrders.map(o => `<li class="text-sm">${o.track_code} - ${o.buyout_item_cost_cny ?? '?'} CNY</li>`).join('');

    modal.querySelector('.modal-content').innerHTML = `
        <div class="flex justify-between items-start mb-4">
            <h3 class="text-2xl font-bold">Массовый выкуп (${selectedOrders.length} заказов)</h3>
            <button onclick="closeModal('buyout-modal')" class="text-2xl font-bold leading-none p-1 -m-1">&times;</button>
        </div>
        <p class="text-sm mb-2">Выбраны следующие заказы (статус будет изменен на "Выкуплен"):</p>
        <ul class="list-disc list-inside mb-4 max-h-40 overflow-y-auto p-2 bg-gray-50 rounded-md">${ordersHtml}</ul>
        <form id="buyout-form">
            <div>
                <label for="buyout-actual-rate-input" class="block text-sm font-medium text-gray-700">Введите реальный курс выкупа (сом/юань) *</label>
                <input type="number" step="any" id="buyout-actual-rate-input" class="mt-1 w-full p-2 border rounded" required placeholder="Например: 12.55">
            </div>
            <div class="flex gap-4 mt-6 border-t pt-4">
                <button type="button" onclick="closeModal('buyout-modal')" class="w-full bg-gray-200 py-2 rounded hover:bg-gray-300">Отмена</button>
                <button type="submit" class="w-full bg-purple-600 text-white py-2 rounded hover:bg-purple-700">Подтвердить выкуп</button>
            </div>
        </form>
    `;
    openModal('buyout-modal');
    document.getElementById('buyout-form').addEventListener('submit', handleBulkBuyout);
}


// --- ФУНКЦИЯ: Обработка сохранения выкупа ---
async function handleBulkBuyout(e) {
    e.preventDefault();
    const rateInput = document.getElementById('buyout-actual-rate-input');
    const rate = parseFloat(rateInput?.value);
    
    if (isNaN(rate) || rate <= 0) {
        alert("Пожалуйста, введите корректный положительный курс.");
        return;
    }
    
    const ids = Array.from(document.querySelectorAll('.order-checkbox:checked')).map(cb => parseInt(cb.dataset.orderId));
    
    showLoader(); // Показываем лоадер

    try {
        const url = '/api/orders/bulk_action'; // Используем эндпоинт массовых действий
        const payload = { 
            action: 'buyout', 
            order_ids: ids, 
            buyout_actual_rate: rate 
        };

        const r = await apiFetch(url, {
            method: 'POST',
            body: JSON.stringify(payload)
        });

        console.log("[Bulk Buyout] Server response:", r);
        alert(r.message || `Выкуп успешно обработан для ${ids.length} заказов!`);
        
        closeModal('buyout-modal');
        await fetchAndRenderOrders(); // Обновляем список, чтобы увидеть статус "Выкуплен"
        toggleOrdersSelectMode(); // Выходим из режима выбора

    } catch (err) {
        console.error("!!! [Bulk Buyout] Error:", err);
        alert(`Ошибка при массовом выкупе: ${err.message}`);
    } finally {
        hideLoader(); // Скрываем лоадер
    }
}
// === КОНЕЦ ФУНКЦИЙ ПОИСКА И МАССОВЫХ ДЕЙСТВИЙ ===

// --- Функции для Редактирования Заказа ---

// Обработчик клика в списке заказов (делегирование)
// Ищет кнопку 'edit-order-btn' и вызывает openEditOrderModal
function handleOrderListClick(e) {
    // Ищем ближайший родительский элемент с классом 'edit-order-btn'
    const editButton = e.target.closest('.edit-order-btn');
    // Если кнопка найдена, получаем ID заказа и открываем модальное окно
    if (editButton) {
        const orderId = editButton.dataset.orderId;
        console.log(`[Order Action] Edit button clicked for Order ID: ${orderId}`);
        openEditOrderModal(orderId); // Вызываем функцию открытия модалки
    }
    // Здесь можно добавить обработку других кнопок внутри заказа, если они появятся
}

// Открывает модальное окно для Редактирования Заказа
// index.html (ПОЛНОСТЬЮ ЗАМЕНЯЕТ openEditOrderModal)

function openEditOrderModal(orderId) {
    console.log(`[Modal] openEditOrderModal: Start for Order ID ${orderId}`);
    // Находим данные заказа в кэше companyOrders по ID
    const order = companyOrders.find(o => o.id == orderId); // Используем '=='

    // Проверяем, найден ли заказ и есть ли у него клиент
    if (!order) {
        console.error(`!!! openEditOrderModal: Order with ID ${orderId} not found in cache.`);
        alert("Ошибка: Не удалось найти данные заказа для редактирования.");
        return;
    }
     if (!order.client) {
         console.error(`!!! openEditOrderModal: Client data missing for Order ID ${orderId}.`);
         alert("Ошибка: Отсутствуют данные клиента для этого заказа.");
         return;
     }

    const modal = document.getElementById('edit-order-modal');
    if (!modal) return console.error("!!! openEditOrderModal: Modal element #edit-order-modal not found!");
    const modalContent = modal.querySelector('.modal-content');
    if (!modalContent) return console.error("!!! openEditOrderModal: Modal content not found!");

    // --- Генерируем HTML для содержимого модального окна ---

    // Генерируем опции для select'а статусов
     const statusOptions = orderStatuses.map(s =>
         `<option value="${s}" ${order.status === s ? 'selected' : ''}>${s}</option>`
     ).join('');

    // --- HTML для выбора филиала (только Владелец) ---
    let locationSelectHtml = '';
    // Проверяем роль И наличие загруженных филиалов
    if (currentUser.role === 'Владелец' && companyLocations && companyLocations.length > 0) {
        const locationOptions = companyLocations.map(loc =>
            // Отмечаем текущий филиал заказа
            `<option value="${loc.id}" ${loc.id === order.location_id ? 'selected' : ''}>${loc.name}</option>`
        ).join('');
        locationSelectHtml = `
            <div>
                <label for="modal-order-location" class="block text-sm font-medium text-gray-700">Филиал</label>
                <select id="modal-order-location" class="mt-1 w-full p-2 border rounded bg-white focus:ring-indigo-500 focus:border-indigo-500">
                    ${locationOptions}
                </select>
            </div>
        `;
    } else {
         // Для сотрудника или если филиалов нет, просто показываем текущий
         const currentLocationName = companyLocations.find(loc => loc.id === order.location_id)?.name || 'Неизвестный';
         locationSelectHtml = `
             <div>
                <label class="block text-sm font-medium text-gray-700">Филиал</label>
                <input type="text" class="mt-1 w-full p-2 border rounded bg-gray-100 cursor-not-allowed" value="${currentLocationName}" readonly title="Филиал заказа">
             </div>
         `;
    }
    // --- КОНЕЦ HTML для выбора филиала ---

    // Поля выкупа (если нужно)
    let buyoutHtml = '';
    if (order.purchase_type === 'Выкуп') {
        buyoutHtml = `
            <h4 class="text-md font-semibold mt-4 border-t pt-4 text-gray-700">Данные для Выкупа</h4>
             <div class="grid grid-cols-2 gap-4">
                 <div>
                     <label for="modal-order-buyout-cost" class="block text-sm font-medium text-gray-600">Стоимость (CNY)</label>
                     <input type="number" step="any" id="modal-order-buyout-cost" class="mt-1 w-full p-2 border rounded text-sm" value="${order.buyout_item_cost_cny || ''}">
                 </div>
                 <div>
                     <label for="modal-order-buyout-commission" class="block text-sm font-medium text-gray-600">Комиссия (%)</label>
                     <input type="number" step="1" id="modal-order-buyout-commission" value="${order.buyout_commission_percent ?? 10}" class="mt-1 w-full p-2 border rounded text-sm">
                 </div>
                 <div>
                     <label for="modal-order-buyout-rate" class="block text-sm font-medium text-gray-600">Курс для клиента</label>
                     <input type="number" step="any" id="modal-order-buyout-rate" class="mt-1 w-full p-2 border rounded text-sm" value="${order.buyout_rate_for_client || ''}">
                 </div>
                  <div>
                     <label for="modal-order-buyout-actual-rate" class="block text-sm font-medium text-gray-600">Реальный курс</label>
                     <input type="number" step="any" id="modal-order-buyout-actual-rate" class="mt-1 w-full p-2 border rounded text-sm" value="${order.buyout_actual_rate || ''}">
                 </div>
            </div>
        `;
    }

    // Собираем весь HTML модального окна
    modalContent.innerHTML = `
        <div class="flex justify-between items-start mb-4">
            <h3 class="text-2xl font-bold text-gray-800">Редактировать Заказ #${order.id}</h3>
            <button onclick="closeModal('edit-order-modal')" class="text-2xl font-bold leading-none p-1 -m-1 text-gray-500 hover:text-gray-700">&times;</button>
        </div>
        <form id="edit-order-form" data-order-id="${orderId}" class="space-y-4">
             <div class="grid grid-cols-2 gap-4">
                 <div>
                     <label for="modal-order-track-code" class="block text-sm font-medium text-gray-700">Трек-код *</label>
                     <input type="text" id="modal-order-track-code" class="mt-1 w-full p-2 border rounded focus:ring-indigo-500 focus:border-indigo-500" required value="${order.track_code || ''}">
                 </div>
                 <div>
                     <label for="modal-order-status" class="block text-sm font-medium text-gray-700">Статус</label>
                     <select id="modal-order-status" class="mt-1 w-full p-2 border rounded bg-white focus:ring-indigo-500 focus:border-indigo-500">${statusOptions}</select>
                 </div>
            </div>
             <div class="grid grid-cols-2 gap-4">
                 <div>
                     <label for="modal-order-party-date" class="block text-sm font-medium text-gray-700">Дата Партии</label>
                     <input type="date" id="modal-order-party-date" class="mt-1 w-full p-2 border rounded focus:ring-indigo-500 focus:border-indigo-500" value="${order.party_date || ''}">
                 </div>
                 ${locationSelectHtml}
            </div>
            <div>
                <label class="block text-sm font-medium text-gray-700">Тип заказа</label>
                <input type="text" id="modal-order-purchase-type" class="mt-1 w-full p-2 border rounded bg-gray-100 cursor-not-allowed" value="${order.purchase_type || '?'}" readonly title="Тип заказа нельзя изменить после создания">
            </div>
            <div>
                <label for="modal-order-client-search" class="block text-sm font-medium text-gray-700">Клиент</label>
                <div class="relative">
                     <input type="text" id="modal-order-client-search" placeholder="Начните ввод для смены клиента..."
                            class="mt-1 w-full p-2 border rounded focus:ring-indigo-500 focus:border-indigo-500"
                            value="${order.client.full_name} (${order.client.client_code_prefix || ''}${order.client.client_code_num || 'Нет кода'})">
                     <input type="hidden" id="modal-order-new-client-id" value="${order.client.id}">
                     <div id="modal-order-client-results" class="absolute hidden top-full left-0 right-0 bg-white border mt-1 rounded-md shadow-lg z-20 max-h-48 overflow-y-auto"></div>
                </div>
            </div>
            <div>
                <label for="modal-order-comment" class="block text-sm font-medium text-gray-700">Комментарий</label>
                <textarea id="modal-order-comment" class="mt-1 w-full p-2 border rounded h-16 focus:ring-indigo-500 focus:border-indigo-500" placeholder="Цвет, размер...">${order.comment || ''}</textarea>
            </div>

            ${buyoutHtml} 

            <div class="flex gap-4 mt-6 border-t pt-4">
                <button type="button" onclick="closeModal('edit-order-modal')" class="w-full bg-gray-200 py-2 rounded hover:bg-gray-300 text-gray-800">Отмена</button>
                <button type="submit" class="w-full bg-green-600 text-white py-2 rounded hover:bg-green-700">Сохранить Изменения</button>
            </div>
        </form>
    `;

    // --- ПРИВЯЗКА СЛУШАТЕЛЕЙ ПОСЛЕ ГЕНЕРАЦИИ HTML ---

    // Привязываем слушатель submit к форме
    const formElement = document.getElementById('edit-order-form');
    if (formElement) {
        // Используем replaceWith для удаления старых слушателей
        const newFormElement = formElement.cloneNode(true);
        formElement.parentNode.replaceChild(newFormElement, formElement);
        newFormElement.addEventListener('submit', handleSaveOrderChanges);
        console.log("[Modal Listener OK] Added submit to #edit-order-form");
    } else {
        console.error("!!! openEditOrderModal: Form #edit-order-form NOT FOUND!");
    }

    // Привязываем слушатель input к полю поиска клиента
    const clientSearchInput = document.getElementById('modal-order-client-search');
    if (clientSearchInput) {
        // Используем replaceWith для удаления старых слушателей
        const newClientSearchInput = clientSearchInput.cloneNode(true);
        clientSearchInput.parentNode.replaceChild(newClientSearchInput, clientSearchInput);
        newClientSearchInput.addEventListener('input', (e) => {
            const resultsDiv = document.getElementById('modal-order-client-results');
            const selectedIdInput = document.getElementById('modal-order-new-client-id');
            handleGenericClientSearch(e.target, resultsDiv, (client) => {
                e.target.value = `${client.full_name} (${client.client_code_prefix || ''}${client.client_code_num || 'Нет кода'})`;
                if(selectedIdInput) selectedIdInput.value = client.id;
            });
        });
        console.log("[Modal Listener OK] Added input listener to #modal-order-client-search");
    } else {
        console.error("!!! openEditOrderModal: Input #modal-order-client-search NOT FOUND!");
    }
    // --- КОНЕЦ ПРИВЯЗКИ СЛУШАТЕЛЕЙ ---

    openModal('edit-order-modal');
    console.log(`[Modal] openEditOrderModal: End for Order ID ${orderId}`);
}
// --- Сохранение изменений Заказа (вызывается из модального окна редактирования) ---
// index.html (Полностью заменяет handleSaveOrderChanges)

// index.html (ПОЛНОСТЬЮ ЗАМЕНЯЕТ handleSaveOrderChanges)

async function handleSaveOrderChanges(e) {
    e.preventDefault(); 
    console.log("[Save Order Changes] handleSaveOrderChanges: Start");
    showLoader(); 
    const form = e.target;
    const orderId = form.dataset.orderId; 
    const orderIdInt = parseInt(orderId); // Нам понадобится число

    if (!orderIdInt) { 
        hideLoader(); 
        alert("Критическая ошибка: Не удалось определить ID редактируемого заказа."); 
        console.error("!!! handleSaveOrderChanges: Order ID not found in form data-attribute.");
        return; 
    }
    
    const newClientId = document.getElementById('modal-order-new-client-id')?.value;
    if (!newClientId || isNaN(parseInt(newClientId))) { 
        hideLoader(); 
        alert("Ошибка: Не удалось определить ID клиента. Пожалуйста, выберите клиента из поиска."); 
        console.error("!!! handleSaveOrderChanges: New Client ID is invalid or missing.");
        return; 
    }

    // Собираем данные ИЗ ПОЛЕЙ МОДАЛЬНОГО ОКНА
    const payload = {
        track_code: document.getElementById('modal-order-track-code')?.value.trim(),
        status: document.getElementById('modal-order-status')?.value,
        party_date: document.getElementById('modal-order-party-date')?.value || null, 
        client_id: parseInt(newClientId), 
        comment: document.getElementById('modal-order-comment')?.value.trim() || null, 
        // Поля выкупа
        buyout_item_cost_cny: parseFloat(document.getElementById('modal-order-buyout-cost')?.value) || null,
        buyout_commission_percent: parseFloat(document.getElementById('modal-order-buyout-commission')?.value) || 10.0, 
        buyout_rate_for_client: parseFloat(document.getElementById('modal-order-buyout-rate')?.value) || null,
        buyout_actual_rate: parseFloat(document.getElementById('modal-order-buyout-actual-rate')?.value) || null,
        // location_id будет добавлен ниже
    };

    // --- ДОБАВЛЕНИЕ ЛОГИКИ LOCATION_ID (только если Владелец может редактировать) ---
    if (currentUser.role === 'Владелец') {
        const locationSelect = document.getElementById('modal-order-location');
        if (locationSelect && locationSelect.value) {
            payload.location_id = parseInt(locationSelect.value); 
            console.log("[Save Order Changes] Sending location_id:", payload.location_id);
        }
    }
    // --- КОНЕЦ ЛОГИКИ LOCATION_ID ---

    // Валидация
    if (!payload.track_code) { 
        hideLoader(); 
        alert("Трек-код не может быть пустым."); 
        console.warn("[Save Order Changes] Validation failed: track_code missing.");
        return; 
    }

    console.log(`[Save Order Changes] Sending PATCH to /api/orders/${orderId}. Payload:`, payload);
    try {
        // 1. Отправляем запрос. Бэкенд (с нашим фиксом в get_orders) вернет
        //    объект updatedOrder С ПОЛНЫМИ ДАННЫМИ КЛИЕНТА.
        const updatedOrder = await apiFetch(`/api/orders/${orderId}`, {
            method: 'PATCH',
            body: JSON.stringify(payload)
        });
        console.log("[Save Order Changes] Server response (updated order):", updatedOrder);
        alert(`Заказ #${orderId} успешно обновлен!`);
        closeModal('edit-order-modal'); 

        // 2. ИСПРАВЛЕНИЕ: Ручное обновление кэша (вместо fetchAndRenderOrders)
        // Находим индекс старого заказа в кэше
        const indexToUpdate = companyOrders.findIndex(o => o.id === orderIdInt);
        
        if (indexToUpdate !== -1) {
            // Если нашли, заменяем старый объект новым
            companyOrders[indexToUpdate] = updatedOrder;
            console.log(`[Save Order Changes] Кэш companyOrders обновлен для заказа ID: ${orderIdInt}`);
        } else {
            // Если не нашли (маловероятно), просто добавляем в начало
            companyOrders.unshift(updatedOrder);
            console.warn(`[Save Order Changes] Заказ ID: ${orderIdInt} не найден в кэше, добавлен в начало.`);
        }
        
        // 3. Перерисовываем список из ОБНОВЛЕННОГО кэша
        renderOrderListFromCache();
        console.log("[Save Order Changes] Список перерисован из кэша.");
        // (renderOrderListFromCache уже вызывает handleOrdersSearch, так что поиск применится)

    } catch (err) { 
        console.error("!!! [Save Order Changes] Error:", err);
        alert(`Ошибка обновления заказа #${orderId}: ${err.message}`);
    } finally {
        hideLoader(); 
        console.log("[Save Order Changes] handleSaveOrderChanges: End");
    }
}


// --- Общие вспомогательные функции (Универсальный поиск клиента и Экспорт) ---

// Универсальная функция поиска клиента (используется в Нескольких местах)
// inputElement - поле ввода текста
// resultsDivElement - div для отображения результатов
// onSelectCallback - функция, вызываемая при выборе клиента (получает объект client)
function handleGenericClientSearch(inputElement, resultsDivElement, onSelectCallback) {
     if (!inputElement || !resultsDivElement || !onSelectCallback) {
          console.error("[Client Search Util] Missing arguments for handleGenericClientSearch.");
          return;
     }
     const searchTerm = inputElement.value; // Текущий текст в поле ввода

     // Скрываем результаты, если поле пустое
     if (!searchTerm || searchTerm.length < 1) {
         resultsDivElement.innerHTML = '';
         resultsDivElement.classList.add('hidden');
         return;
     }

     // Debounce: ждем 300мс после последнего ввода перед поиском
     clearTimeout(inputElement.debounceTimer); // Сбрасываем предыдущий таймер
     inputElement.debounceTimer = setTimeout(async () => {
         console.log(`[Client Search Util] Searching for: "${searchTerm}"`);
         resultsDivElement.innerHTML = '<div class="p-2 text-sm text-gray-500 animate-pulse">Поиск...</div>'; // Индикатор
         resultsDivElement.classList.remove('hidden'); // Показываем
         try {
             // Запрос к API
             const clients = await apiFetch(`/api/clients/search?q=${encodeURIComponent(searchTerm)}`);
             console.log(`[Client Search Util] Found ${clients.length} clients.`);

             if (clients && clients.length > 0) {
                 // Генерируем HTML для найденных клиентов
                 resultsDivElement.innerHTML = clients.map(c => `
                     <div class="p-2 hover:bg-indigo-50 cursor-pointer text-sm search-result-item border-b last:border-b-0"
                          data-client-json='${JSON.stringify(c)}'>
                         ${c.full_name} (${c.client_code_prefix || ''}${c.client_code_num || 'Нет кода'}) - ${c.phone}
                     </div>
                 `).join('');
                 // Добавляем обработчики клика к результатам
                 resultsDivElement.querySelectorAll('.search-result-item').forEach(item => {
                     item.addEventListener('click', () => {
                         try {
                              const clientData = JSON.parse(item.dataset.clientJson); // Извлекаем данные
                              console.log(`[Client Search Util] Client selected:`, clientData);
                              onSelectCallback(clientData); // Вызываем callback с выбранным клиентом
                              resultsDivElement.innerHTML = ''; // Очищаем результаты
                              resultsDivElement.classList.add('hidden'); // Скрываем список
                         } catch (e) {
                              console.error("[Client Search Util] Error parsing client data from click:", e);
                              alert("Ошибка выбора клиента.");
                         }
                     });
                 });
             } else {
                 resultsDivElement.innerHTML = '<div class="p-2 text-sm text-gray-500">Клиенты не найдены.</div>';
             }
         } catch (error) { // Обработка ошибок поиска
             console.error("[Client Search Util] Error:", error);
             resultsDivElement.innerHTML = `<div class="p-2 text-sm text-red-500">Ошибка поиска: ${error.message}</div>`;
         }
     }, 300); // Задержка debounce
 }

// Функция экспорта отфильтрованных заказов в Excel
function handleExportOrders() {
     console.log("[Export Orders] handleExportOrders: Start");
     // Используем текущий кэш заказов (companyOrders), который отражает примененные фильтры
     if (!companyOrders || companyOrders.length === 0) {
         alert('Нет данных для экспорта. Пожалуйста, сначала загрузите или отфильтруйте заказы.');
         return;
     }
     // Проверяем наличие библиотеки XLSX
     if (typeof XLSX === 'undefined') {
         alert("Ошибка: Библиотека XLSX для экспорта не загружена.");
         return;
     }

     console.log(`[Export Orders] Preparing to export ${companyOrders.length} orders...`);
     showLoader(); // Показываем лоадер на время подготовки файла

     try {
         // Преобразуем данные заказов в формат для листа Excel
         const dataToExport = companyOrders.map(order => ({
             'Дата Партии': order.party_date || '',
             'Трек-код': order.track_code || '',
             'Статус': order.status || '',
             'Клиент ФИО': order.client?.full_name || '?',
             'Клиент Телефон': order.client?.phone || '?',
             'Клиент Код': `${order.client?.client_code_prefix || ''}${order.client?.client_code_num || ''}`,
             'Комментарий': order.comment || '',
             'Тип': order.purchase_type || '',
             'Цена CNY': order.buyout_item_cost_cny ?? '', // Используем ?? для пустых значений вместо null/undefined
             'Курс Клиент': order.buyout_rate_for_client ?? '',
             'Комиссия %': order.buyout_commission_percent ?? '',
             'Реал. Курс': order.buyout_actual_rate ?? '',
             'Расчет Вес': order.calculated_weight_kg ?? '',
             'Расчет Сумма': order.calculated_final_cost_som ?? '',
             'Дата Выдачи': order.issued_at ? new Date(order.issued_at).toLocaleString('ru-RU') : '', // Форматируем дату
             'Факт Вес': order.weight_kg ?? '',
             'Факт Сумма': order.final_cost_som ?? ''
             // Можно добавить любые другие поля из объекта order
         }));
         console.log("[Export Orders] Data prepared for sheet.");

         // Создаем новый лист Excel из подготовленных данных
         const worksheet = XLSX.utils.json_to_sheet(dataToExport);
         console.log("[Export Orders] Worksheet created.");

         // Создаем новую книгу Excel
         const workbook = XLSX.utils.book_new();

         // Добавляем лист в книгу
         XLSX.utils.book_append_sheet(workbook, worksheet, 'Заказы'); // Имя листа "Заказы"
         console.log("[Export Orders] Worksheet appended to workbook.");

         // Генерируем имя файла с датой и названием компании
         const today = new Date().toISOString().split('T')[0];
         const companyName = currentCompany ? currentCompany.name.replace(/\s+/g, '_') : 'SuperAdmin';
         const filename = `Экспорт_Заказов_${companyName}_${today}.xlsx`;
         console.log(`[Export Orders] Generated filename: ${filename}`);

         // Запускаем скачивание файла браузером
         XLSX.writeFile(workbook, filename);
         console.log("[Export Orders] Download initiated.");
         alert(`Экспорт ${companyOrders.length} заказов в файл "${filename}" начат.`);

     } catch (e) { // Обработка ошибок при создании Excel
          console.error("!!! [Export Orders] Error creating Excel file:", e);
          alert("Не удалось создать Excel файл для экспорта. Подробности в консоли.");
     } finally {
          hideLoader(); // Скрываем лоадер
          console.log("[Export Orders] handleExportOrders: End");
     }
 }
// === КОНЕЦ МОДУЛЯ ЗАКАЗЫ ===

// =================================================================
// МОДУЛЬ: ВЫДАЧА (Issuance) (v4.1 - Rebuild)
// =================================================================

// index.html (ПОЛНОСТЬЮ ЗАМЕНЯЕТ renderIssueTab)

// index.html (ПОЛНОСТЬЮ ЗАМЕНЯЕТ renderIssueTab)

async function renderIssueTab() {
    console.log("[Render] renderIssueTab: Start");
    const pane = document.getElementById('tab-issue');
    if (!pane) {
         console.warn("[Render] renderIssueTab: Pane #tab-issue not found.");
         return;
    }

    // --- ГЕНЕРИРУЕМ HTML ДЛЯ ФИЛЬТРА ФИЛИАЛОВ (ТОЛЬКО ДЛЯ ВЛАДЕЛЬЦА) ---
    let locationFilterHtml = '';
    // Показываем, если Владелец И филиалов БОЛЬШЕ одного И филиалы загружены
    if (currentUser.role === 'Владелец' && companyLocations && companyLocations.length > 1) {
        const locationOptions = companyLocations.map(loc =>
            // Предварительно выбираем основной филиал Владельца, если он есть
            `<option value="${loc.id}" ${loc.id === currentUser.location_id ? 'selected' : ''}>${loc.name}</option>`
        ).join('');

        locationFilterHtml = `
            <div class="p-2 bg-gray-100 rounded-md shadow-sm relative">
                <label for="issue-location-filter" class="text-xs font-medium text-gray-700 mr-2">Филиал:</label>
                <select id="issue-location-filter" class="rounded-md border-gray-300 p-1.5 text-xs bg-white shadow-sm w-36">
                    <option value="">-- Все филиалы --</option>
                    ${locationOptions}
                </select>
            </div>
        `;
        console.log("[Render] renderIssueTab: Location filter HTML generated.");
    } else {
         console.warn("[Render] renderIssueTab: Location filter NOT generated. Role:", currentUser.role, "Locations:", companyLocations?.length);
    }
    // --- КОНЕЦ ГЕНЕРАЦИИ ФИЛЬТРА ---

    // Генерируем основной HTML для вкладки "Выдача"
    pane.innerHTML = `
        <div id="issue-container" class="bg-white p-6 rounded-lg shadow-md">
            <div class="flex flex-wrap justify-between items-center gap-4 mb-4 border-b pb-4">
                <h2 class="text-2xl font-bold text-gray-800">Заказы, готовые к выдаче</h2>
                <div class="flex items-center gap-4 flex-wrap"> 
                    
                    ${locationFilterHtml} 
                    
                    <button id="show-issued-history-btn" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded text-sm">История выданных</button>
                    <button id="refresh-issue-list-btn" title="Обновить список" class="text-2xl ml-auto text-gray-500 hover:text-indigo-600">&circlearrowright;</button> 
                </div>
            </div>
            <div class="mb-4">
                <input type="search" id="issue-search-input" placeholder="🔍 Поиск по клиенту, телефону, трек-коду..." class="w-full p-2 border rounded-lg focus:ring-indigo-500 focus:border-indigo-500">
            </div>
            <div id="issue-list" class="space-y-4">
                <p class="text-gray-500 animate-pulse">Загрузка заказов для выдачи...</p>
            </div>
        </div>
    `;

    // --- Привязываем слушатели ---
    const containerDiv = document.getElementById('issue-container');
    if (containerDiv) {
        document.getElementById('show-issued-history-btn')?.addEventListener('click', showIssuedHistory);
        document.getElementById('refresh-issue-list-btn')?.addEventListener('click', fetchAndRenderIssueList);
        document.getElementById('issue-search-input')?.addEventListener('input', handleIssueSearch);
        
        // Привязываем слушатель к фильтру филиалов, ЕСЛИ ОН БЫЛ СОЗДАН
        const locationFilterSelect = document.getElementById('issue-location-filter');
        if (locationFilterSelect) {
            const newSelect = locationFilterSelect.cloneNode(true);
            locationFilterSelect.parentNode?.replaceChild(newSelect, locationFilterSelect);
            newSelect.addEventListener('change', fetchAndRenderIssueList); 
            console.log("[Listener OK] Added change to #issue-location-filter");
        }
        
        // Список заказов (делегирование)
        const issueListDiv = document.getElementById('issue-list');
        if (issueListDiv) {
            const newListDiv = issueListDiv.cloneNode(false); 
            issueListDiv.parentNode?.replaceChild(newListDiv, issueListDiv);
            newListDiv.innerHTML = '<p class="text-gray-500 animate-pulse">Загрузка заказов...</p>'; 
            newListDiv.addEventListener('change', handleIssueCheckboxChange);
            newListDiv.addEventListener('click', handleIssueButtonClick);
            console.log("[Listener OK] Added delegate listeners to #issue-list");
        }

        await fetchAndRenderIssueList(); 
        
    } else {
        console.error("!!! renderIssueTab: #issue-container not found.");
    }
    console.log("[Render] renderIssueTab: End");
}


async function fetchAndRenderIssueList() {
    console.log("[Fetch] fetchAndRenderIssueList: Start");
    const listDiv = document.getElementById('issue-list');
    if (!listDiv) return;

    listDiv.innerHTML = '<p class="text-gray-500 animate-pulse">Загрузка заказов...</p>';
    showLoader();

    // --- ИСПРАВЛЕНИЕ: Считываем выбранный location_id для Владельца ---
    const params = new URLSearchParams();
    if (currentUser.role === 'Владелец') {
        const locationFilterSelect = document.getElementById('issue-location-filter');
        // Проверяем, что select существует И в нем выбрано НЕ пустое значение ("-- Все филиалы --")
        if (locationFilterSelect && locationFilterSelect.value) {
            params.append('location_id', locationFilterSelect.value);
            console.log("[Fetch Issue List] Filtering by location_id:", locationFilterSelect.value);
        } else {
             console.log("[Fetch Issue List] Owner viewing all locations.");
        }
    }
    // Обычный сотрудник НЕ передает location_id, бэкенд отфильтрует сам
    const url = `/api/orders/ready_for_issue?${params.toString()}`; // Добавляем параметры к URL
    console.log("[Fetch Issue List] Requesting URL:", url);
    // --- КОНЕЦ ИСПРАВЛЕНИЯ ---

    try {
        // Запрашиваем заказы со статусом "Готов к выдаче"
        const ordersReady = await apiFetch(url); // Используем URL с параметрами

        // Группируем по клиенту (код остается)
        const ordersByClient = ordersReady.reduce((acc, order) => {
            const client_id = order.client?.id || 'unknown';
            if (!acc[client_id]) {
                acc[client_id] = { client: order.client, orders: [] };
            }
            acc[client_id].orders.push(order);
            return acc;
        }, {});

        listDiv.innerHTML = ''; // Очищаем перед рендерингом
        if (Object.keys(ordersByClient).length === 0) {
            listDiv.innerHTML = '<p class="text-gray-500">Нет заказов, готовых к выдаче (с учетом фильтра).</p>';
            return;
        }

        // Рендерим группы (код остается)
        for (const clientId in ordersByClient) {
            const group = ordersByClient[clientId];
            const client = group.client || { full_name: '?', phone: '?', client_code_prefix: '', client_code_num: '?' };
            const clientCode = `${client.client_code_prefix || ''}${client.client_code_num || '?'}`;

            const ordersHtml = group.orders.map(o => `
                <li class="flex items-center gap-2">
                    <input type="checkbox" class="issue-order-checkbox h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500"
                           data-order-id="${o.id}" data-client-id="${clientId}" data-track-code="${o.track_code}">
                    <span>${o.track_code} ${o.comment ? `(${o.comment})` : ''}</span>
                    ${o.calculated_final_cost_som ? `<span class="text-xs text-blue-600 ml-auto">${o.calculated_final_cost_som.toFixed(0)} сом</span>` : ''}
                </li>
            `).join('');

            const clientDiv = document.createElement('div');
            clientDiv.className = 'client-group p-4 bg-gray-50 rounded-lg shadow-sm border';
            clientDiv.dataset.clientName = client.full_name?.toLowerCase() || '';
            clientDiv.dataset.clientCode = clientCode.toLowerCase();
            clientDiv.dataset.clientPhone = client.phone || '';
            clientDiv.dataset.trackCodes = group.orders.map(o => o.track_code?.toLowerCase() || '').join(',');

            clientDiv.innerHTML = `
                <div class="flex justify-between items-center mb-2">
                    <div class="flex items-center gap-3">
                        <input type="checkbox" class="select-all-client-orders h-5 w-5 rounded border-gray-400 text-indigo-600 focus:ring-indigo-500"
                               data-client-id="${clientId}" title="Выбрать все заказы клиента">
                        <div>
                            <h3 class="font-bold text-lg">${client.full_name} (${clientCode})</h3>
                            <p class="text-sm text-gray-600">${client.phone}</p>
                        </div>
                    </div>
                    <button class="issue-btn bg-green-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-600 disabled:opacity-50 disabled:cursor-not-allowed text-sm"
                            data-client-id="${clientId}" disabled>Выдать выбранное</button>
                </div>
                <ul class="mt-2 space-y-1 pl-8">${ordersHtml}</ul>
            `;
            listDiv.appendChild(clientDiv);
        }
        console.log("[Fetch] fetchAndRenderIssueList: Render complete.");

    } catch (error) {
        listDiv.innerHTML = `<p class="text-red-500">Ошибка загрузки: ${error.message}</p>`;
    } finally {
        hideLoader();
    }
}

// --- Обработчик изменения чекбоксов на вкладке Выдача ---
function handleIssueCheckboxChange(e) {
    const target = e.target;
    let clientId = target.dataset.clientId;

    // Обработка "Выбрать все" для клиента
    if (target.classList.contains('select-all-client-orders')) {
        const isChecked = target.checked;
        document.querySelectorAll(`.issue-order-checkbox[data-client-id="${clientId}"]`).forEach(cb => cb.checked = isChecked);
    } 
    // Обработка одиночного чекбокса (обновляем "Выбрать все", если нужно)
    else if (target.classList.contains('issue-order-checkbox')) {
        clientId = target.dataset.clientId; // Переопределяем на всякий случай
        const allCheckboxes = document.querySelectorAll(`.issue-order-checkbox[data-client-id="${clientId}"]`);
        const checkedCount = document.querySelectorAll(`.issue-order-checkbox[data-client-id="${clientId}"]:checked`).length;
        const selectAll = document.querySelector(`.select-all-client-orders[data-client-id="${clientId}"]`);
        
        if (selectAll) {
             if (checkedCount === 0) {
                 selectAll.checked = false;
                 selectAll.indeterminate = false;
             } else if (checkedCount === allCheckboxes.length) {
                 selectAll.checked = true;
                 selectAll.indeterminate = false;
             } else {
                 selectAll.checked = false;
                 selectAll.indeterminate = true;
             }
        }
    } else {
         return; // Выходим, если клик не по чекбоксу
    }
    
    // Обновляем состояние кнопки "Выдать" для этого клиента
    const issueBtn = document.querySelector(`.issue-btn[data-client-id="${clientId}"]`);
    if (issueBtn) {
        const anyChecked = document.querySelector(`.issue-order-checkbox[data-client-id="${clientId}"]:checked`);
        issueBtn.disabled = !anyChecked; // Кнопка активна, если выбран хотя бы 1 заказ
    }
}

// --- Обработчик клика по кнопке "Выдать" ---
function handleIssueButtonClick(e) {
    const target = e.target.closest('.issue-btn');
    if (target && !target.disabled) {
        const clientId = target.dataset.clientId;
        const selectedCheckboxes = document.querySelectorAll(`.issue-order-checkbox[data-client-id="${clientId}"]:checked`);
        const ordersToIssue = Array.from(selectedCheckboxes).map(cb => ({
            id: parseInt(cb.dataset.orderId),
            track_code: cb.dataset.trackCode
        }));

        if (ordersToIssue.length > 0) {
            renderIssueModal(ordersToIssue); // Открываем модальное окно выдачи
        }
    }
}

// --- Рендеринг Модального Окна Выдачи ---
async function renderIssueModal(ordersToIssue) {
    console.log("[Render Issue Modal] Start rendering for orders:", ordersToIssue);
    // Находим элементы модального окна
    const issueModal = document.getElementById('issue-modal');
    // Проверка, что модальное окно существует
    if (!issueModal) {
        console.error("!!! renderIssueModal: Modal element #issue-modal not found!");
        return;
    }
    const modalContent = issueModal.querySelector('.modal-content');
    // Проверка, что контейнер для контента существует
    if (!modalContent) {
        console.error("!!! renderIssueModal: Modal content container (.modal-content) not found!");
        return;
    }

    // Показываем заглушку загрузки и открываем модальное окно
    modalContent.innerHTML = '<p class="text-center p-8 animate-pulse">Загрузка данных для выдачи...</p>';
    openModal('issue-modal'); // Открываем модальное окно
    showLoader(); // Показываем глобальный лоадер

    try {
        // --- Получаем полные данные заказов из кэша ---
        // Создаем Map для быстрого доступа к полным данным по ID заказа
        const fullOrderDataMap = new Map();
        // Проходим по списку ID заказов для выдачи
        ordersToIssue.forEach(o => {
            // Ищем полные данные заказа в глобальном кэше companyOrders
            const fullData = companyOrders.find(co => co.id === o.id);
            // Если данные найдены, добавляем их в Map
            if (fullData) {
                fullOrderDataMap.set(o.id, fullData);
            } else {
                // Предупреждаем, если данные заказа не найдены в кэше
                console.warn(`[Render Issue Modal] Full data for Order ID ${o.id} not found in cache.`);
            }
        });

        // --- Рассчитываем предварительную (расчетную) сумму ---
        let preCalculatedTotal = 0;
        // Проходим по найденным полным данным заказов
        fullOrderDataMap.forEach(o => {
            // Суммируем предрасчитанную стоимость (calculated_final_cost_som), если она есть
            preCalculatedTotal += o.calculated_final_cost_som || 0;
        });
        console.log(`[Render Issue Modal] Pre-calculated total: ${preCalculatedTotal}`);

        // --- Генерируем HTML для списка заказов С ПРЕДЗАПОЛНЕННЫМ ВЕСОМ ---
        const ordersHtml = ordersToIssue.map(o => {
            // Получаем полные данные для этого заказа из созданной Map
            const orderData = fullOrderDataMap.get(o.id);
            // Получаем предрасчитанный вес (calculated_weight_kg) или пустую строку, если его нет
            const calculatedWeight = orderData?.calculated_weight_kg ?? ''; // Используем ?? '' для value

            // Возвращаем HTML для элемента списка
            return `
            <div class="flex justify-between items-center border-b pb-2 mb-2">
                <span class="font-semibold text-sm">${o.track_code}</span>
                <input type="number" step="any" placeholder="Вес (кг)"
                       class="issue-weight-input w-24 p-1 border rounded text-sm"
                       data-order-id="${o.id}"
                       value="${calculatedWeight}" /* <-- ВСТАВЛЕНО ЗНАЧЕНИЕ ВЕСА */
                       required> </div>
            `;
        }).join(''); // Соединяем HTML всех заказов
        // --- КОНЕЦ ГЕНЕРАЦИИ HTML СПИСКА ЗАКАЗОВ ---

        // --- Получаем курсы и цену по умолчанию ---
        let defaultPrice = 5.5; // Значение по умолчанию
        let defaultRate = 87.5; // Значение по умолчанию
        // Пытаемся взять значения из ТЕКУЩЕЙ АКТИВНОЙ смены (если она есть)
        if (activeShift) {
             defaultPrice = activeShift.price_per_kg_usd || defaultPrice;
             defaultRate = activeShift.exchange_rate_usd || defaultRate;
             console.log("[Render Issue Modal] Using values from active shift:", defaultPrice, defaultRate);
        } else {
             console.log("[Render Issue Modal] Active shift not found, using default values.");
        }

        // --- Собираем HTML всего модального окна ---
        modalContent.innerHTML = `
            <div class="flex justify-between items-start mb-4">
                 <h3 class="text-2xl font-bold">Оформление выдачи (${ordersToIssue.length} зак.)</h3>
                 <button onclick="closeModal('issue-modal')" class="text-2xl font-bold leading-none p-1 -m-1">&times;</button>
            </div>
            <form id="issue-form">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div class="space-y-4">
                        <div class="p-3 bg-blue-50 rounded-lg">
                            <label for="total-weight-input" class="block text-sm font-medium">Общий вес (кг)</label>
                            <input type="number" step="any" id="total-weight-input" placeholder="Для авто-распределения" class="mt-1 w-full p-2 border rounded-md">
                        </div>
                        <div class="max-h-60 overflow-y-auto pr-2">${ordersHtml}</div> <div class="p-3 bg-gray-100 rounded-lg space-y-2">
                            <div>
                                <label for="issue-price-per-kg" class="block text-sm">Цена за кг ($) *</label>
                                <input type="number" step="0.1" id="issue-price-per-kg" value="${defaultPrice}" class="w-full p-2 border rounded" required>
                            </div>
                            <div>
                                <label for="issue-exchange-rate" class="block text-sm">Курс USD (сом) *</label>
                                <input type="number" step="0.1" id="issue-exchange-rate" value="${defaultRate}" class="w-full p-2 border rounded" required>
                            </div>
                        </div>
                    </div>
                    <div class="space-y-4">
                        <div>
                            <label for="payment-method-select" class="block text-sm font-medium">Способ оплаты</label>
                            <select id="payment-method-select" class="w-full mt-1 p-2 border rounded-md bg-white">
                                <option value="cash">Наличные</option>
                                <option value="card">Картой</option>
                                <option value="mixed">Смешанный</option>
                            </select>
                        </div>
                        <div id="payment-fields-container" class="space-y-3">
                            </div>
                        <div class="p-4 bg-indigo-50 rounded-lg text-right space-y-2">
                            ${preCalculatedTotal > 0 ? `<div class="text-sm text-gray-600">Предварительная сумма: ${preCalculatedTotal.toFixed(2)} сом</div>` : ''}
                            <div class="text-lg">Итого к оплате (факт): <span id="total-cost-display" class="font-bold">0.00 сом</span></div>
                            <div class="text-md">Всего оплачено: <span id="total-paid-display" class="font-bold">0.00 сом</span></div>
                            <div class="text-xl text-green-600">Сдача: <span id="change-display" class="font-bold">0.00 сом</span></div>
                        </div>
                    </div>
                </div>
                <div class="mt-6 flex justify-end gap-4 border-t pt-4"> <button type="button" onclick="closeModal('issue-modal')" class="bg-gray-300 hover:bg-gray-400 text-black font-bold py-2 px-6 rounded-lg">Отмена</button>
                    <button type="submit" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg">Выдать</button>
                </div>
            </form>
        `;

        // --- Привязываем логику расчета и обработчики к созданным элементам ---
        setupIssueModalLogic(); // <--- Эта функция инициализирует расчеты и слушатели внутри модалки
        console.log("[Render Issue Modal] Logic attached.");

    } catch (error) { // Обработка ошибок при подготовке окна
         console.error("!!! [Render Issue Modal] Error preparing modal:", error);
         // Показываем сообщение об ошибке в модальном окне
         modalContent.innerHTML = `
              <div class="flex justify-between items-start mb-4">
                 <h3 class="text-2xl font-bold text-red-700">Ошибка</h3>
                 <button onclick="closeModal('issue-modal')" class="text-2xl font-bold">&times;</button>
              </div>
              <p class="text-red-600">Не удалось подготовить окно выдачи: ${error.message}</p>
              <div class="mt-6 text-right">
                  <button onclick="closeModal('issue-modal')" class="bg-gray-300 py-2 px-4 rounded">Закрыть</button>
              </div>`;
    } finally {
         // В любом случае скрываем глобальный лоадер
         hideLoader();
         console.log("[Render Issue Modal] End.");
    }
}

// --- Логика модального окна выдачи (расчет, поля оплаты) ---
function setupIssueModalLogic() {
    const form = document.getElementById('issue-form');
    const paymentMethodSelect = document.getElementById('payment-method-select');
    const paymentFieldsContainer = document.getElementById('payment-fields-container');
    const totalWeightInput = document.getElementById('total-weight-input');
    const individualWeightInputs = document.querySelectorAll('.issue-weight-input');
    const priceInput = document.getElementById('issue-price-per-kg');
    const rateInput = document.getElementById('issue-exchange-rate');
    let totalCost = 0; // Глобальная (в рамках модалки) переменная для итоговой стоимости

    const updateTotals = () => {
        const price = parseFloat(priceInput.value) || 0;
        const rate = parseFloat(rateInput.value) || 0;
        let totalWeight = 0;
        individualWeightInputs.forEach(input => { totalWeight += parseFloat(input.value) || 0; });
        totalCost = totalWeight * price * rate;
        document.getElementById('total-cost-display').textContent = `${totalCost.toFixed(2)} сом`;
        updatePaymentFields(); // Пересчитываем оплату, т.к. изменилась итоговая сумма
    };

    const updatePaymentFields = () => {
        const method = paymentMethodSelect.value;
        let cashPaid = parseFloat(document.getElementById('issue-paid-cash')?.value) || 0;
        let cardPaid = parseFloat(document.getElementById('issue-paid-card')?.value) || 0;
        
        // Если выбрана оплата картой, поле карты заполняется автоматически
        if (method === 'card') {
            cardPaid = totalCost;
            cashPaid = 0; // Наличных нет
             const cardInput = document.getElementById('issue-paid-card');
             if (cardInput) cardInput.value = cardPaid.toFixed(2);
        }
        
        let totalPaid = cashPaid + cardPaid;
        let change = totalPaid > totalCost ? totalPaid - totalCost : 0;
        
        document.getElementById('total-paid-display').textContent = `${totalPaid.toFixed(2)} сом`;
        document.getElementById('change-display').textContent = `${change.toFixed(2)} сом`;
    };

    const renderPaymentFields = () => {
        const method = paymentMethodSelect.value;
        paymentFieldsContainer.innerHTML = '';
        const cashField = `<div><label class="block text-sm">Наличными (сом)</label><input type="number" id="issue-paid-cash" value="0" step="any" class="w-full p-2 border rounded"></div>`;
        // Поле карты делаем readonly только если выбрана оплата ТОЛЬКО картой
        const cardField = `<div><label class="block text-sm">Картой (сом)</label><input type="number" id="issue-paid-card" value="0.00" step="any" class="w-full p-2 border rounded" ${method === 'card' ? 'readonly' : ''}></div>`;
        // Типы карт - TODO: Загрузить из config на сервере?
        const cardTypes = ["MBank", "Optima", "DemirBank", "Другое"]; 
        const cardTypeField = `<div><label class="block text-sm">Тип карты</label><select id="issue-card-type" class="w-full p-2 border rounded bg-white">${cardTypes.map(t => `<option value="${t}">${t}</option>`).join('')}</select></div>`;

        if (method === 'cash') paymentFieldsContainer.innerHTML = cashField;
        if (method === 'card') paymentFieldsContainer.innerHTML = cardField + cardTypeField;
        if (method === 'mixed') paymentFieldsContainer.innerHTML = cashField + cardField + cardTypeField;

        // Добавляем слушатели к полям оплаты ПОСЛЕ их создания
        document.getElementById('issue-paid-cash')?.addEventListener('input', () => {
            // В смешанном режиме авто-заполняем карту остатком
            if (method === 'mixed') {
                const cashAmount = parseFloat(document.getElementById('issue-paid-cash').value) || 0;
                const remainder = totalCost - cashAmount;
                document.getElementById('issue-paid-card').value = (remainder > 0 ? remainder : 0).toFixed(2);
            }
            updatePaymentFields(); // Пересчитываем общую оплату и сдачу
        });
        document.getElementById('issue-paid-card')?.addEventListener('input', updatePaymentFields);
        
        updateTotals(); // Вызываем один раз для инициализации и расчета при card/cash
    };

    renderPaymentFields(); // Рендерим поля оплаты при инициализации
    paymentMethodSelect.addEventListener('change', renderPaymentFields); // Перерендериваем при смене способа
    [priceInput, rateInput].forEach(el => el.addEventListener('input', updateTotals)); // Слушатели цены/курса
    
    // Слушатель общего веса
    totalWeightInput.addEventListener('input', () => {
        const totalWeight = parseFloat(totalWeightInput.value) || 0;
        if (totalWeight >= 0 && individualWeightInputs.length > 0) {
            const weightPerItem = (totalWeight / individualWeightInputs.length).toFixed(3);
            individualWeightInputs.forEach(input => { input.value = weightPerItem; });
        } else { individualWeightInputs.forEach(input => { input.value = ''; }); }
        updateTotals(); // Пересчитываем итог
    });
    
    // Слушатели индивидуальных весов
    individualWeightInputs.forEach(input => {
        input.addEventListener('input', () => {
            totalWeightInput.value = ''; // Сбрасываем общий вес
            updateTotals(); // Пересчитываем итог
        });
    });
    
    // Слушатель отправки формы
    form.addEventListener('submit', handleIssueSubmit);
}

// --- Обработчик отправки формы выдачи ---
async function handleIssueSubmit(e) {
    e.preventDefault();
    const ordersPayload = Array.from(document.querySelectorAll('.issue-weight-input')).map(input => ({
        order_id: parseInt(input.dataset.orderId),
        weight_kg: parseFloat(input.value)
    }));
    
    // Валидация веса
    if (ordersPayload.some(o => !o.weight_kg || o.weight_kg <= 0)) {
        alert('Ошибка: Вес должен быть указан (больше нуля) для всех заказов.');
        return;
    }
    
    const method = document.getElementById('payment-method-select').value;
    const paidCash = (method === 'cash' || method === 'mixed') ? (parseFloat(document.getElementById('issue-paid-cash')?.value) || 0) : 0;
    const paidCard = (method === 'card' || method === 'mixed') ? (parseFloat(document.getElementById('issue-paid-card')?.value) || 0) : 0;
    
    // Простая проверка суммы оплаты (можно улучшить, сравнив с totalCost)
    if (paidCash < 0 || paidCard < 0) {
        alert("Суммы оплаты не могут быть отрицательными."); return;
    }

    const payload = {
        orders: ordersPayload,
        price_per_kg_usd: parseFloat(document.getElementById('issue-price-per-kg').value),
        exchange_rate_usd: parseFloat(document.getElementById('issue-exchange-rate').value),
        paid_cash: paidCash,
        paid_card: paidCard,
        card_payment_type: (method === 'card' || method === 'mixed') ? document.getElementById('issue-card-type')?.value : null
    };

    // Валидация цены и курса
    if (!payload.price_per_kg_usd || payload.price_per_kg_usd <= 0 || !payload.exchange_rate_usd || payload.exchange_rate_usd <= 0) {
        alert("Пожалуйста, укажите корректные цену и курс."); return;
    }

    showLoader(); 
    try {
        const response = await apiFetch('/api/orders/issue', { // Используем /api
            method: 'POST',
            body: JSON.stringify(payload)
        });
        
        alert(response.message || 'Заказы успешно выданы!');
        closeModal('issue-modal');
        await fetchAndRenderIssueList(); // Обновляем список готовых к выдаче
        
    } catch (error) {
        alert(`Ошибка при выдаче: ${error.message}`);
    } finally {
        hideLoader(); 
    }
}

// --- Функции для Истории Выданных ---

// index.html (ПОЛНОСТЬЮ ЗАМЕНЯЕТ showIssuedHistory)

async function showIssuedHistory() {
    const issuedHistoryModal = document.getElementById('issued-history-modal');
    const modalContent = issuedHistoryModal.querySelector('.modal-content');
    const today = new Date().toISOString().split('T')[0];

    // --- HTML для фильтра филиалов (только Владелец) ---
    let locationFilterHistoryHtml = '';
    if (currentUser.role === 'Владелец' && companyLocations && companyLocations.length > 1) {
        const locationOptions = companyLocations.map(loc =>
            `<option value="${loc.id}" ${loc.id === currentUser.location_id ? 'selected' : ''}>${loc.name}</option>`
        ).join('');
        locationFilterHistoryHtml = `
            <div class="flex-shrink-0">
                <label for="history-location-filter" class="block text-sm font-medium text-gray-700">Филиал:</label>
                <select id="history-location-filter" class="mt-1 p-2 border rounded-md bg-white text-sm w-40">
                    <option value="">-- Все филиалы --</option>
                    ${locationOptions}
                </select>
            </div>
        `;
    }
    // --- КОНЕЦ HTML ФИЛЬТРА ---

    modalContent.innerHTML = `
        <div class="flex justify-between items-center mb-4">
             <h3 class="text-2xl font-bold">История выданных заказов</h3>
             <button onclick="closeModal('issued-history-modal')" class="text-2xl font-bold">&times;</button>
        </div>
        <div class="flex flex-wrap gap-4 items-end p-4 bg-gray-50 rounded-lg mb-4 border">
            
            <div> <label for="history-start-date" class="block text-sm font-medium">С</label> <input type="date" id="history-start-date" value="${today}" class="mt-1 p-2 border rounded-md"> </div>
            <div> <label for="history-end-date" class="block text-sm font-medium">По</label> <input type="date" id="history-end-date" value="${today}" class="mt-1 p-2 border rounded-md"> </div>
            
            ${locationFilterHistoryHtml}
            
            <button id="filter-history-btn" class="bg-blue-600 text-white py-2 px-4 rounded-md ml-auto">Показать</button>
        </div>
        <div id="history-content" class="overflow-y-auto max-h-[60vh]">
            <p class="animate-pulse">Загрузка истории...</p>
        </div>
    `;
    openModal('issued-history-modal');

    // Привязываем слушатель к кнопке "Показать" и фильтру филиалов
    document.getElementById('filter-history-btn')?.addEventListener('click', fetchAndRenderHistory);
    document.getElementById('history-location-filter')?.addEventListener('change', fetchAndRenderHistory); // Добавляем слушатель
    
    // Сразу загружаем историю за сегодня
    await fetchAndRenderHistory();
}

// index.html (ПОЛНОСТЬЮ ЗАМЕНЯЕТ fetchAndRenderHistory)

async function fetchAndRenderHistory() {
    const contentDiv = document.getElementById('history-content');
    const startDate = document.getElementById('history-start-date')?.value;
    const endDate = document.getElementById('history-end-date')?.value;
    if (!contentDiv || !startDate || !endDate) return;

    contentDiv.innerHTML = '<p class="animate-pulse">Загрузка истории...</p>';
    showLoader(); 

    // --- ДОБАВЛЕНИЕ: Считываем и передаем location_id ---
    const params = new URLSearchParams({
        start_date: startDate,
        end_date: endDate
    });
    if (currentUser.role === 'Владелец') {
        const locationSelect = document.getElementById('history-location-filter');
        if (locationSelect && locationSelect.value) {
            params.append('location_id', locationSelect.value);
            console.log("[Fetch History] Filtering history by location_id:", locationSelect.value);
        }
    }
    const url = `/api/orders/issued?${params.toString()}`;
    console.log("[Fetch History] Requesting URL:", url);
    // --- КОНЕЦ ДОБАВЛЕНИЯ ---

    try {
        const issuedOrders = await apiFetch(url); // Используем URL с параметрами

        if (!issuedOrders || issuedOrders.length === 0) {
            contentDiv.innerHTML = '<p class="text-gray-500">Выданных заказов за этот период (с учетом фильтра) нет.</p>';
            return;
        }

        const tableRows = issuedOrders.map(o => `
            <tr class="border-b hover:bg-gray-50 text-sm">
                <td class="p-2">${new Date(o.issued_at).toLocaleString()}</td>
                <td class="p-2">${o.client?.full_name || '?'} (${o.client?.client_code_prefix || ''}${o.client?.client_code_num || '?'})</td>
                <td class="p-2">${o.track_code}</td>
                <td class="p-2">${o.weight_kg?.toFixed(3) || '-'} кг</td>
                <td class="p-2">${o.final_cost_som?.toFixed(2) || '-'} сом</td>
                <td class="p-2">
                    <button class="revert-status-btn text-xs bg-yellow-400 hover:bg-yellow-500 text-yellow-900 px-2 py-1 rounded" 
                            data-order-id="${o.id}">Вернуть</button>
                </td>
            </tr>
        `).join('');

        contentDiv.innerHTML = `
            <div class="mb-4">
                 <input type="search" id="history-search-input" placeholder="🔍 Поиск по клиенту, трек-коду..." class="w-full p-2 border rounded-lg">
            </div>
            <div class="overflow-y-auto max-h-[50vh]">
                <table class="w-full text-left" id="history-table">
                    <thead class="bg-gray-100 sticky top-0">
                        <tr class="text-xs font-semibold uppercase text-gray-600">
                           <th class="p-2">Дата выдачи</th>
                           <th class="p-2">Клиент</th>
                           <th class="p-2">Трек-код</th>
                           <th class="p-2">Вес</th>
                           <th class="p-2">Сумма</th>
                           <th class="p-2">Действие</th>
                        </tr>
                    </thead>
                    <tbody>${tableRows}</tbody>
                </table>
            </div>
        `;

        // Привязываем слушатели
        document.getElementById('history-search-input')?.addEventListener('input', handleHistorySearch);
        contentDiv.querySelector('#history-table tbody')?.addEventListener('click', e => {
            const revertBtn = e.target.closest('.revert-status-btn');
            if (revertBtn) {
                const orderId = revertBtn.dataset.orderId;
if (confirm('Вы уверены, что хотите вернуть этот заказ? Оплата будет отменена.')) {
    // Проверяем, установлен ли пароль в настройках
    const requiredPassword = companySettings['password_revert_order'];
    let password = null;

    if (requiredPassword) {
        password = prompt("Для возврата заказа введите пароль:");
        if (password === null) return; // Нажата "Отмена"
    }

    const reason = prompt("Укажите ПРИЧИНУ возврата (обязательно):");
    if (!reason || reason.trim().length < 5) {
        alert("Причина не указана или слишком короткая. Возврат отменен.");
        return;
    }

    handleRevertStatus(orderId, password, reason); // <-- ПЕРЕДАЕМ ДАННЫЕ
}
            }
        });

    } catch (error) {
        contentDiv.innerHTML = `<p class="text-red-500">Ошибка загрузки истории: ${error.message}</p>`;
    } finally {
        hideLoader(); 
    }
}

// Поиск по истории выданных
function handleHistorySearch(e) {
    const searchTerm = e.target.value.toLowerCase().trim();
    document.querySelectorAll('#history-table tbody tr').forEach(row => {
        const rowContent = row.textContent?.toLowerCase() || '';
        row.style.display = rowContent.includes(searchTerm) ? '' : 'none';
    });
}

// Обработка возврата статуса
async function handleRevertStatus(orderId, password, reason) { // <-- ПРИНИМАЕМ ДАННЫЕ
    console.log(`[Revert] Reverting order ID: ${orderId}`);
    showLoader(); 
    try {
        // Формируем payload
        const payload = {
            password: password,
            revert_reason: reason
        };

        // Вызываем PATCH /api/orders/{id}/revert_status
        await apiFetch(`/api/orders/${orderId}/revert_status`, { 
            method: 'PATCH',
            body: JSON.stringify(payload) // <-- ОТПРАВЛЯЕМ PAYLOAD
        });

        alert('Статус заказа успешно возвращен на "Готов к выдаче"!');
        await fetchAndRenderHistory(); // Обновляем историю в модальном окне
        await fetchAndRenderIssueList(); // Обновляем список готовых к выдаче на основной вкладке

    } catch (error) {
        alert(`Ошибка возврата статуса: ${error.message}`);
    } finally {
        hideLoader(); 
    }
}



// --- Поиск по списку Готовых к Выдаче ---
function handleIssueSearch(e) {
    const searchTerm = e.target.value.toLowerCase().trim();
    document.querySelectorAll('#issue-list .client-group').forEach(group => {
        const name = group.dataset.clientName || '';
        const code = group.dataset.clientCode || '';
        const phone = group.dataset.clientPhone || '';
        const tracks = group.dataset.trackCodes || '';

        const isMatch = name.includes(searchTerm) || 
                        code.includes(searchTerm) || 
                        phone.includes(searchTerm) || 
                        tracks.includes(searchTerm);
        
        group.style.display = isMatch ? 'block' : 'none';
    });
}

// === КОНЕЦ МОДУЛЯ ВЫДАЧА ===

// =================================================================
// МОДУЛЬ: РАСХОДЫ (Владелец/Кассир) (v4.1 - Rebuild)
// =================================================================

// --- Рендеринг вкладки "Расходы" ---
async function renderExpensesTab() {
    console.log("[Render] renderExpensesTab: Start");
    const today = new Date().toISOString().split('T')[0]; // Сегодняшняя дата для полей по умолчанию
    const pane = document.getElementById('tab-expenses'); // Находим контейнер вкладки
    // Если контейнер не найден (например, из-за ошибки в HTML или правах), выходим
    if (!pane) {
        console.warn("[Render] renderExpensesTab: Pane #tab-expenses not found.");
        return;
    }

    // --- ДОБАВИТЬ: HTML для фильтра филиалов (только Владелец) ---
    let locationFilterHtml = ''; // Инициализируем пустой строкой
    // Показываем фильтр, только если текущий пользователь - Владелец
    // И если глобальный кэш филиалов companyLocations загружен и содержит больше одного филиала
    if (currentUser.role === 'Владелец' && companyLocations && companyLocations.length > 1) {
        // Генерируем <option> для каждого филиала
        const locationOptions = companyLocations.map(loc =>
            // Предварительно выбираем основной филиал Владельца, если он есть
            `<option value="${loc.id}" ${loc.id === currentUser.location_id ? 'selected' : ''}>${loc.name}</option>`
        ).join(''); // Соединяем все <option> в одну строку

        // Формируем HTML для select'а
        locationFilterHtml = `
            <div>
                <label for="expenses-location-filter" class="block text-sm font-medium text-gray-700">Филиал:</label>
                <select id="expenses-location-filter" class="mt-1 p-2 border rounded-md bg-white text-sm w-full">
                    <option value="">-- Все расходы --</option> ${locationOptions} </select>
            </div>
        `;
        console.log("[Render Expenses] Фильтр филиалов для Владельца добавлен.");
    } else {
         console.log("[Render Expenses] Фильтр филиалов не требуется или недоступен.");
    }
    // --- КОНЕЦ ДОБАВЛЕНИЯ ФИЛЬТРА ФИЛИАЛОВ ---


    // Генерируем основной HTML для всей вкладки "Расходы"
    pane.innerHTML = `
        <div id="expenses-container" class="bg-white p-6 rounded-lg shadow-md">
            <div class="flex flex-wrap justify-between items-center gap-4 mb-4 border-b pb-4">
                <h2 class="text-2xl font-bold text-gray-800">Учет расходов</h2>
                <button id="add-expense-btn" class="bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-700 text-sm">➕ Добавить расход</button>
            </div>

            <div class="flex flex-wrap gap-4 items-end p-4 bg-gray-50 rounded-lg mb-4 border">
                <div>
                    <label for="expense-start-date" class="block text-sm font-medium text-gray-700">С</label>
                    <input type="date" id="expense-start-date" value="${today}" class="mt-1 p-2 border rounded-md">
                </div>
                <div>
                    <label for="expense-end-date" class="block text-sm font-medium text-gray-700">По</label>
                    <input type="date" id="expense-end-date" value="${today}" class="mt-1 p-2 border rounded-md">
                </div>
                ${locationFilterHtml}
                <button id="filter-expenses-btn" class="bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700 ml-auto">Показать</button> </div>

            <div class="mb-4">
                <input type="search" id="expenses-search-input" placeholder="🔍 Поиск по типу, сумме, примечанию..." class="w-full p-2 border rounded-lg">
            </div>

            <div id="expenses-list" class="space-y-3">
                <p class="text-gray-500">Нажмите "Показать", чтобы загрузить расходы за период.</p>
            </div>
        </div>
    `;

    // --- Добавляем слушатели к элементам, которые мы ТОЛЬКО ЧТО создали ---
    // Находим главный контейнер вкладки
    const containerDiv = document.getElementById('expenses-container');
    // Проверяем, найден ли контейнер (на всякий случай)
    if (containerDiv) {
        // Кнопка "Добавить расход"
        const addBtn = document.getElementById('add-expense-btn');
        // Если кнопка найдена, добавляем слушатель клика, который откроет модальное окно
        if (addBtn) addBtn.addEventListener('click', () => openExpenseModal());

        // Кнопка "Показать" (для применения фильтров даты и филиала)
        const filterBtn = document.getElementById('filter-expenses-btn');
        // Если кнопка найдена, добавляем слушатель клика, который вызовет загрузку и рендеринг расходов
        if (filterBtn) filterBtn.addEventListener('click', fetchAndRenderExpenses);

        // Поле поиска
        const searchInput = document.getElementById('expenses-search-input');
        // Если поле найдено, добавляем слушатель ввода, который будет фильтровать УЖЕ отображенный список
        if (searchInput) searchInput.addEventListener('input', handleExpensesSearch);

        // Список расходов (для делегирования кликов по кнопкам "Изменить", "Удалить")
        const listDiv = document.getElementById('expenses-list');
        // Если список найден, добавляем слушатель клика на весь список
        if (listDiv) listDiv.addEventListener('click', handleExpenseActions);

        // ДОБАВИТЬ СЛУШАТЕЛЬ ДЛЯ НОВОГО ФИЛЬТРА ФИЛИАЛОВ
        const locationFilterSelect = document.getElementById('expenses-location-filter');
        // Если select филиалов был добавлен И найден
        if (locationFilterSelect) {
            // Добавляем слушатель события 'change' (смена выбора)
            locationFilterSelect.addEventListener('change', fetchAndRenderExpenses);
            console.log("[Listener OK] Added change to #expenses-location-filter");
        }
        // КОНЕЦ ДОБАВЛЕНИЯ

        // Загружаем расходы за сегодня (по умолчанию) при первой загрузке вкладки
        await fetchAndRenderExpenses();

    } else {
        // Если главный контейнер не найден, выводим ошибку в консоль
        console.error("!!! renderExpensesTab: #expenses-container not found.");
    }

    console.log("[Render] renderExpensesTab: End");
}


// --- Загрузка и отображение списка Расходов ---
// index.html (ЗАМЕНИТЬ ЭТОЙ ФУНКЦИЕЙ СТАРУЮ fetchAndRenderExpenses)

// --- Загрузка и отображение списка Расходов ---
async function fetchAndRenderExpenses() {
    console.log("[Fetch] fetchAndRenderExpenses: Start");
    // Находим контейнер, куда будем выводить список расходов
    const listDiv = document.getElementById('expenses-list');
    // Находим поля с датами начала и конца периода
    const startDateInput = document.getElementById('expense-start-date');
    const endDateInput = document.getElementById('expense-end-date');

    // Проверяем, найдены ли все необходимые элементы
    if (!listDiv || !startDateInput || !endDateInput) {
        console.error("!!! fetchAndRenderExpenses: Critical elements not found (listDiv or date inputs).");
        return; // Выходим, если что-то не найдено
    }
    // Получаем значения дат
    const startDate = startDateInput.value;
    const endDate = endDateInput.value;
    // Проверяем, что даты выбраны
    if (!startDate || !endDate) {
        listDiv.innerHTML = '<p class="text-yellow-500">Пожалуйста, выберите даты начала и конца периода.</p>';
        return; // Выходим, если даты не выбраны
    }

    // Показываем заглушку "Загрузка..."
    listDiv.innerHTML = '<p class="text-gray-500 animate-pulse">Загрузка расходов...</p>';
    showLoader(); // Показываем глобальный индикатор загрузки

    // --- ДОБАВИТЬ: Считываем выбранный location_id (если пользователь - Владелец) ---
    // Создаем объект URLSearchParams для удобного добавления параметров к URL
    const params = new URLSearchParams({
        start_date: startDate, // Добавляем дату начала
        end_date: endDate     // Добавляем дату конца
    });
    // Проверяем, является ли текущий пользователь Владельцем
    if (currentUser.role === 'Владелец') {
        // Находим select для выбора филиала
        const locationSelect = document.getElementById('expenses-location-filter');
        // Если select существует И в нем выбрано какое-то значение (не пустая опция "-- Все расходы --")
        if (locationSelect && locationSelect.value) {
            // Добавляем параметр location_id к запросу
            params.append('location_id', locationSelect.value);
            console.log("[Fetch Expenses] Filtering by location_id:", locationSelect.value);
        } else {
             // Если Владелец выбрал "-- Все расходы --" или select'а нет
             console.log("[Fetch Expenses] Owner viewing all locations' expenses.");
        }
    }
    // Для обычного сотрудника location_id не добавляем, бэкенд отфильтрует сам
    // Формируем URL запроса с параметрами (?start_date=...&end_date=...&location_id=...)
    const url = `/api/expenses?${params.toString()}`;
    console.log("[Fetch Expenses] Requesting URL:", url);
    // --- КОНЕЦ ДОБАВЛЕНИЯ ---

    try {
        // Выполняем запрос к API с помощью нашей вспомогательной функции apiFetch
        // Используем сформированный URL с параметрами
        const expenses = await apiFetch(url);

        // Проверяем, вернул ли бэкенд пустой список
        if (!expenses || expenses.length === 0) {
            listDiv.innerHTML = '<p class="text-gray-500">Расходов за выбранный период (с учетом фильтра) не найдено.</p>';
        } else {
            // Если расходы есть, генерируем HTML для каждого элемента
            listDiv.innerHTML = expenses.map(exp => {

                // --- ИСПРАВЛЕНИЕ: Безопасное получение имени сотрудника ---
                // Определяем имя сотрудника. По умолчанию - "Общий", если расход не привязан к смене.
                let employeeName = 'Общий (Владелец)'; // Значение по умолчанию
                // Проверяем, есть ли у расхода связь со сменой (shift),
                // есть ли у смены связь с сотрудником (employee),
                // и есть ли у сотрудника имя (full_name)
                if (exp.shift && exp.shift.employee && exp.shift.employee.full_name) {
                    employeeName = exp.shift.employee.full_name; // Если все есть, берем имя сотрудника из смены
                }
                // --- КОНЕЦ ИСПРАВЛЕНИЯ ---

                // Определяем, можно ли редактировать этот расход
                // Владелец может редактировать любые расходы
                // Сотрудник может редактировать только расходы из АКТИВНОЙ смены (shift.end_time === null)
                const canEdit = (currentUser.role === 'Владелец') ||
                                (exp.shift && exp.shift.end_time === null);

                // Определяем, можно ли удалять этот расход
                // Только Владелец может удалять, и только если расход не из закрытой смены
                const canDelete = (currentUser.role === 'Владелец') &&
                                (exp.shift === null || exp.shift.end_time === null);

                // Формируем HTML-разметку для одного расхода
                return `
                    <div class="p-3 bg-gray-50 rounded-md border flex flex-wrap justify-between items-center gap-2 expense-item"
                         data-notes="${(exp.notes || '').toLowerCase()}" data-type="${(exp.expense_type?.name || '').toLowerCase()}"> <div class="flex-grow min-w-[200px]">
                            <p class="font-bold text-lg">
                                ${exp.expense_type?.name || 'Тип не указан'} — <span class="text-red-600">${exp.amount.toFixed(2)} сом</span>
                            </p>
                            <p class="text-sm text-gray-700">${exp.notes || 'Без примечания'}</p>
                            <p class="text-xs text-gray-500">
                                ${new Date(exp.created_at).toLocaleString('ru-RU')} | Сотрудник: ${employeeName}
                            </p>
                        </div>

                        <div class="flex-shrink-0 flex gap-2">
                            ${canEdit ? `
                            <button data-expense-json='${JSON.stringify(exp)}' class="edit-expense-btn text-sm bg-gray-200 hover:bg-gray-300 px-3 py-1 rounded">
                                Изменить
                            </button>
                            ` : ''} ${canDelete ? `
                            <button data-expense-id="${exp.id}"
                                    data-expense-name="${exp.expense_type?.name || 'Расход'}" class="delete-expense-btn text-sm bg-red-200 hover:bg-red-300 text-red-800 px-3 py-1 rounded">
                                Удалить
                            </button>
                            ` : ''} </div>
                    </div>
                `;
            }).join(''); // Соединяем HTML всех расходов в одну строку
        }
        console.log("[Fetch] fetchAndRenderExpenses: Success");
    } catch (e) {
        // Если произошла ошибка при запросе к API
        console.error("!!! [Fetch] fetchAndRenderExpenses: Error", e);
        listDiv.innerHTML = `<p class="text-red-500">Ошибка загрузки расходов: ${e.message}</p>`;
    } finally {
        // В любом случае (успех или ошибка) скрываем глобальный индикатор загрузки
        hideLoader();
    }
}

// --- Обработка действий (Редактирование, Удаление) ---
function handleExpenseActions(e) {
    const editBtn = e.target.closest('.edit-expense-btn');
    const deleteBtn = e.target.closest('.delete-expense-btn');
    
    if (editBtn) {
        try {
            const expenseData = JSON.parse(editBtn.dataset.expenseJson);
            openExpenseModal(expenseData); // TODO: Создать openExpenseModal
            // alert(`Редактирование расхода: ${expenseData.id}. Открытие модального окна.`);
        } catch (e) {
            console.error("Error parsing expense data:", e);
        }
    } else if (deleteBtn) {
        const expenseId = deleteBtn.dataset.expenseId;
        const expenseName = deleteBtn.dataset.expenseName;
        if (confirm(`Удалить расход "${expenseName}"? Это действие НЕОБРАТИМО и требует пароля Владельца!`)) {
            const password = prompt("Введите пароль Владельца для подтверждения удаления:");
            if (password) {
                handleDeleteExpense(expenseId, password);
            } else if (password !== null) {
                alert("Удаление отменено: пароль не введен.");
            }
        }
    }
}

// --- Функция удаления расхода ---
async function handleDeleteExpense(expenseId, password) {
    console.log(`[Delete] handleDeleteExpense: Deleting ID ${expenseId}`);
    showLoader();
    try {
        // Отправляем DELETE запрос (пароль передается как Query параметр)
        await apiFetch(`/api/expenses/${expenseId}?password=${encodeURIComponent(password)}`, { 
            method: 'DELETE' 
        });
        alert("Расход успешно удален!");
        await fetchAndRenderExpenses(); // Обновляем список
    } catch (err) {
        console.error("!!! [Delete] handleDeleteExpense: Error", err);
        alert(`Ошибка удаления расхода: ${err.message}`);
    } finally {
        hideLoader();
    }
}

// --- Функция поиска по расходам ---
function handleExpensesSearch(e) {
    const searchTerm = e.target.value.toLowerCase().trim();
    document.querySelectorAll('#expenses-list .expense-item').forEach(item => {
        const itemType = item.dataset.type || '';
        const itemNotes = item.dataset.notes || '';
        const itemContent = item.textContent?.toLowerCase() || '';

        const isMatch = itemType.includes(searchTerm) || itemNotes.includes(searchTerm) || itemContent.includes(searchTerm);
        item.style.display = isMatch ? 'flex' : 'none';
    });
}

// --- Функция: Открытие модального окна добавления/редактирования расхода ---
// index.html (Полностью заменяет openExpenseModal)

async function openExpenseModal(expense = null) {
    // Проверку на активную смену для СОТРУДНИКА оставим на бэкенде.
    // Владелец может открывать всегда.
    
    const expenseModal = document.getElementById('expense-modal');
    const modalContent = expenseModal.querySelector('.modal-content');
    const isEdit = expense !== null; // Редактирование пока не меняем
    
    modalContent.innerHTML = '<p class="text-center p-8">Загрузка данных...</p>';
    openModal('expense-modal');
    showLoader(); 

    try {
        // --- ЗАГРУЖАЕМ ДАННЫЕ ПАРАЛЛЕЛЬНО ---
        const [typesData, activeShiftsData] = await Promise.allSettled([
            // Загружаем типы расходов (из кэша или API)
            (companyExpenseTypes.length > 0) ? Promise.resolve(companyExpenseTypes) : apiFetch('/api/expense_types'),
            // Загружаем ВСЕ активные смены компании (для Владельца)
            (currentUser.role === 'Владелец') ? fetchActiveShiftsForCompany() : Promise.resolve([]) 
        ]);

        // Обрабатываем типы расходов
        if (typesData.status === 'fulfilled') {
            companyExpenseTypes = typesData.value;
        } else {
            throw new Error(`Не удалось загрузить типы расходов: ${typesData.reason?.message || typesData.reason}`);
        }
        
        // Обрабатываем активные смены (только для Владельца)
        let activeShifts = [];
        if (activeShiftsData.status === 'fulfilled') {
            activeShifts = activeShiftsData.value;
        } else {
            // Ошибка загрузки смен не критична, Владелец сможет добавить общий расход
            console.warn("Не удалось загрузить активные смены для выбора:", activeShiftsData.reason);
        }
        
        // Генерируем опции для Типов Расходов
        const typesOptions = companyExpenseTypes
            .map(t => `<option value="${t.id}" ${isEdit && expense.expense_type_id === t.id ? 'selected' : ''}>${t.name}</option>`)
            .join('');

        // --- ГЕНЕРИРУЕМ ВЫПАДАЮЩИЙ СПИСОК СМЕН ДЛЯ ВЛАДЕЛЬЦА ---
        let shiftSelectorHtml = '';
        if (currentUser.role === 'Владелец') {
            if (activeShifts.length > 0) {
                // Если есть активные смены, предлагаем выбор
                const shiftOptions = activeShifts.map(shift => {
                    const locationName = companyLocations.find(loc => loc.id === shift.location_id)?.name || `Филиал ${shift.location_id}`;
                    const employeeName = shift.employee?.full_name || 'Неизвестен';
                    return `<option value="${shift.id}">Смена #${shift.id} (${locationName} - ${employeeName})</option>`;
                }).join('');
                
                shiftSelectorHtml = `
                    <div>
                        <label for="expense-shift-select" class="block text-sm font-medium text-gray-700">Привязать к смене:</label>
                        <select id="expense-shift-select" name="shift_id" class="mt-1 w-full p-2 border rounded bg-white">
                            <option value="">-- Общий расход (без привязки) --</option>
                            ${shiftOptions}
                        </select>
                    </div>
                `;
            } else {
                // Если активных смен нет, сообщаем об этом
                shiftSelectorHtml = `<p class="text-sm text-gray-500">Нет активных смен для привязки. Расход будет добавлен как общий.</p>`;
            }
        } else {
            // Для обычного сотрудника показываем ID его текущей смены
             shiftSelectorHtml = `<p class="text-sm text-gray-600">Смена ID: ${activeShift?.id ?? 'N/A'}</p>`;
        }
        // --- КОНЕЦ ГЕНЕРАЦИИ СПИСКА СМЕН ---

        modalContent.innerHTML = `
            <div class="flex justify-between items-start">
                <h3 class="text-2xl font-bold mb-4">${isEdit ? 'Редактировать расход' : 'Добавить расход'}</h3>
                <button onclick="closeModal('expense-modal')" class="text-2xl font-bold">&times;</button>
            </div>
            <form id="expense-form" data-expense-id="${isEdit ? expense.id : ''}" class="space-y-4">
                
                ${shiftSelectorHtml}
                
                <div>
                    <label class="block text-sm font-medium text-gray-700">Тип расхода *</label>
                    <select name="expense_type_id" class="mt-1 w-full p-2 border rounded bg-white" required>${typesOptions}</select>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700">Сумма (сом) *</label>
                    <input type="number" step="0.01" name="amount" class="mt-1 w-full p-2 border rounded" value="${isEdit ? expense.amount : ''}" required>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700">Примечание</label>
                    <textarea name="notes" class="mt-1 w-full p-2 border rounded">${isEdit ? expense.notes || '' : ''}</textarea>
                </div>
                <div class="flex gap-4 mt-6">
                    <button type="button" onclick="closeModal('expense-modal')" class="w-full bg-gray-200 py-2 rounded">Отмена</button>
                    <button type="submit" class="w-full bg-green-600 text-white py-2 rounded">Сохранить</button>
                </div>
            </form>
        `;
        
        // Привязываем обработчик submit к форме
        document.getElementById('expense-form')?.addEventListener('submit', handleSaveExpense);
        
    } catch(err) {
        alert(`Ошибка загрузки данных для расхода: ${err.message}`);
        closeModal('expense-modal');
    } finally {
        hideLoader();
    }
}

// --- Функция сохранения расхода ---
// index.html (Полностью заменяет handleSaveExpense)

async function handleSaveExpense(e) {
    e.preventDefault();
    const form = e.target;
    const expenseId = form.dataset.expenseId; // Исправлено с expense-id
    const isEdit = !!expenseId;
    
    const url = isEdit ? `/api/expenses/${expenseId}` : '/api/expenses'; 
    const method = isEdit ? 'PATCH' : 'POST'; 
    
    const payload = {
        expense_type_id: parseInt(form.elements.expense_type_id.value),
        amount: parseFloat(form.elements.amount.value),
        notes: form.elements.notes.value || null
        // shift_id будет добавлен ниже, если выбран
    };

    // --- ДОБАВЛЕНИЕ SHIFT_ID ДЛЯ ВЛАДЕЛЬЦА ---
    if (currentUser.role === 'Владелец' && !isEdit) { // Добавляем shift_id только при СОЗДАНИИ Владельцем
        const shiftSelect = document.getElementById('expense-shift-select');
        if (shiftSelect && shiftSelect.value) { // Если select существует и выбрано значение (не пустое)
            payload.shift_id = parseInt(shiftSelect.value); 
        } else {
            payload.shift_id = null; // Если выбрано "-- Общий расход --" или смен не было
        }
    }
    // Для обычных сотрудников shift_id определяется на бэкенде
    // При редактировании shift_id не меняем через эту форму
    // --- КОНЕЦ ДОБАВЛЕНИЯ SHIFT_ID ---

    if (isNaN(payload.amount) || payload.amount <= 0 || isNaN(payload.expense_type_id)) {
        alert("Пожалуйста, введите корректную сумму и выберите тип расхода.");
        return;
    }

    showLoader(); 
    try {
        const response = await apiFetch(url, {
            method: method,
            body: JSON.stringify(payload)
        });
        
        alert(isEdit ? 'Расход обновлен!' : 'Расход успешно добавлен!');
        closeModal('expense-modal');
        await fetchAndRenderExpenses(); // Обновляем список на вкладке
        
    } catch (err) {
        alert(`Ошибка: ${err.message}`);
    } finally {
        hideLoader();
    }
}

// index.html (ПОЛНОСТЬЮ ЗАМЕНЯЕТ МОДУЛЬ: ОТЧЕТЫ)

// =================================================================
// МОДУЛЬ: ОТЧЕТЫ (v4.1 - Rebuild)
// =================================================================

// --- Рендеринг главной вкладки "Отчеты" (создает под-вкладки) ---
function renderReportsTab() {
    console.log("[Render] renderReportsTab: Start");
    const pane = document.getElementById('tab-reports');
    if (!pane) return;

    const userPerms = new Set(currentUser.permissions || []);
    let subTabsHtml = '';
    let subContentHtml = '';
    let firstSubTabName = null; // Имя первой доступной под-вкладки

    // Создаем под-вкладки на основе прав
    // Отчет по смене
    if (userPerms.has('view_shift_report')) {
        subTabsHtml += '<button data-subtab="shift-report" class="report-subtab-btn tab-btn">Отчет по смене</button>';
        subContentHtml += '<div id="subtab-shift-report" class="report-subtab-pane tab-pane"></div>';
        if (!firstSubTabName) firstSubTabName = 'shift-report';
    }
    // Сводный отчет
    if (userPerms.has('view_full_reports')) {
        subTabsHtml += '<button data-subtab="summary-report" class="report-subtab-btn tab-btn">Сводный отчет</button>';
        subContentHtml += '<div id="subtab-summary-report" class="report-subtab-pane tab-pane"></div>';
        if (!firstSubTabName) firstSubTabName = 'summary-report';

        // --- ДОБАВИТЬ ЭТОТ БЛОК ---
        // Отчет по выкупу (добавляем сюда же, так как требует прав на полные отчеты)
        subTabsHtml += '<button data-subtab="buyout-report" class="report-subtab-btn tab-btn">Отчет по выкупу</button>';
        subContentHtml += '<div id="subtab-buyout-report" class="report-subtab-pane tab-pane"></div>';
        if (!firstSubTabName) firstSubTabName = 'buyout-report';
        // --- КОНЕЦ ДОБАВЛЕНИЯ ---
    }

    // Генерируем HTML для под-вкладок и их контейнеров
    pane.innerHTML = `
        <div class="border-b border-gray-200">
            <nav class="-mb-px flex space-x-8" id="reports-subtabs">
                ${subTabsHtml.replaceAll('class="tab-btn"', 'class="tab-btn whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm border-transparent text-gray-500 hover:text-gray-700"')}
            </nav>
        </div>
        <div id="reports-subtab-content" class="mt-6">
            ${subContentHtml}
        </div>
    `;

    // Привязываем слушатель к под-вкладкам
    const subtabsContainer = document.getElementById('reports-subtabs');
    if (subtabsContainer) {
        // Используем replaceWith/cloneNode для удаления старых слушателей (на всякий случай)
        const newSubtabsContainer = subtabsContainer.cloneNode(true);
        subtabsContainer.parentNode?.replaceChild(newSubtabsContainer, subtabsContainer);
        // Добавляем слушатель к новому контейнеру
        newSubtabsContainer.addEventListener('click', e => {
            const tabButton = e.target.closest('.report-subtab-btn');
            if (tabButton) {
                activateReportSubTab(tabButton.dataset.subtab); // Активируем под-вкладку
            }
        });
        console.log("[Listener OK] Added click delegate to #reports-subtabs");
    }

    // Рендерим содержимое ВСЕХ под-вкладок (они теперь точно найдутся)
    if (document.getElementById('subtab-shift-report')) {
        renderShiftReportSubTab();
    }
    if (document.getElementById('subtab-summary-report')) {
        renderSummaryReportSubTab();
    }
    // --- ДОБАВИТЬ ВЫЗОВ РЕНДЕРИНГА ДЛЯ НОВОЙ ВКЛАДКИ ---
    if (document.getElementById('subtab-buyout-report')) {
        renderBuyoutReportSubTab(); // Вызываем новую функцию рендеринга
    }
    // --- КОНЕЦ ДОБАВЛЕНИЯ ---

    // Активируем первую доступную под-вкладку
    if (firstSubTabName) {
        // Небольшая задержка, чтобы DOM успел обновиться перед активацией
        setTimeout(() => activateReportSubTab(firstSubTabName), 0);
    } else {
        console.warn("[Render Reports] No sub-tabs available to activate.");
    }
    console.log("[Render] renderReportsTab: End");
}

// --- Активация под-вкладок ---
function activateReportSubTab(tabName) {
    const tabsContainer = document.getElementById('reports-subtabs');
    const contentContainer = document.getElementById('reports-subtab-content');
    if (!tabsContainer || !contentContainer) return;

    tabsContainer.querySelectorAll('.report-subtab-btn').forEach(btn => {
        btn.classList.remove('border-indigo-500', 'text-indigo-600');
        btn.classList.add('border-transparent', 'text-gray-500');
    });
    
    const activeBtn = tabsContainer.querySelector(`[data-subtab="${tabName}"]`);
    if (activeBtn) {
        activeBtn.classList.add('border-indigo-500', 'text-indigo-600');
        activeBtn.classList.remove('border-transparent', 'text-gray-500');
    }

    contentContainer.querySelectorAll('.report-subtab-pane').forEach(pane => {
        pane.classList.add('hidden');
    });
    
    const activePane = document.getElementById(`subtab-${tabName}`);
    if (activePane) {
        activePane.classList.remove('hidden');
    }
}

// --- Рендеринг под-вкладки "Отчет по смене" ---
function renderShiftReportSubTab() {
    const pane = document.getElementById('subtab-shift-report');
    if (!pane) return;

    // --- ИСПРАВЛЕНИЕ: HTML для фильтра филиалов (только Владелец) ---
    // (companyLocations теперь гарантированно загружен из initializeMainAppUI)
    let locationFilterHtml = '';
    if (currentUser.role === 'Владелец' && companyLocations && companyLocations.length > 1) {
        const locationOptions = companyLocations.map(loc =>
            // Предварительно выбираем основной филиал Владельца
            `<option value="${loc.id}" ${loc.id === currentUser.location_id ? 'selected' : ''}>${loc.name}</option>`
        ).join('');
        
        locationFilterHtml = `
            <div class="flex-shrink-0">
                <label for="shift-report-location-filter" class="text-xs font-medium text-gray-700">Филиал:</label>
                <select id="shift-report-location-filter" class="rounded-md border-gray-300 p-1.5 text-sm bg-white shadow-sm w-40">
                    ${locationOptions}
                </select>
            </div>
        `;
        console.log("[Render ShiftReport] Фильтр филиалов добавлен.");
    }
    // --- КОНЕЦ ИСПРАВЛЕНИЯ ---

    pane.innerHTML = `
        <div class="bg-white p-6 rounded-lg shadow-md max-w-2xl mx-auto">
            <div class="flex flex-wrap justify-between items-center gap-4 mb-4 border-b pb-4">
                <h2 class="text-2xl font-bold">Отчет по текущей смене</h2>
                <div class="flex items-center gap-4">
                    ${locationFilterHtml} 
                    <button id="refresh-report-btn" title="Обновить отчет" class="text-2xl text-gray-500 hover:text-indigo-600">&circlearrowright;</button>
                </div>
            </div>
            <div id="shift-report-content" class="space-y-3">
                <p class="animate-pulse">Загрузка отчета...</p>
            </div>
        </div>
    `;
    
    document.getElementById('refresh-report-btn')?.addEventListener('click', fetchAndRenderCurrentShiftReport);
    // Добавляем слушатель к новому фильтру (если он есть)
    document.getElementById('shift-report-location-filter')?.addEventListener('change', fetchAndRenderCurrentShiftReport);

    fetchAndRenderCurrentShiftReport(); // Загружаем при первом рендере
}

// --- Загрузка отчета по ТЕКУЩЕЙ смене ---
async function fetchAndRenderCurrentShiftReport() {
    const contentDiv = document.getElementById('shift-report-content');
    if (!contentDiv) return;
    contentDiv.innerHTML = '<p class="animate-pulse">Обновление отчета...</p>';
    showLoader();

    // --- ИСПРАВЛЕНИЕ: Определяем, какой URL вызывать ---
    let url = ''; 
    
    if (currentUser.role === 'Владелец') {
        const locationSelect = document.getElementById('shift-report-location-filter');
        let locationIdToFetch = currentUser.location_id; // По умолчанию филиал Владельца

        if (locationSelect && locationSelect.value) {
            // Если Владелец выбрал филиал в списке
            locationIdToFetch = locationSelect.value;
        }
        
        if (locationIdToFetch) {
             url = `/api/reports/shift/location/${locationIdToFetch}`;
        } else {
             // Если Владелец не привязан к филиалу и ничего не выбрал
             contentDiv.innerHTML = `<p class="text-yellow-500 font-semibold">Ошибка: Владелец не привязан к филиалу. Выберите филиал из списка (если он есть).</p>`;
             hideLoader();
             return;
        }
        
    } else {
        // Обычный сотрудник (не Владелец)
        url = '/api/reports/shift/current'; // Бэкенд сам найдет его смену
    }
    
    console.log("[Shift Report] Requesting URL:", url);
    // --- КОНЕЦ ИСПРАВЛЕНИЯ ---

    try {
        const report = await apiFetch(url); 

        contentDiv.innerHTML = `
            <div class="text-sm text-gray-500">
                <p><strong>Сотрудник:</strong> ${report.employee_name || '?'}</p>
                <p><strong>Филиал:</strong> ${report.location_name || '?'}</p>
                <p><strong>Смена открыта:</strong> ${new Date(report.shift_start_time).toLocaleString()}</p>
            </div>
            <div class="border-t pt-4 mt-4 space-y-2 text-lg">
                <div class="flex justify-between"><span>Наличные на начало:</span> <span class="font-semibold">${report.starting_cash.toFixed(2)} сом</span></div>
                <div class="flex justify-between text-green-600"><span>Приход наличными (+):</span> <span class="font-semibold">${report.cash_income.toFixed(2)} сом</span></div>
                <div class="flex justify-between text-blue-600"><span>Приход по карте (+):</span> <span class="font-semibold">${report.card_income.toFixed(2)} сом</span></div>
                <div class="flex justify-between text-red-600"><span>Расходы (операционные) (-):</span> <span class="font-semibold">${report.total_expenses.toFixed(2)} сом</span></div>
                <div class="flex justify-between text-yellow-600"><span>Возвраты (-):</span> <span class="font-semibold">${report.total_returns.toFixed(2)} сом</span></div>
            </div>
            <div class="border-t pt-4 mt-4">
                <div class="flex justify-between text-xl font-bold">
                    <span>Итого в кассе (расчет):</span>
                    <span>${report.calculated_cash.toFixed(2)} сом</span>
                </div>
            </div>
        `;
    } catch (e) {
        // Если 404 - смены нет, если 403 - нет прав
        contentDiv.innerHTML = `<p class="text-red-500 font-semibold">Ошибка загрузки отчета: ${e.message}</p>`;
    } finally {
        hideLoader();
    }
}

// --- Рендеринг под-вкладки "Сводный отчет" ---
function renderSummaryReportSubTab() {
    console.log("[Render] renderSummaryReportSubTab: Start");
    const pane = document.getElementById('subtab-summary-report'); // Находим контейнер под-вкладки
    // Если контейнер не найден, выходим
    if (!pane) {
         console.warn("[Render] renderSummaryReportSubTab: Pane #subtab-summary-report not found.");
         return;
    }
    const today = new Date().toISOString().split('T')[0]; // Сегодняшняя дата

    // --- HTML для фильтра филиалов (только для Владельца) ---
    let locationFilterHtml = ''; // Инициализируем пустой строкой
    // Показываем, если пользователь Владелец И есть больше одного филиала в кэше
    if (currentUser.role === 'Владелец' && companyLocations && companyLocations.length > 1) {
        // Генерируем <option> для каждого филиала
        const locationOptions = companyLocations.map(loc =>
            // Атрибут value содержит ID, текст - название филиала
            `<option value="${loc.id}">${loc.name}</option>`
        ).join('');
        // Формируем HTML для select'а
        locationFilterHtml = `
            <div>
                <label for="summary-location-filter" class="block text-sm font-medium text-gray-700">Филиал:</label>
                <select id="summary-location-filter" class="mt-1 p-2 border rounded-md bg-white text-sm w-full">
                    <option value="">-- Все филиалы --</option> ${locationOptions} </select>
            </div>
        `;
        console.log("[Render Summary] Фильтр филиалов для Владельца добавлен.");
    } else {
         console.log("[Render Summary] Фильтр филиалов не требуется.");
    }
    // --- КОНЕЦ HTML ФИЛЬТРА ---

    // Генерируем основной HTML для под-вкладки
    pane.innerHTML = `
        <div class="bg-white p-6 rounded-lg shadow-md max-w-3xl mx-auto">
            <h2 class="text-2xl font-bold mb-4">Сводный отчет</h2>
            <div class="flex flex-wrap gap-4 items-end p-4 bg-gray-50 rounded-lg mb-4 border">
                <div>
                    <label for="summary-start-date" class="block text-sm font-medium">С</label>
                    <input type="date" id="summary-start-date" value="${today}" class="mt-1 p-2 border rounded-md">
                </div>
                <div>
                    <label for="summary-end-date" class="block text-sm font-medium">По</label>
                    <input type="date" id="summary-end-date" value="${today}" class="mt-1 p-2 border rounded-md">
                </div>
                ${locationFilterHtml}
                <button id="generate-summary-report-btn" class="bg-blue-600 text-white py-2 px-4 rounded-md ml-auto">Сформировать</button>
            </div>
            <div id="summary-report-content">
                <p class="text-gray-500">Выберите период и нажмите "Сформировать".</p>
            </div>
        </div>
    `;

    // --- Добавляем слушатели к ТОЛЬКО ЧТО созданным элементам ---
    // Кнопка "Сформировать"
    const generateBtn = document.getElementById('generate-summary-report-btn');
    if (generateBtn) {
        generateBtn.addEventListener('click', fetchAndRenderSummaryReport);
        console.log("[Listener OK] Added click to #generate-summary-report-btn");
    }

    // Фильтр филиалов (если он был создан)
    const locationSelect = document.getElementById('summary-location-filter');
    if (locationSelect) {
         // Добавляем слушатель 'change', который будет вызывать `fetchAndRenderSummaryReport`
         // Это позволит отчету обновляться сразу при смене филиала (опционально, можно оставить только кнопку "Сформировать")
        locationSelect.addEventListener('change', fetchAndRenderSummaryReport);
        console.log("[Listener OK] Added change to #summary-location-filter");
    }

    console.log("[Render] renderSummaryReportSubTab: End");
}

// --- Рендеринг под-вкладки "Отчет по выкупу" ---
function renderBuyoutReportSubTab() {
    console.log("[Render] renderBuyoutReportSubTab: Start");
    const pane = document.getElementById('subtab-buyout-report'); // Находим контейнер
    if (!pane) {
        console.warn("[Render] renderBuyoutReportSubTab: Pane #subtab-buyout-report not found.");
        return;
    }
    const today = new Date().toISOString().split('T')[0]; // Сегодняшняя дата

    // Фильтр филиалов (аналогично Сводному отчету)
    let locationFilterHtml = '';
    if (currentUser.role === 'Владелец' && companyLocations && companyLocations.length > 1) {
        const locationOptions = companyLocations.map(loc =>
            `<option value="${loc.id}">${loc.name}</option>`
        ).join('');
        locationFilterHtml = `
            <div>
                <label for="buyout-location-filter" class="block text-sm font-medium text-gray-700">Филиал:</label>
                <select id="buyout-location-filter" class="mt-1 p-2 border rounded-md bg-white text-sm w-full">
                    <option value="">-- Все филиалы --</option>
                    ${locationOptions}
                </select>
            </div>
        `;
    }

    // Генерируем HTML для под-вкладки
    pane.innerHTML = `
        <div class="bg-white p-6 rounded-lg shadow-md"> <h2 class="text-2xl font-bold mb-4">Отчет по выкупам и курсовой разнице</h2>
            <div class="flex flex-wrap gap-4 items-end p-4 bg-gray-50 rounded-lg mb-4 border">
                <div>
                    <label for="buyout-start-date" class="block text-sm font-medium">С</label>
                    <input type="date" id="buyout-start-date" value="${today}" class="mt-1 p-2 border rounded-md">
                </div>
                <div>
                    <label for="buyout-end-date" class="block text-sm font-medium">По</label>
                    <input type="date" id="buyout-end-date" value="${today}" class="mt-1 p-2 border rounded-md">
                </div>
                ${locationFilterHtml} <button id="generate-buyout-report-btn" class="bg-blue-600 text-white py-2 px-4 rounded-md ml-auto">Сформировать</button>
            </div>
            <div class="mb-4">
                <input type="search" id="buyout-report-search-input" placeholder="🔍 Поиск по клиенту, трек-коду..." class="w-full p-2 border rounded-lg">
            </div>
            <div id="buyout-report-content" class="overflow-x-auto"> <p class="text-gray-500">Выберите период и нажмите "Сформировать".</p>
            </div>
        </div>
    `;

    // --- Добавляем слушатели ---
    const generateBtn = document.getElementById('generate-buyout-report-btn');
    if (generateBtn) {
        generateBtn.addEventListener('click', fetchAndRenderBuyoutReport);
        console.log("[Listener OK] Added click to #generate-buyout-report-btn");
    }
    const searchInput = document.getElementById('buyout-report-search-input');
    if (searchInput) {
        searchInput.addEventListener('input', handleBuyoutReportSearch); // Нужна функция handleBuyoutReportSearch
        console.log("[Listener OK] Added input to #buyout-report-search-input");
    }
    const locationSelect = document.getElementById('buyout-location-filter');
    if (locationSelect) {
        locationSelect.addEventListener('change', fetchAndRenderBuyoutReport);
        console.log("[Listener OK] Added change to #buyout-location-filter");
    }

    console.log("[Render] renderBuyoutReportSubTab: End");
    // Не загружаем отчет сразу, ждем нажатия кнопки "Сформировать"
}

// --- Рендеринг под-вкладки "Отчет по выкупу" ---
function renderBuyoutReportSubTab() {
    console.log("[Render] renderBuyoutReportSubTab: Start");
    const pane = document.getElementById('subtab-buyout-report'); // Находим контейнер
    if (!pane) {
        console.warn("[Render] renderBuyoutReportSubTab: Pane #subtab-buyout-report not found.");
        return;
    }
    const today = new Date().toISOString().split('T')[0]; // Сегодняшняя дата

    // Фильтр филиалов (аналогично Сводному отчету)
    let locationFilterHtml = '';
    if (currentUser.role === 'Владелец' && companyLocations && companyLocations.length > 1) {
        const locationOptions = companyLocations.map(loc =>
            `<option value="${loc.id}">${loc.name}</option>`
        ).join('');
        locationFilterHtml = `
            <div>
                <label for="buyout-location-filter" class="block text-sm font-medium text-gray-700">Филиал:</label>
                <select id="buyout-location-filter" class="mt-1 p-2 border rounded-md bg-white text-sm w-full">
                    <option value="">-- Все филиалы --</option>
                    ${locationOptions}
                </select>
            </div>
        `;
    }

    // Генерируем HTML для под-вкладки
    pane.innerHTML = `
        <div class="bg-white p-6 rounded-lg shadow-md"> <h2 class="text-2xl font-bold mb-4">Отчет по выкупам и курсовой разнице</h2>
            <div class="flex flex-wrap gap-4 items-end p-4 bg-gray-50 rounded-lg mb-4 border">
                <div>
                    <label for="buyout-start-date" class="block text-sm font-medium">С</label>
                    <input type="date" id="buyout-start-date" value="${today}" class="mt-1 p-2 border rounded-md">
                </div>
                <div>
                    <label for="buyout-end-date" class="block text-sm font-medium">По</label>
                    <input type="date" id="buyout-end-date" value="${today}" class="mt-1 p-2 border rounded-md">
                </div>
                ${locationFilterHtml} <button id="generate-buyout-report-btn" class="bg-blue-600 text-white py-2 px-4 rounded-md ml-auto">Сформировать</button>
            </div>
            <div class="mb-4">
                <input type="search" id="buyout-report-search-input" placeholder="🔍 Поиск по клиенту, трек-коду..." class="w-full p-2 border rounded-lg">
            </div>
            <div id="buyout-report-content" class="overflow-x-auto"> <p class="text-gray-500">Выберите период и нажмите "Сформировать".</p>
            </div>
        </div>
    `;

    // --- Добавляем слушатели ---
    const generateBtn = document.getElementById('generate-buyout-report-btn');
    if (generateBtn) {
        generateBtn.addEventListener('click', fetchAndRenderBuyoutReport);
        console.log("[Listener OK] Added click to #generate-buyout-report-btn");
    }
    const searchInput = document.getElementById('buyout-report-search-input');
    if (searchInput) {
        searchInput.addEventListener('input', handleBuyoutReportSearch); // Нужна функция handleBuyoutReportSearch
        console.log("[Listener OK] Added input to #buyout-report-search-input");
    }
    const locationSelect = document.getElementById('buyout-location-filter');
    if (locationSelect) {
        locationSelect.addEventListener('change', fetchAndRenderBuyoutReport);
        console.log("[Listener OK] Added change to #buyout-location-filter");
    }

    console.log("[Render] renderBuyoutReportSubTab: End");
    // Не загружаем отчет сразу, ждем нажатия кнопки "Сформировать"
}

// --- Загрузка Сводного отчета ---
async function fetchAndRenderSummaryReport() {
    console.log("[Fetch] fetchAndRenderSummaryReport: Start");
    // Находим контейнер для вывода результата
    const contentDiv = document.getElementById('summary-report-content');
    // Находим поля с датами
    const startDateInput = document.getElementById('summary-start-date');
    const endDateInput = document.getElementById('summary-end-date');

    // Проверяем наличие элементов
    if (!contentDiv || !startDateInput || !endDateInput) {
        console.error("!!! fetchAndRenderSummaryReport: Critical elements not found.");
        return;
    }
    // Получаем значения дат
    const startDate = startDateInput.value;
    const endDate = endDateInput.value;
    // Проверяем, выбраны ли даты
    if (!startDate || !endDate) {
        contentDiv.innerHTML = '<p class="text-yellow-500">Пожалуйста, выберите даты начала и конца периода.</p>';
        return;
    }

    // Показываем заглушку и лоадер
    contentDiv.innerHTML = '<p class="animate-pulse">Формирование отчета...</p>';
    showLoader();

    // --- ДОБАВИТЬ: Считываем выбранный location_id ---
    // Создаем объект URLSearchParams
    const params = new URLSearchParams({
        start_date: startDate,
        end_date: endDate
    });
    // Ищем select филиалов
    const locationSelect = document.getElementById('summary-location-filter');
    // Если select существует (т.е. пользователь - Владелец и филиалов > 1)
    // И если выбрано значение (не пустая опция "-- Все филиалы --")
    if (locationSelect && locationSelect.value) {
        // Добавляем параметр location_id к запросу
        params.append('location_id', locationSelect.value);
        console.log("[Fetch Summary] Filtering by location_id:", locationSelect.value);
    } else if (currentUser.role === 'Владелец') {
        console.log("[Fetch Summary] Owner viewing summary for ALL locations.");
    }
    // Формируем URL с параметрами
    const url = `/api/reports/summary?${params.toString()}`;
    console.log("[Fetch Summary] Requesting URL:", url);
    // --- КОНЕЦ ДОБАВЛЕНИЯ ---

    try {
        // Выполняем запрос к API с помощью apiFetch
        const response = await apiFetch(url); // Используем URL с параметрами
        // Извлекаем данные отчета из ответа
        const summary = response.summary;

        // Генерируем HTML для блока с расходами по типам
        let expensesHtml = Object.entries(summary.expenses_by_type)
            // Для каждой пары [тип, сумма] создаем div
            .map(([type, amount]) => `<div class="flex justify-between text-sm text-gray-700 ml-4"><span>- ${type}:</span><span>${amount.toFixed(2)} сом</span></div>`)
            .join(''); // Соединяем все div'ы в одну строку
        // Если блок пустой, показываем сообщение
        if (!expensesHtml) expensesHtml = '<p class="text-sm text-gray-500 ml-4">Расходов за период нет.</p>';

        // Генерируем HTML для блока со списком смен
        let shiftsHtml = '<h3 class="text-xl font-bold mt-6 mb-2">Закрытые смены за период</h3>';
        // Проверяем, есть ли смены в ответе
        if (!summary.shifts || summary.shifts.length === 0) {
            shiftsHtml += '<p class="text-gray-500">Закрытых смен за этот период не найдено.</p>';
        } else {
            // Для каждой смены генерируем div с информацией и кнопкой
            shiftsHtml += summary.shifts.map(shift => {
                // Получаем имя сотрудника и филиала (если они есть)
                const employeeName = shift.employee?.full_name || 'Неизвестен';
                const locationName = shift.location?.name || 'Филиал ?';
                // Форматируем даты начала и конца смены
                const startTimeStr = shift.start_time ? new Date(shift.start_time).toLocaleString('ru-RU') : '?';
                const endTimeStr = shift.end_time ? new Date(shift.end_time).toLocaleString('ru-RU') : 'АКТИВНА';

                // Возвращаем HTML для одной смены
                return `
                    <div class="p-2 border rounded-md hover:bg-gray-50 flex justify-between items-center text-sm mb-2"> <div>
                            <p><strong>${employeeName}</strong> @ ${locationName}</p>
                            <p class="text-xs text-gray-500">${startTimeStr} - ${endTimeStr}</p>
                        </div>
                        <button class="view-shift-report-btn bg-blue-100 text-blue-800 text-xs px-3 py-1 rounded-full" data-shift-id="${shift.id}">Подробнее</button>
                    </div>
                `;
            }).join(''); // Соединяем HTML всех смен
        }

        // Рендерим весь HTML отчета в contentDiv
        contentDiv.innerHTML = `
            <div class="border rounded-lg p-4 mb-6 bg-gray-50"> <h3 class="text-lg font-semibold mb-3 text-gray-700">Финансовые показатели:</h3>
                <div class="space-y-2"> <div class="flex justify-between text-green-600"><span>Общая выручка (+):</span><span class="font-bold">${summary.total_income.toFixed(2)} сом</span></div>
                    <div class="flex justify-between text-sm text-gray-700 ml-4"><span>(Наличными):</span><span>${summary.total_cash_income.toFixed(2)} сом</span></div>
                    <div class="flex justify-between text-sm text-gray-700 ml-4"><span>(Картой):</span><span>${summary.total_card_income.toFixed(2)} сом</span></div>

                    <div class="flex justify-between text-red-600 pt-2"><span>Общие расходы (-):</span><span class="font-bold">${summary.total_expenses.toFixed(2)} сом</span></div>
                    ${expensesHtml} </div>
            </div>
            <div class="border-t pt-4"> <div class="flex justify-between text-2xl font-bold ${summary.net_profit >= 0 ? 'text-green-700' : 'text-red-700'}">
                    <span>Чистая прибыль:</span><span>${summary.net_profit.toFixed(2)} сом</span>
                </div>
            </div>
            <div class="mt-6"> ${shiftsHtml} </div>
        `;

        // Привязываем слушатели к ТОЛЬКО ЧТО созданным кнопкам "Подробнее"
        contentDiv.querySelectorAll('.view-shift-report-btn').forEach(btn => {
            // Используем replaceWith/cloneNode для удаления старых слушателей (на всякий случай)
            const newBtn = btn.cloneNode(true);
            btn.parentNode?.replaceChild(newBtn, btn);
            // Добавляем слушатель к новой кнопке
            newBtn.addEventListener('click', (e) => {
                const shiftId = e.target.dataset.shiftId; // Получаем ID смены из data-атрибута
                showPastShiftReportModal(shiftId); // Вызываем функцию показа модального окна для этой смены
            });
        });
        console.log("[Fetch Summary] Report rendered successfully.");

    } catch (e) { // Обработка ошибок при запросе к API
        console.error("!!! [Fetch Summary] Error fetching or rendering summary report:", e);
        contentDiv.innerHTML = `<p class="text-red-500">Ошибка загрузки сводного отчета: ${e.message}</p>`;
    } finally {
        // Скрываем глобальный лоадер в любом случае
        hideLoader();
        console.log("[Fetch] fetchAndRenderSummaryReport: End");
    }
}

// --- Загрузка и рендеринг Отчета по выкупу ---
async function fetchAndRenderBuyoutReport() {
    console.log("[Fetch] fetchAndRenderBuyoutReport: Start");
    const contentDiv = document.getElementById('buyout-report-content');
    const startDateInput = document.getElementById('buyout-start-date');
    const endDateInput = document.getElementById('buyout-end-date');
    if (!contentDiv || !startDateInput || !endDateInput) return; // Проверка

    const startDate = startDateInput.value;
    const endDate = endDateInput.value;
    if (!startDate || !endDate) {
        contentDiv.innerHTML = '<p class="text-yellow-500">Выберите даты.</p>';
        return;
    }

    contentDiv.innerHTML = '<p class="animate-pulse">Формирование отчета по выкупу...</p>';
    showLoader();

    // --- Формируем URL с параметрами ---
    const params = new URLSearchParams({
        start_date: startDate,
        end_date: endDate
    });
    // Добавляем location_id (аналогично Сводному отчету)
    const locationSelect = document.getElementById('buyout-location-filter');
    if (locationSelect && locationSelect.value) {
        params.append('location_id', locationSelect.value);
        console.log("[Fetch Buyout] Filtering by location_id:", locationSelect.value);
    } else if (currentUser.role === 'Владелец') {
        console.log("[Fetch Buyout] Owner viewing buyout for ALL locations.");
    }
    // Используем РЕАЛЬНЫЙ URL эндпоинта
    const url = `/api/reports/buyout?${params.toString()}`;
    console.log("[Fetch Buyout] Requesting URL:", url);
    // --- Конец формирования URL ---

    try {
        // --- ЗАПРОС К API ---
        const response = await apiFetch(url); // Выполняем запрос
        // Извлекаем данные из ответа бэкенда
        const { items, total_profit } = response.report;
        // --- КОНЕЦ ЗАПРОСА К API ---


        if (!items || items.length === 0) {
            contentDiv.innerHTML = '<p class="text-gray-500">Заказов на выкуп за выбранный период (с учетом фильтра) нет.</p>';
            return;
        }

        // Генерируем строки таблицы
        const rowsHtml = items.map(item => `
            <tr class="border-b text-sm hover:bg-gray-50 buyout-report-row">
                <td class="p-2 whitespace-nowrap">${new Date(item.created_at).toLocaleDateString('ru-RU')}</td>
                <td class="p-2">${item.client_name || '?'}</td>
                <td class="p-2">${item.track_code || '?'}</td>
                <td class="p-2 text-right">${item.item_cost_cny?.toFixed(2) || '-'}</td>
                <td class="p-2 text-right">${item.rate_for_client?.toFixed(2) || '-'}</td>
                <td class="p-2 text-right font-semibold">${item.price_for_client?.toFixed(2) || '-'}</td>
                <td class="p-2 text-right">${item.actual_rate?.toFixed(2) || 'Не указан'}</td>
                <td class="p-2 text-right">${item.actual_cost?.toFixed(2) || '-'}</td>
                <td class="p-2 text-right font-bold ${item.profit >= 0 ? 'text-green-600' : 'text-red-600'}">${item.profit?.toFixed(2) || '0.00'}</td>
            </tr>
        `).join('');

        // Генерируем HTML всей таблицы и итоговой суммы
        contentDiv.innerHTML = `
            <table class="w-full min-w-[900px]"> <thead class="bg-gray-100 sticky top-0"> <tr class="text-left text-xs font-bold uppercase text-gray-600">
                        <th class="p-2">Дата</th>
                        <th class="p-2">Клиент</th>
                        <th class="p-2">Трек</th>
                        <th class="p-2 text-right">Цена(CNY)</th>
                        <th class="p-2 text-right">Курс(клиент)</th>
                        <th class="p-2 text-right">Цена(клиент)</th>
                        <th class="p-2 text-right">Реал. курс</th>
                        <th class="p-2 text-right">Себестоимость</th>
                        <th class="p-2 text-right">Прибыль</th>
                    </tr>
                </thead>
                <tbody>${rowsHtml}</tbody>
            </table>
            <div class="mt-4 text-right border-t pt-4">
                <span class="text-lg font-bold">Итоговая прибыль от курсовой разницы:</span>
                <span id="buyout-total-profit" class="text-xl font-bold ${total_profit >= 0 ? 'text-green-700' : 'text-red-700'}">${total_profit.toFixed(2)} сом</span>
            </div>
        `;
        console.log("[Fetch Buyout] Report rendered with REAL data.");

    } catch (e) { // Обработка ошибок
        console.error("!!! [Fetch Buyout] Error fetching or rendering buyout report:", e);
        contentDiv.innerHTML = `<p class="text-red-500">Ошибка загрузки отчета по выкупу: ${e.message}</p>`;
    } finally {
        // Скрываем лоадер
        hideLoader();
        console.log("[Fetch] fetchAndRenderBuyoutReport: End");
    }
}

// --- Функция поиска по Отчету о выкупе ---
function handleBuyoutReportSearch(e) {
    const searchTerm = e.target.value.toLowerCase().trim();
    console.log(`[Search Buyout] Term: "${searchTerm}"`);
    let visibleProfit = 0; // Переменная для подсчета прибыли видимых строк

    // Находим все строки таблицы (кроме шапки)
    document.querySelectorAll('#buyout-report-content table tbody tr.buyout-report-row').forEach(row => {
        const rowContent = row.textContent?.toLowerCase() || ''; // Получаем текст всей строки
        // Проверяем, содержит ли строка поисковый запрос
        const isMatch = rowContent.includes(searchTerm);
        // Показываем или скрываем строку
        row.style.display = isMatch ? '' : 'none';
        // Если строка видима, добавляем ее прибыль к общей видимой прибыли
        if (isMatch) {
            // Находим ячейку с прибылью (последняя td)
            const profitCell = row.querySelector('td:last-child');
            if (profitCell) {
                visibleProfit += parseFloat(profitCell.textContent) || 0; // Добавляем значение
            }
        }
    });

    // Обновляем отображение итоговой прибыли ТОЛЬКО для видимых строк
    const totalProfitSpan = document.getElementById('buyout-total-profit');
    if (totalProfitSpan) {
        totalProfitSpan.textContent = `${visibleProfit.toFixed(2)} сом`; // Показываем сумму видимых
        // Меняем цвет в зависимости от знака
        totalProfitSpan.classList.toggle('text-green-700', visibleProfit >= 0);
        totalProfitSpan.classList.toggle('text-red-700', visibleProfit < 0);
    }
    console.log(`[Search Buyout] Filtering complete. Visible profit: ${visibleProfit.toFixed(2)}`);
}

// --- Показ модального окна с отчетом по ПРОШЛОЙ смене ---
async function showPastShiftReportModal(shiftId) {
    // Убедимся, что модальное окно #shift-report-modal существует в HTML
    const modal = document.getElementById('shift-report-modal'); 
    if (!modal) return console.error("Модальное окно #shift-report-modal не найдено!");
    const contentDiv = modal.querySelector('.modal-content');
    if (!contentDiv) return console.error("Контейнер .modal-content не найден!");
    
    contentDiv.innerHTML = '<p class="animate-pulse">Загрузка отчета по смене...</p>';
    openModal('shift-report-modal');
    showLoader(); 

    try {
        const report = await apiFetch(`/api/reports/shift/${shiftId}`);

        contentDiv.innerHTML = `
            <div class="flex justify-between items-start">
                <h3 class="text-2xl font-bold mb-4">Отчет по смене №${report.shift_id}</h3>
                <button onclick="closeModal('shift-report-modal')" class="text-2xl font-bold">&times;</button>
            </div>
            <div class="text-sm text-gray-500">
                <p><strong>Сотрудник:</strong> ${report.employee_name}</p>
                <p><strong>Филиал:</strong> ${report.location_name}</p>
                <p><strong>Период:</strong> ${new Date(report.shift_start_time).toLocaleString()} - ${report.shift_end_time ? new Date(report.shift_end_time).toLocaleString() : 'АКТИВНА'}</p>
            </div>
            <div class="border-t pt-4 mt-4 space-y-2 text-lg">
                <div class="flex justify-between"><span>Наличные на начало:</span> <span class="font-semibold">${report.starting_cash.toFixed(2)} сом</span></div>
                <div class="flex justify-between text-green-600"><span>Приход наличными (+):</span> <span class="font-semibold">${report.cash_income.toFixed(2)} сом</span></div>
                <div class="flex justify-between text-blue-600"><span>Приход по карте (+):</span> <span class="font-semibold">${report.card_income.toFixed(2)} сом</span></div>
                <div class="flex justify-between text-red-600"><span>Расходы (операционные) (-):</span> <span class="font-semibold">${report.total_expenses.toFixed(2)} сом</span></div>
                <div class="flex justify-between text-yellow-600"><span>Возвраты (-):</span> <span class="font-semibold">${report.total_returns.toFixed(2)} сом</span></div>
            </div>
            <div class="border-t pt-4 mt-4 space-y-2">
                <div class="flex justify-between text-xl font-bold"><span>Итого в кассе (расчет):</span><span>${report.calculated_cash.toFixed(2)} сом</span></div>
                <div class="flex justify-between text-lg"><span>В кассе по факту (при закрытии):</span><span class="font-semibold">${report.actual_closing_cash?.toFixed(2) || 'Смена не закрыта'} сом</span></div>
                ${report.discrepancy !== null ? `
                    <div class="flex justify-between text-xl font-bold ${report.discrepancy === 0 ? 'text-green-600' : 'text-red-600'}">
                        <span>Расхождение:</span>
                        <span>${report.discrepancy.toFixed(2)} сом</span>
                    </div>
                ` : ''}
            </div>
        `;
    } catch (e) {
        contentDiv.innerHTML = `<p class="text-red-500">Ошибка загрузки отчета: ${e.message}</p>`;
    } finally {
        hideLoader();
    }
}
// === КОНЕЦ МОДУЛЯ ОТЧЕТЫ ===

// === НАЧАЛО: Логика модального окна Расчета (Адаптированная) ===

// --- Функция открытия и инициализации модального окна расчета ---
function openCalculateModal() {
    console.log("[Calculate Modal] Открытие окна расчета...");
    const calculateModal = document.getElementById('calculate-modal');
    if (!calculateModal) return; // Проверка

    // --- Сброс окна в начальное состояние ---
    // Шаг 1 (Поиск)
    const searchInput = document.getElementById('calc-client-search-input');
    if(searchInput) searchInput.value = '';
    const searchResults = document.getElementById('calc-client-search-results');
    if(searchResults) searchResults.innerHTML = '';
    if(searchResults) searchResults.classList.add('hidden'); // Убедимся, что скрыт
    const clientInfo = document.getElementById('calc-selected-client-info');
    if(clientInfo) clientInfo.classList.add('hidden');
    const clientIdInput = document.getElementById('calc-selected-client-id');
    if(clientIdInput) clientIdInput.value = '';

    // Шаг 2 (Заказы)
    const step2 = document.getElementById('calc-step-2-orders');
    if(step2) step2.classList.add('hidden');
    const ordersList = document.getElementById('calc-orders-list');
    if(ordersList) ordersList.innerHTML = '<p class="text-gray-500">Сначала выберите клиента.</p>';
    const selectAllCheckbox = document.getElementById('calc-select-all-orders');
    if(selectAllCheckbox) selectAllCheckbox.checked = false;

    // Шаг 3 (Расчет)
    const step3 = document.getElementById('calc-step-3-calculation');
    if(step3) step3.classList.add('hidden');
    const totalWeightInput = document.getElementById('calc-total-weight-input');
    if(totalWeightInput) totalWeightInput.value = '';
    const individualWeights = document.getElementById('calc-individual-weights');
    if(individualWeights) individualWeights.innerHTML = '';
    const totalCostDisplay = document.getElementById('calc-total-cost-display');
    if(totalCostDisplay) totalCostDisplay.textContent = '0.00 сом';

    // Шаг 4 (Действия)
    const step4 = document.getElementById('calc-step-4-actions');
    if(step4) step4.classList.add('hidden');

    // --- Подгрузка актуальных курсов и цены ---
    // Используем данные активной смены (если есть) или стандартные значения
    const defaultPriceInput = document.getElementById('calc-price-per-kg');
    const defaultRateInput = document.getElementById('calc-exchange-rate');
    if (defaultPriceInput) {
         defaultPriceInput.value = activeShift?.price_per_kg_usd || 5.5; // Значение по умолчанию
    }
    if (defaultRateInput) {
         defaultRateInput.value = activeShift?.exchange_rate_usd || 87.5; // Значение по умолчанию
    }

    // --- Заполнение выпадающего списка статусов ---
    const statusSelect = document.getElementById('calc-new-status-select');
    if (statusSelect) {
        // Добавляем опцию "Не менять" и все статусы из глобальной переменной orderStatuses
        statusSelect.innerHTML = '<option value="">-- Не менять --</option>' +
                                  orderStatuses.map(s => `<option value="${s}">${s}</option>`).join('');
    }

    // --- Привязка слушателей (ВАЖНО делать это здесь, чтобы избежать дублей) ---
    // Используем replaceAndListen для надежности
    const replaceAndListenCalc = (id, event, handler) => {
        const element = document.getElementById(id);
        if (element) {
            const newElement = element.cloneNode(true);
            element.parentNode?.replaceChild(newElement, element);
            newElement.addEventListener(event, handler);
            console.log(`[Calc Listener OK] Added ${event} to #${id}`);
        } else {
             console.warn(`!!! Calculate Modal: Element #${id} NOT FOUND during listener attachment.`);
        }
    };

    replaceAndListenCalc('calc-client-search-input', 'input', handleCalcClientSearch);
    replaceAndListenCalc('calc-select-all-orders', 'change', handleCalcSelectAllOrders);
    replaceAndListenCalc('save-calculation-btn', 'click', saveCalculation); // Функция сохранения

    // Слушатели для полей расчета будут добавлены в handleCalculationCheckboxChange

    // Открываем модальное окно
    openModal('calculate-modal');
    console.log("[Calculate Modal] Окно открыто и инициализировано.");
}

// --- Поиск клиента ВНУТРИ модального окна расчета ---
function handleCalcClientSearch(e) {
    const input = e.target;
    const resultsDiv = document.getElementById('calc-client-search-results');
    const selectedIdInput = document.getElementById('calc-selected-client-id');
    const clientInfoDiv = document.getElementById('calc-selected-client-info');

    // Используем универсальную функцию поиска
    handleGenericClientSearch(input, resultsDiv, (client) => {
        // Callback-функция, вызываемая при выборе клиента
        input.value = ''; // Очищаем поиск
        if(resultsDiv) resultsDiv.classList.add('hidden'); // Скрываем результаты
        if(selectedIdInput) selectedIdInput.value = client.id; // Сохраняем ID
        if(clientInfoDiv) { // Показываем инфо о выбранном клиенте
             clientInfoDiv.textContent = `Выбран клиент: ${client.full_name} (${client.client_code_prefix || ''}${client.client_code_num || 'Нет кода'})`;
             clientInfoDiv.classList.remove('hidden');
        }
        // Запускаем загрузку заказов этого клиента
        loadClientOrdersForCalculation(client.id);
    });
}

// --- Загрузка и отображение заказов клиента ДЛЯ РАСЧЕТА ---
async function loadClientOrdersForCalculation(clientId) {
    console.log(`[Calculate Modal] Загрузка заказов для клиента ID: ${clientId}`);
    const ordersListDiv = document.getElementById('calc-orders-list');
    const step2Div = document.getElementById('calc-step-2-orders');
    const step3Div = document.getElementById('calc-step-3-calculation');
    const step4Div = document.getElementById('calc-step-4-actions');

    if (!ordersListDiv || !step2Div || !step3Div || !step4Div) return; // Проверка

    ordersListDiv.innerHTML = '<p class="text-gray-500 animate-pulse">Загрузка заказов...</p>';
    step2Div.classList.remove('hidden'); // Показываем блок выбора заказов
    step3Div.classList.add('hidden');    // Скрываем блок расчета
    step4Div.classList.add('hidden');    // Скрываем блок действий

    try {
        // Формируем URL для получения заказов ТОЛЬКО этого клиента и НЕ выданных
        const params = new URLSearchParams({ client_id: clientId });

        // --- ИСПРАВЛЕНИЕ: ДОБАВЛЯЕМ ID КОМПАНИИ ---
        if (!currentCompany || !currentCompany.id) {
            console.error("!!! [Calculate Modal] КРИТИЧЕСКАЯ ОШИБКА: Не удалось определить ID компании (currentCompany.id) для запроса заказов!");
            ordersListDiv.innerHTML = '<p class="text-red-500">Ошибка: Не удалось определить ID компании.</p>';
            return; // Прерываем выполнение
        }
        params.append('company_id', currentCompany.id);
        // --- КОНЕЦ ИСПРАВЛЕНИЯ ---

        // Добавляем все статусы, кроме "Выдан"
        orderStatuses.filter(s => s !== 'Выдан').forEach(s => params.append('statuses', s));

        // Выполняем запрос к API (используем существующий эндпоинт GET /api/orders)
        // Теперь URL будет содержать client_id, company_id и statuses
        const clientOrders = await apiFetch(`/api/orders?${params.toString()}`);

        if (!clientOrders || clientOrders.length === 0) {
            ordersListDiv.innerHTML = '<p class="text-gray-500">У этого клиента нет заказов для расчета (кроме выданных).</p>';
            return;
        }

        // Генерируем HTML для списка заказов с чекбоксами
        ordersListDiv.innerHTML = clientOrders.map(order => `
            <div class="flex items-center justify-between py-1">
                <div class="flex items-center">
                    <input type="checkbox" id="calc-order-${order.id}" value="${order.id}"
                           class="calc-order-checkbox h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500"
                           data-track-code="${order.track_code}"
                           data-order-json='${JSON.stringify(order)}'> <label for="calc-order-${order.id}" class="ml-3 block text-sm text-gray-900">
                        ${order.track_code} <span class="text-xs text-gray-500">(${order.status})</span>
                    </label>
                </div>
                <span class="text-xs text-blue-600">
                    ${order.calculated_weight_kg ? `Вес: ${order.calculated_weight_kg} кг` : ''}
                    ${order.calculated_final_cost_som ? ` / Цена: ${order.calculated_final_cost_som.toFixed(0)} сом` : ''}
                </span>
            </div>
        `).join('');

        // Добавляем обработчики на чекбоксы заказов ПОСЛЕ их создания
        ordersListDiv.querySelectorAll('.calc-order-checkbox').forEach(cb => {
            // Удаляем старый слушатель перед добавлением нового
            const newCb = cb.cloneNode(true);
            cb.parentNode.replaceChild(newCb, cb);
            newCb.addEventListener('change', handleCalculationCheckboxChange);
        });
        console.log(`[Calculate Modal] Заказы (${clientOrders.length}) загружены и отображены.`);

    } catch (error) {
        console.error("!!! [Calculate Modal] Ошибка загрузки заказов:", error);
        ordersListDiv.innerHTML = `<p class="text-red-500">Ошибка загрузки заказов: ${error.message}</p>`;
    }
}

// --- Обработчик для чекбокса "Выбрать все" в окне расчета ---
function handleCalcSelectAllOrders(e) {
    const isChecked = e.target.checked;
    console.log(`[Calculate Modal] Select all checkbox changed to: ${isChecked}`);
    // Находим все чекбоксы заказов ВНУТРИ МОДАЛЬНОГО ОКНА
    document.querySelectorAll('#calc-orders-list .calc-order-checkbox').forEach(cb => {
        cb.checked = isChecked; // Устанавливаем то же состояние
    });
    // Вызываем обработчик изменения, чтобы показать/скрыть блок расчета и обновить поля
    handleCalculationCheckboxChange();
}

// --- Обработчик изменения любого чекбокса заказа в окне расчета ---
function handleCalculationCheckboxChange() {
    // Находим все ОТМЕЧЕННЫЕ чекбоксы заказов в модалке
    const checkedCheckboxes = document.querySelectorAll('#calc-orders-list .calc-order-checkbox:checked');
    const calculationDiv = document.getElementById('calc-step-3-calculation');
    const actionsDiv = document.getElementById('calc-step-4-actions');
    const individualWeightsDiv = document.getElementById('calc-individual-weights');

    // Проверяем, есть ли отмеченные
    if (checkedCheckboxes.length > 0) {
        console.log(`[Calculate Modal] ${checkedCheckboxes.length} orders selected. Showing calculation steps.`);
        // Если выбран хотя бы один заказ, показываем блоки расчета и кнопок
        if(calculationDiv) calculationDiv.classList.remove('hidden');
        if(actionsDiv) actionsDiv.classList.remove('hidden');
        if(!individualWeightsDiv) return; // Выходим, если контейнер для веса не найден

        // Генерируем поля для ввода веса только для ВЫБРАННЫХ заказов
        individualWeightsDiv.innerHTML = ''; // Очищаем предыдущие поля
        checkedCheckboxes.forEach(cb => {
            const orderId = cb.value;
            const trackCode = cb.dataset.trackCode;
            let orderData = {};
            try { // Пытаемся получить полные данные заказа из data-атрибута
                 orderData = JSON.parse(cb.dataset.orderJson);
            } catch(e) { console.warn("Could not parse order data from checkbox", e); }
            // Берем сохраненный вес (calculated_weight_kg), если он есть
            const prefilledWeight = orderData?.calculated_weight_kg || '';

            // Добавляем HTML для поля ввода веса
            individualWeightsDiv.innerHTML += `
                <div class="flex justify-between items-center border-b pb-1 mb-1"> <span class="font-semibold text-sm">${trackCode}</span>
                    <input type="number" step="any" placeholder="Вес (кг)"
                           class="calc-weight-input w-24 p-1 border rounded text-sm"
                           data-order-id="${orderId}" value="${prefilledWeight}" required>
                </div>
            `;
        });

        // Добавляем слушатели для ТОЛЬКО ЧТО созданных полей расчета
        addCalculationListeners();
        // Сразу пересчитываем стоимость с предзаполненными данными
        updateCalculationTotals();

    } else {
        console.log("[Calculate Modal] No orders selected. Hiding calculation steps.");
        // Если ни один заказ не выбран, скрываем блоки и очищаем поля веса
        if(calculationDiv) calculationDiv.classList.add('hidden');
        if(actionsDiv) actionsDiv.classList.add('hidden');
        if(individualWeightsDiv) individualWeightsDiv.innerHTML = '';
    }
     // Обновляем состояние чекбокса "Выбрать все"
     updateCalcSelectAllCheckboxState();
}

// Обновляет состояние чекбокса "Выбрать все" ВНУТРИ ОКНА РАСЧЕТА
function updateCalcSelectAllCheckboxState() {
     const selectAllCheckbox = document.getElementById('calc-select-all-orders');
     if (!selectAllCheckbox) return;

     const allCheckboxes = document.querySelectorAll('#calc-orders-list .calc-order-checkbox');
     const checkedCount = document.querySelectorAll('#calc-orders-list .calc-order-checkbox:checked').length;

     if (allCheckboxes.length === 0) {
         selectAllCheckbox.checked = false;
         selectAllCheckbox.indeterminate = false;
     } else if (checkedCount === 0) {
         selectAllCheckbox.checked = false;
         selectAllCheckbox.indeterminate = false;
     } else if (checkedCount === allCheckboxes.length) {
         selectAllCheckbox.checked = true;
         selectAllCheckbox.indeterminate = false;
     } else {
         selectAllCheckbox.checked = false;
         selectAllCheckbox.indeterminate = true;
     }
}

// --- Добавление слушателей к полям расчета (вес, цена, курс) ---
// Вызывается из handleCalculationCheckboxChange ПОСЛЕ создания полей веса
function addCalculationListeners() {
    console.log("[Calculate Modal] Adding listeners to calculation inputs.");
    // Общий вес (используем replaceAndListenCalc для надежности)
    const replaceAndListenCalc = (id, event, handler) => {
        const element = document.getElementById(id);
        if (element) {
            const newElement = element.cloneNode(true);
            element.parentNode?.replaceChild(newElement, element);
            newElement.addEventListener(event, handler);
        }
    };
    replaceAndListenCalc('calc-total-weight-input', 'input', handleTotalWeightChange);

    // Индивидуальные веса (находим ВСЕ и привязываем слушатель)
    document.querySelectorAll('.calc-weight-input').forEach(input => {
        // Удаляем старый слушатель перед добавлением нового
        const newInput = input.cloneNode(true);
        input.parentNode?.replaceChild(newInput, input);
        // Добавляем слушатель к новому элементу
        newInput.addEventListener('input', () => {
             // Сбрасываем общий вес, если начали вводить индивидуальный
            const totalWeightInp = document.getElementById('calc-total-weight-input');
            if(totalWeightInp) totalWeightInp.value = '';
            // Пересчитываем итоговую сумму
            updateCalculationTotals();
        });
    });

    // Цена и курс
    replaceAndListenCalc('calc-price-per-kg', 'input', updateCalculationTotals);
    replaceAndListenCalc('calc-exchange-rate', 'input', updateCalculationTotals);
}

// --- Обработчик изменения общего веса (для авто-распределения) ---
function handleTotalWeightChange() {
    const totalWeightInput = document.getElementById('calc-total-weight-input');
    const totalWeight = parseFloat(totalWeightInput?.value) || 0; // Безопасное получение значения
    const individualInputs = document.querySelectorAll('.calc-weight-input');

    console.log(`[Calculate Modal] Total weight changed: ${totalWeight}`);

    // Распределяем вес, только если он >= 0 и есть поля для распределения
    if (totalWeight >= 0 && individualInputs.length > 0) {
        const weightPerItem = (totalWeight / individualInputs.length).toFixed(3); // Распределяем поровну, 3 знака после запятой
        console.log(`[Calculate Modal] Auto-distributing weight: ${weightPerItem} kg per item.`);
        individualInputs.forEach(input => { input.value = weightPerItem; });
    } else if (totalWeight < 0) {
         console.warn("[Calculate Modal] Total weight cannot be negative.");
         if(totalWeightInput) totalWeightInput.value = ''; // Сбрасываем отрицательное значение
         individualInputs.forEach(input => { input.value = ''; }); // Очищаем индивидуальные
    } else {
        // Если общий вес убрали или 0, очищаем индивидуальные
        console.log("[Calculate Modal] Clearing individual weights.");
        individualInputs.forEach(input => { input.value = ''; });
    }
    // Пересчитываем итоговую сумму в любом случае
    updateCalculationTotals();
}

// --- Пересчет и отображение итоговой стоимости ---
function updateCalculationTotals() {
    const priceInput = document.getElementById('calc-price-per-kg');
    const rateInput = document.getElementById('calc-exchange-rate');
    const totalCostDisplay = document.getElementById('calc-total-cost-display');

    // Проверки на наличие элементов
    if (!priceInput || !rateInput || !totalCostDisplay) {
         console.error("!!! updateCalculationTotals: Missing required elements.");
         return;
    }

    const price = parseFloat(priceInput.value) || 0;
    const rate = parseFloat(rateInput.value) || 0;
    let currentTotalWeight = 0;
    // Суммируем значения из ВСЕХ полей индивидуального веса
    document.querySelectorAll('.calc-weight-input').forEach(input => {
        currentTotalWeight += parseFloat(input.value) || 0;
    });

    // Рассчитываем итоговую стоимость
    const totalCost = currentTotalWeight * price * rate;
    // Отображаем результат, форматируя до 2 знаков после запятой
    totalCostDisplay.textContent = `${totalCost.toFixed(2)} сом`;
    // console.log(`[Calculate Modal] Totals updated: Weight=${currentTotalWeight.toFixed(3)}, Price=${price}, Rate=${rate}, TotalCost=${totalCost.toFixed(2)}`);
}

// --- Сохранение расчета (вызывается кнопкой "Сохранить") ---
async function saveCalculation() {
    console.log("[Calculate Modal] saveCalculation: Start");
    // Находим все отмеченные чекбоксы заказов
    const selectedCheckboxes = document.querySelectorAll('#calc-orders-list .calc-order-checkbox:checked');
    // Получаем значения цены и курса
    const pricePerKgInput = document.getElementById('calc-price-per-kg');
    const exchangeRateInput = document.getElementById('calc-exchange-rate');
    const pricePerKg = parseFloat(pricePerKgInput?.value);
    const exchangeRate = parseFloat(exchangeRateInput?.value);
    // Получаем выбранный новый статус (или null, если "-- Не менять --")
    const statusSelect = document.getElementById('calc-new-status-select');
    const newStatus = statusSelect?.value || null;

    // --- Собираем данные по весу для каждого выбранного заказа ---
    const ordersPayloadItems = []; // Массив для отправки на бэкенд
    let hasInvalidWeight = false; // Флаг для проверки корректности веса
    selectedCheckboxes.forEach(cb => {
        const orderId = parseInt(cb.value);
        // Находим соответствующее поле ввода веса
        const weightInput = document.querySelector(`.calc-weight-input[data-order-id="${orderId}"]`);
        const weight = parseFloat(weightInput?.value);

        // Проверяем, что вес введен и он больше нуля
        if (!weight || weight <= 0) {
            hasInvalidWeight = true; // Ставим флаг, если вес некорректен
            if(weightInput) weightInput.classList.add('border-red-500'); // Подсвечиваем неверное поле
        } else {
            if(weightInput) weightInput.classList.remove('border-red-500'); // Убираем подсветку
        }
        // Добавляем данные заказа в массив (даже если вес некорректен, чтобы проверка сработала)
        ordersPayloadItems.push({ order_id: orderId, weight_kg: weight || 0 });
    });

    // --- Проверки перед отправкой ---
    if (ordersPayloadItems.length === 0) {
        alert('Не выбрано ни одного заказа для расчета.');
        return;
    }
    if (hasInvalidWeight) {
        alert('Ошибка: Вес должен быть указан (больше нуля) для всех выбранных заказов. Проверьте подсвеченные поля.');
        return;
    }
    // Проверяем цену и курс
    let validationError = false;
    if (!pricePerKg || pricePerKg <= 0) {
        alert('Ошибка: Укажите корректную цену за кг (больше нуля).');
        if(pricePerKgInput) pricePerKgInput.classList.add('border-red-500');
        validationError = true;
    } else {
         if(pricePerKgInput) pricePerKgInput.classList.remove('border-red-500');
    }
    if (!exchangeRate || exchangeRate <= 0) {
        alert('Ошибка: Укажите корректный курс USD (больше нуля).');
        if(exchangeRateInput) exchangeRateInput.classList.add('border-red-500');
        validationError = true;
    } else {
         if(exchangeRateInput) exchangeRateInput.classList.remove('border-red-500');
    }
    if(validationError) return; // Прерываем, если есть ошибки валидации

    // Формируем тело запроса для API
    const payload = {
        orders: ordersPayloadItems,      // Список заказов с весом
        price_per_kg_usd: pricePerKg,    // Цена
        exchange_rate_usd: exchangeRate, // Курс
        new_status: newStatus            // Новый статус (или null)
    };

    console.log("[Calculate Modal] Отправка данных на /api/orders/calculate:", payload);
    showLoader(); // Показываем индикатор загрузки

    try {
        // Выполняем POST запрос к новому эндпоинту
        const response = await apiFetch('/api/orders/calculate', {
            method: 'POST',
            body: JSON.stringify(payload)
        });

        console.log("[Calculate Modal] Server response:", response);
        alert(response.message || 'Расчет успешно сохранен!');
        closeModal('calculate-modal'); // Закрываем модальное окно

        // Обновляем список заказов на основной вкладке "Заказы"
        // Вызываем fetchAndRenderOrders, чтобы загрузить свежие данные (включая обновленные статусы и расчеты)
        await fetchAndRenderOrders();
        console.log("[Calculate Modal] Список заказов на основной вкладке обновлен.");

    } catch (error) { // Обработка ошибок от API
        console.error("!!! [Calculate Modal] Ошибка при сохранении расчета:", error);
        alert(`Ошибка при сохранении расчета: ${error.message}`);
        // Оставляем модальное окно открытым при ошибке
    } finally {
        hideLoader(); // Скрываем индикатор загрузки
        console.log("[Calculate Modal] saveCalculation: End");
    }
}

// === КОНЕЦ: Логика модального окна Расчета ===

// =================================================================
// МОДУЛЬ: НАСТРОЙКИ (Владелец)
// =================================================================

// Кэш для настроек
let companySettings = {}; // { key: value, ... }

// --- Рендеринг вкладки "Настройки" ---
async function renderSettingsTab() {
    console.log("[Render] renderSettingsTab: Start");
    const pane = document.getElementById('tab-settings');
    if (!pane) return;

    // Генерируем HTML для вкладки
    pane.innerHTML = `
        <div class="bg-white p-6 rounded-lg shadow-md max-w-2xl mx-auto">
            <h2 class="text-2xl font-bold mb-4">Настройки Компании</h2>

            <div class="border-b border-gray-200 mb-6">
                <nav class="-mb-px flex space-x-8" id="settings-subtabs">
                    <button data-subtab="settings-main" class="setting-subtab-btn tab-btn whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm border-indigo-500 text-indigo-600">Основные</button>
                    <button data-subtab="settings-passwords" class="setting-subtab-btn tab-btn whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm border-transparent text-gray-500 hover:text-gray-700">Пароли</button>
                </nav>
            </div>

            <form id="settings-form" class="space-y-6">

                <div id="subtab-settings-main" class="setting-subtab-pane space-y-6">
                    <div>
                        <label for="setting-china-address" class="block text-sm font-medium text-gray-700">Адрес склада в Китае</label>
                        <p class="text-xs text-gray-500 mb-1">Используйте <code>{{client_code}}</code> для подстановки кода клиента.</p>
                        <textarea id="setting-china-address" data-key="china_warehouse_address" class="setting-input w-full p-2 border rounded-md h-24 font-mono"></textarea>
                    </div>

                    <div>
                        <label for="setting-pdf-link" class="block text-sm font-medium text-gray-700">Ссылка на PDF с инструкцией</label>
                        <p class="text-xs text-gray-500 mb-1">Полная ссылка (https://...) для кнопки в боте.</p>
                        <input type="url" id="setting-pdf-link" data-key="instruction_pdf_link" class="setting-input w-full p-2 border rounded-md" placeholder="https://.../instruction.pdf">
                    </div>

                <div>
                    <label for="setting-client-code-start" class="block text-sm font-medium text-gray-700">Начальный номер для кодов клиентов</label>
                    <p class="text-xs text-gray-500 mb-1">Новые клиенты (созданные в админке или боте) будут получать код, начиная с этого номера (например: 1001, 1400).</p>
                    <input type="number" id="setting-client-code-start" data-key="client_code_start" class="setting-input w-full p-2 border rounded-md" placeholder="1001">
                </div>
                </div>

                <div id="subtab-settings-passwords" class="setting-subtab-pane space-y-6 hidden">
                    <p class="text-sm text-gray-600">Установите пароли для опасных действий. Если поле оставить <b>пустым</b>, пароль запрашиваться не будет.</p>

                    <div>
                        <label for="setting-pass-revert-order" class="block text-sm font-medium text-gray-700">Пароль на <b>Возврат</b> выданного заказа</label>
                        <input type="text" id="setting-pass-revert-order" data-key="password_revert_order" class="setting-input w-full p-2 border rounded-md">
                    </div>

                    <div>
                        <label for="setting-pass-delete-order" class="block text-sm font-medium text-gray-700">Пароль на <b>Удаление</b> заказа</label>
                        <input type="text" id="setting-pass-delete-order" data-key="password_delete_order" class="setting-input w-full p-2 border rounded-md">
                    </div>

                    <div>
                        <label for="setting-pass-delete-client" class="block text-sm font-medium text-gray-700">Пароль на <b>Удаление</b> клиента</label>
                        <input type="text" id="setting-pass-delete-client" data-key="password_delete_client" class="setting-input w-full p-2 border rounded-md">
                    </div>
                </div>

                <div class="border-t pt-4">
                    <button type="submit" class="w-full bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-700">Сохранить Настройки</button>
                </div>
            </form>
        </div>
    `;

    // Привязываем слушатель к форме
    const form = document.getElementById('settings-form');
    if (form) {
        form.replaceWith(form.cloneNode(true)); // Очищаем старые
        document.getElementById('settings-form').addEventListener('submit', handleSaveSettings);
        console.log("[Listener OK] Added submit to #settings-form");
    }

    // Привязываем слушатель к под-вкладкам
    const subtabsContainer = document.getElementById('settings-subtabs');
    if (subtabsContainer) {
        subtabsContainer.addEventListener('click', e => {
            const tabButton = e.target.closest('.setting-subtab-btn');
            if (tabButton) {
                const tabName = tabButton.dataset.subtab;
                // Стилизация кнопок
                document.querySelectorAll('.setting-subtab-btn').forEach(btn => {
                    btn.classList.remove('border-indigo-500', 'text-indigo-600');
                    btn.classList.add('border-transparent', 'text-gray-500');
                });
                tabButton.classList.add('border-indigo-500', 'text-indigo-600');
                tabButton.classList.remove('border-transparent', 'text-gray-500');
                // Показ/скрытие панелей
                document.querySelectorAll('.setting-subtab-pane').forEach(pane => {
                    pane.classList.toggle('hidden', pane.id !== `subtab-${tabName}`);
                });
            }
        });
        console.log("[Listener OK] Added click to #settings-subtabs");
    }

    // Загружаем и отображаем текущие настройки
    await fetchAndRenderSettings();
}

// --- Загрузка и отображение Настроек ---
async function fetchAndRenderSettings() {
    console.log("[Fetch] fetchAndRenderSettings: Start");
    showLoader();
    try {
        const settingsList = await apiFetch('/api/settings'); // Получаем список [{key: k, value: v}, ...]
        
        // Преобразуем список в удобный объект (кэш)
        companySettings = settingsList.reduce((acc, setting) => {
            acc[setting.key] = setting.value;
            return acc;
        }, {});
        
        console.log("[Fetch] fetchAndRenderSettings: Settings loaded:", companySettings);

        // Заполняем поля ввода
        document.querySelectorAll('.setting-input').forEach(input => {
            const key = input.dataset.key;
            if (companySettings.hasOwnProperty(key)) {
                input.value = companySettings[key] || '';
            }
        });

    } catch (e) {
        console.error("[Fetch] fetchAndRenderSettings: Error", e);
        alert(`Ошибка загрузки настроек: ${e.message}`);
    } finally {
        hideLoader();
    }
}

// --- Сохранение Настроек ---
async function handleSaveSettings(e) {
    e.preventDefault();
    console.log("[Save] handleSaveSettings: Start");
    showLoader();
    
    // Собираем данные из всех полей с классом 'setting-input'
    const settingsToSave = {};
    document.querySelectorAll('.setting-input').forEach(input => {
        const key = input.dataset.key;
        if (key) {
            settingsToSave[key] = input.value.trim() || null;
        }
    });
    
    const payload = {
        settings: settingsToSave
    };

    try {
        console.log("[Save] handleSaveSettings: Sending payload:", payload);
        const updatedSettingsList = await apiFetch('/api/settings', {
            method: 'PUT',
            body: JSON.stringify(payload)
        });
        
        // Обновляем кэш
        companySettings = updatedSettingsList.reduce((acc, setting) => {
            acc[setting.key] = setting.value;
            return acc;
        }, {});
        
        console.log("[Save] handleSaveSettings: Settings saved successfully.");
        alert("Настройки успешно сохранены!");

    } catch (err) {
        console.error("[Save] handleSaveSettings: Error", err);
        alert(`Ошибка сохранения настроек: ${err.message}`);
    } finally {
        hideLoader();
    }
}


</script>
</body>
</html>